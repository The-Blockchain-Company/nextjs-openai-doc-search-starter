> **Ouroboros Genesis: Composable Proof-of-Stake Blockchains with**

**Dynamic Availability**

Christian Badertscher*^?^*, Peter Gaˇzi*^??^*, Aggelos
Kiayias*^?\ ?\ ?^*, Alexander Russell*^†^*, and Vassilis Zikas*^‡^*

> February 22, 2019
>
> **Abstract.** Proof-of-stake-based (in short, PoS-based) blockchains
> aim to overcome scalability, efficiency, and composability limitations
> of the proof-of-work paradigm, which underlies the security of several
> mainstream cryptocurrencies including Bitcoin.
>
> Our work puts forth the first (global universally) composable (GUC)
> treatment of PoS-based blockchains in a setting that captures---for
> the first time in GUC---arbitrary numbers of parties that may not be
> fully operational, e.g., due to network problems, reboots, or updates
> of their OS that affect all or just some of their local resources
> including their network interface and clock. This setting, which we
> refer to as *dynamic availability*, naturally captures decentralized
> environments within which real-world deployed blockchain protocols are
> assumed to operate.
>
> We observe that *none* of the existing PoS-based blockchain protocols
> can realize the ledger functionality under dynamic availability in the
> same way that Bitcoin does (using only the information available in
> the genesis block). To address this we propose a new PoS-based
> protocol, "Ouroboros Genesis", that adapts one of the latest
> cryptographically-secure PoS-based blockchain protocols with a novel
> *chain selection rule*. The rule enables new or offline parties to
> safely (re-)join and bootstrap their blockchain only from a trusted
> copy of the genesis block without any additional advice---such as
> checkpoints---or assumptions regarding past availability. We say that
> such a blockchain protocol can "bootstrap from genesis."
>
> We prove the GUC security of Ouroboros Genesis against a fully
> adaptive adversary controlling less than half of the total stake. Our
> model allows adversarial scheduling of messages in a network with
> delays and captures the dynamic availability of participants in the
> worst case. Importantly, our protocol is effectively independent of
> both the maximum network delay and the minimum level of
> availability--- both of which are run-time parameters. Proving the
> security of our construction against an adaptive adversary requires a
> novel martingale technique that may be of independent interest in the
> analysis of blockchain protocols.

# 1 Introduction

> The primary real-world use of blockchains, thus far, has been to offer
> a platform for decentralized cryptocurrencies with various
> capabilities \[26, 5\]. A unique feature of blockchain protocols (in
> contrast to standard multiparty computation) from which the setting
> draws much of its appeal is the fact that the parties that run the
> protocol may engage only in passing with the protocol and need not
> identify themselves to other protocol participants. In fact, the
> Bitcoin blockchain protocol remains robust in the presence of a
> Byzantine adversary even if parties arbitrarily desynchronize, join at
> any moment of the execution, or go offline for arbitrary periods of
> time (a set of execution features that we will refer to as *dynamic
> availability*), as long as a majority of hashing power is always
> following the protocol.
>
> Motivated by this novel setting, several applications have recently
> emerged that use blockchains (or the cryptocurrencies that build on
> top of them) as enablers for other cryptographic protocols. For
> example, a
>
> *?*
>
> University of Edinburgh and IOHK, christian.badertscher@ed.ac.uk. Work
> done while at ETH Zurich.
>
> *??*

IOHK, peter.gazi@iohk.io. *? ? ?*

> University of Edinburgh and IOHK. akiayias@inf.ed.ac.uk. Research
> partly supported by EU Project No. 780477, PRIVILEDGE.
>
> *†*
>
> University of Connecticut and IOHK. acr@cse.uconn.edu. This material
> is based upon work supported by the National Science Foundation under
> Grant No. 1717432.
>
> *‡*
>
> University of Edinburgh and IOHK. vassilis.zikas@ed.ac.uk.
>
> number of recent work \[2, 4, 24, 23, 1\] describe how
> blockchain-based cryptocurrencies can be used to obtain a[^1]natural
> notion of fairness in multi-party computation against dishonest
> majorities; or to allow parties to play games of chance---e.g., card
> games like poker, lottery-based games, etc.---without the need of a
> trusted third party; or how to use blockchains as bulletin boards in
> electronic voting. Such developments---in conjunction with the direct
> applicability to cryptocurrencies---have led to a pressing need for a
> general, formal security analysis of the functionality that blockchain
> protocols provide.
>
> Recently, Badertscher et al. \[3\] put forth the first composable
> analysis of Bitcoin, by proving that it implements, in a universally
> composable (UC) manner, an immutable transaction ledger. This improved
> on previous works \[17, 27\] that provided a game-based security
> analyses and rigorously described an ideal ledger that provides an
> answer to the question: What is the goal that Bitcoin aims to achieve?
> The advantage of such a UC treatment of blockchains is that it allows
> for a modular design and security analysis of the above cryptographic
> applications of blockchains.
>
> Notwithstanding, the wide adoption of Bitcoin has revealed some
> serious efficiency and (in)composability issues. The efficiency issues
> stem from the fact that it relies on *proof-of-work* (in short,
> *PoW*), a cryptographic puzzle-solving procedure with increasing
> difficulty as more parties join the system.^1^ Composability issues
> are due to the fact that the puzzle-solving procedure can, in
> principle, be useful also for other protocols--- independent from the
> Bitcoin mining process.[^2] This means that one cannot exclude the
> possibility that an adversarial miner, participating in such an
> independent protocol *π* and in Bitcoin in parallel, can potentially
> double the value of his effort, by using the same hash query both for
> *π* and for Bitcoin.
>
> The demand for blockchain solutions that do not suffer from the above
> issues gave rise to an exciting recent line of work that propose to
> use alternative resources to achieve consensus and maintain a robust
> ledger. The most popular such resource is *stake* in the system.
> Informally, instead of requiring a party to invest computing power in
> order to be allowed to extend the blockchain, parties are given the
> chance to do so according to their *stake* in the system, e.g., the
> number of coins they own. This paradigm, often referred to as
> *proof-of-stake* (in short *PoS*), has yielded a number of proposals
> for PoS-based blockchains.[^3]
>
> Several of these PoS-based proposals originated from the cryptographic
> community, e.g., Algorand \[19\], Snow White \[13\], and
> Ouroboros/Ouroboros Praos \[22, 14\]. As such they are accompanied by
> a formal security proof that they achieve a well defined set of
> desirable properties. Alas, these protocols severely restrict the
> dynamic availability of participants: Snow White \[13\] and
> Ouroboros/Ouroboros Praos \[22, 14\] require an honest blockchain to
> be delivered as trusted "advice" to any joining party---a form of
> "checkpointing", while Algorand \[19\] requires the explicit knowledge
> of a good estimate of the number of offline parties. Furthermore, all
> these works focus on a property-based specification of the provided
> security guarantees, i.e., they prove that they achieve a desirable
> set of properties. Such property-based definitions are known not to
> ensure, in general, the composability of the proposed schemes \[8, 10,
> 20\]. This leaves the following questions open:

-   *Can PoS offer the same level of dynamic availability guarantees as
    PoW? In particular, joining without checkpointing advice or the
    knowledge of other parties' online/offline status?*

-   *What is the ideal functionality implemented by PoS-based
    blockchains? How does it compare to the one implemented by PoW?*

-   *Does PoS suffer from the same incomposability issues as PoW?*

> Our work addresses all the above questions. We put forth the first UC
> treatment of PoS-based blockchains. Our model captures for the first
> time dynamic availability and provides a fine-grained classification
> of failures that determine all different settings that an honest
> protocol participant may find itself in during the protocol execution.
> Given that none of the existing PoS protocols provide such strong
> guarantees, we describe and analyze a new protocol based on Ouroboros
> Praos \[14\]. The major structural change towards our new protocol,
> which we call Ouroboros Genesis, is a novel chain selection rule that
> enables joining parties to "bootstrap" only from a trusted copy of the
> genesis block. We prove that the protocol UC-securely implements the
> natural ledger functionality proposed in \[3\]---the very same
> functionality shown to be possessed by Bitcoin. We prove security in
> the setting of dynamic availability under the assumption of standard
> cryptographic primitives, an initialization functionality that is akin
> to public-key registration and a global random oracle which is a
> natural abstraction of deterministic hash functions. Our contributions
> are discussed in more detail below.
>
> **Our Contributions.** Our work provides a Universally Composable (UC)
> \[8\] treatment of proof-of-stakebased blockchains. To obtain a tight
> abstraction of the real-world setting and stronger composability
> guarantees, our treatment is in the UC model with *global setups*,
> a.k.a. GUC \[9\]; note that all our statements trivially apply also to
> the standard UC model by considering global setups as ideal UC
> functionalities.[^4]Dynamic Availability. Our first contribution is
> capturing in an accurate manner the guarantees that any such protocol
> can give to freshly joining parties and/or parties with temporary
> connectivity/availability issues, a setting that we call dynamic
> availability. More concretely, our model distinguishes several classes
> of honest parties, based on:

-   whether the party has access to all three resources it needs (i.e.,
    is registered with the respective functionalities): the random
    oracle, the clock, and the network (see Fig. 1 for the detailed
    enumeration of these classes);

-   whether the party has been able to follow the protocol in such a
    state for sufficiently long to be guaranteed to hold a synchronized
    view of the ledger (we call such parties *synchronized*). More
    specifically, we will describe a parameter called Delay (a function
    of the network delay *∆*) that determines the time sufficient for a
    party with access to all resources to become fully synchronized with
    the state of the protocol. We stress that Delay is a parameter that
    is unknown to the protocol participants, thus it is impossible for a
    party to determine whether it is already synchronized.

> This detailed classification allows us to precisely capture the
> following derived party classes that will be essential for describing
> the security guarantees provided by our protocol:

-   *Alert parties* are parties that have access to all the required
    resources, and are also synchronized. These parties enjoy full
    security guarantees and we will require a lower bound on their
    number (see below) to ensure security.

-   *Potentially active parties* (or *active* for short) are all parties
    that, broadly speaking, might potentially act in the current time
    slot of the protocol execution. This includes honest parties that
    have access to all the required resources as well as adversarial
    parties. Note that honest parties who lose access to clock are also
    potentially active, as they are not able to reliably evolve their
    private state, and hence it cannot be excluded that if they later
    get corrupted, they might act retroactively.

-   *Inactive Parties* are all other parties, such as honest parties
    that cannot access some of the necessary resources to engage with
    the protocol, e.g., their network connection. Per protocol rules,
    such parties abstain from active participation until that access is
    regained.

> Our objective is to realize the ledger functionality given the
> following two conditions:

(A) *The ratio α of the number of alert over the active parties is
    above* 1*/*2*; the difference is by a constant that is sufficiently
    large to absorb the partial synchrony delay parameter ∆.*

> In particular (and similar to the Bitcoin blockchain, see \[17, 27\])
> the protocol will use a parameter *f* and will permit a meaningful
> security guarantee provided that a suitable relation between *f* and
> *∆* is satisfied. For a fixed choice of *f*, the larger the delay *∆*
> is, the larger the difference between 1*/*2 and the alert over active
> ratio should be. Note that this condition is simply a translation of
> the standard honest-majority assumption into our dynamic-availability
> setting.

(B) *The ratio β of the number of active over all parties is bounded
    from* 0 *by some arbitrary constant that is unknown to the protocol
    participants.*

> This necessary assumption provides an upper bound on the probability
> that *no* party will be able to act in the protocol at a given time
> (if it fails the protocol may halt).
>
> It is instructive to consider what role various party classes play in
> the above assumptions. In particular, let us stress that the stake of
> inactive parties, such as those that have lost (or given up) their
> network connection or their access to the random oracle, does not
> count as adversarial; in other words, they do not affect the ratio
> considered in Assumption (A) above.
>
> The above guarantees (and the corresponding assumptions) are arguably
> natural. However, none of the existing PoS protocols provides them
> without additional assumptions and/or restrictions to the adversary's
> capabilities. Concretely, existing solutions and proposals \[22, 13,
> 14, 6\] either forfeit dynamic availability and assume honest parties
> are regularly online or rely on an assumption that joining (or
> resuming) parties are implicitly given access to a *checkpointing*
> functionality, which serves them a trusted recent honest chain and is
> supposed to be implemented either "for-free" by the environment or by
> some fortuitous network connection to existing honest parties. This
> solves the problem of joining parties getting up to speed with the
> correct chain---which is the main challenge here--but is arguably a
> strong assumption. To see this, note that given such a functionality
> parties only need to deregister and register in order to obtain
> eventual consensus, which completely trivializes the main goal of a
> blockchain protocol. One can attempt to avoid such trivialization by
> restricting the interval between deregistration and reregistration, or
> even forbidding it, but this makes the assumption somewhat artificial
> and excludes natural scenarios from the analysis, such as short-term
> unavailability (e.g. due to a system crash, network outage,
> maintenance, or update restart). We also note that even with the
> assumption of such an additional checkpointing functionality, there is
> no existing PoS solution which can tolerate both the optimal threshold
> of adversarial stake ratio approaching 1/2, and full adaptivity in
> corruptions and in the (re-)joining schedule, i.e.,
> (re-)registration/deregistration.
>
> Note that the PoS protocol Algorand \[19\] does not require such
> checkpointing or parties being regularly online, however it requires a
> good estimate on participation to be fixed in the protocol, thus
> forfeiting dynamic availability as well. This requirement stems from
> the fact that the core of the protocol runs a Byzantine agreement
> sub-protocol that requires to be able to know (bounds on) the level of
> expected participation and hence estimate in advance the number of
> messages that are required to proceed with key protocol decisions. A
> PoS Blockchain with Bootstrapping from Genesis. Given the deficiencies
> of existing protocols to handle dynamic availability we present a new
> protocol, Ouroboros Genesis, that is based on a recent PoS protocol,
> Ouroboros Praos \[14\]. The novelty of our protocol lies in its chain
> selection rule that instantiates the so-called maxvalid procedure in
> \[17, 22, 3, 14\] in a way that allows the parties to identify a chain
> whose prefix has been part of the prefix of a recent honest chain,
> *using only knowledge of the genesis block*. For this reason we refer
> to this process as *bootstrapping from genesis*.
>
> Concretely, we prove that Ouroboros Genesis (G)UC-securely realizes
> the ledger functionality in the dynamic-availability setting, as long
> as the two essential conditions (A) and (B) introduced above are
> satisfied. Towards this goal, we develop a new technique which
> non-trivially extends the martingale argument from \[29\] so that we
> can use it to analyze an adaptive adversary in the presence of a
> worst-case (adversarial) joiningschedule. This technique is of
> independent interest, as it might prove useful for analyzing other
> PoS-based blockchains. Overall our security proof maintains the same
> cryptographic assumptions as \[14\].
>
> Global UC formalisation. As a technical contribution, along the way we
> also provide a full specification of the real-world resources needed
> for PoS as ideal functionalities and global setups in GUC. Concretely,
> following the paradigm of \[3\], we capture protocols in the (semi-)
> synchronous model as (G)UC protocols with access to a global clock
> functionality, and to a network with eventual (bounded) delivery. A
> delicate deviation from \[3\], which also formally demonstrates the
> stronger composability guarantees that PoS offers, is with respect to
> how we abstract the calls to the hash function. Concretely, we assume
> the protocol participants have access to a *global* random oracle
> setup (in short, GRO). This captures the abstraction of hash functions
> as *publicly available* random functions. This should be contrasted to
> their abstraction as a UC functionality proposed in \[3\], which is
> less composable. Intuitively, a (deterministic) hash function can be
> queried by any party, whereas a UC random-oracle functionality is
> available only to its calling protocol *π*; this implicitly restricts
> access to this functionality (and therefore the hash function it is
> supposed to abstract) on the specific protocol *π*.[^5]
>
> In fact, a closer consideration of the idiosyncrasies of PoWs reveals
> that abstracting hash-queries as calls to a GRO is not an option for
> PoW-based blockchains. This is true because of two issues: (1) at an
> intuitive level this would imply that the environment (i.e., other
> protocols) could make queries to the GRO and then share them with the
> adversary, which, as discussed above, gives "free" out-of-band
> computing resources to the adversary; (2) at the more technical level,
> the non-programmability of the GRO allows the environment to check
> that the simulator creates blocks that indeed carry sufficient work;
> but since the simulator needs to also simulate the hash queries of
> honest parties, this would only be feasible if he had a much larger
> querybudget than the adversary, which is not possible as the GRO needs
> to behave identically in the real and ideal world. We note in passing
> that in \[11\] a version of the GRO was proposed that reduces the
> power of the environment to check on the simulator; this GRO---which
> is arguably not the most realistic abstraction of hash
> functions---would still not work for PoWs because of the first issue.
> Demonstrating that PoS-based schemes can be proved in a model where
> hash functions are abstracted as GROs (which is not the case for the
> PoW setting) sheds light on the comparison between PoW and PoS.
>
> Our results and analysis thus categorically address the three
> questions posed above: Ouroboros Genesis can realise the same ledger
> functionality as Bitcoin, *G*~ledger~ \[3\], in a setting with dynamic
> availability using standard cryptographic assumptions. In particular,
> the realization proof is carried out in a model where hash-functions
> are abstracted as global random oracles which shows that the consensus
> step does not suffer from the composability issues of PoW protocols.
> We note that providing explicit realizations of all the hybrid
> functionalities in the GRO model is beyond the scope of the current
> paper. Nevertheless, we observe that PoS protocols can effectively
> drop-in replace PoW based ones with the only added requirement being
> the initialization functionality that should provide a key
> registration service as opposed to merely a common random string.
>
> **Related Work.** A number of recent works have studied---in a
> rigorous cryptographic manner---the security of existing and newly
> proposed blockchain protocols both PoW-based, e.g, \[17, 27, 3\] and
> PoS-based, e.g., \[22, 14, 28, 13, 19\]. In the PoW-based setting,
> \[3\] describes and proves the composable security guarantees of the
> most representative protocol, namely Bitcoin; furthermore, the
> security proof tolerates an adaptive adversary and achieves optimal
> resilience---the adversary can control any percentage less than 50% of
> the network's total computing power. In contrast, in the PoS-based
> setting, no simulation-based (UC) proof existed, and different
> proposed schemes tolerate different types of adversaries in terms of
> adaptivity. For example, Ouroboros \[22\] achieves only
> "semi-adaptive" security (corruptions with delay), whereas among the
> adaptively secure ones, Algorand \[19\] needs less than 1*/*3 of the
> stake of the system to be held by malicious parties, whereas Show
> White \[13\] and Ouroboros Praos \[14\] achieve the optimal 1*/*2
> bound, at the cost of needing a checkpointing functionality to
> accommodate joining parties.
>
> The idea of parties that are muted for some time but do receive their
> messages was first proposed in \[28\] where those parties were
> referred to as *sleepers*. Our modeling of such parties differs from
> (and in fact strictly generalizes) that of \[28\] in various ways:
> first, instead of describing them by means of whether they are paused
> or not, we characterize them by means of the availability of their
> resources, making clear how those parties enter this state.
> Furthermore, our notion is only affecting the PoS session that is
> being executed and thus, in our composable setting, such parties are
> not restricted as to how they should behave within other protocols
> that they concurrently participate in. To emphasize this distinction
> and the fact that they may be continuing to operate in other protocol
> sessions we use the term "stalled" for these parties (cf. Fig. 1). In
> addition to the modeling distinctions, our model allows us to obtain
> more general statements regarding the adaptivity of the adversary.
> Concretely, we can tolerate fully adaptive adversaries and worst-case
> registration/deregistration scheduling. In contrast, \[13\] tolerates
> semi-adaptive adversaries, whose corruption only takes effect after a
> certain number of rounds. Interestingly, there is no need for
> distinguishing a class of parties called deepsleepers in \[13\] (i.e.,
> those that are in sleepy mode for a prolonged time) that required
> checkpointing via a safe initialisation string and thus the related
> impossibility result in \[13\] can be circumvented. Taking advantage
> our bootstrapping from genesis chain selection rule, all parties that
> are stalling, even for prolonged periods of time, can safely
> resynchronize without the assistance of a trusted initialisation
> exactly as in the case of PoW-based protocols.
>
> **Outline of the remainder of the paper.** In Section 2 we provide a
> formal description of our model of computation, including our real and
> ideal world functionalities and setups. In Section 3 we describe
> Ouroboros Genesis as a (G)UC protocol called Ouroboros-Genesis. The
> security analysis of the protocol, i.e., the proof that it UC-securely
> realizes the ledger functionality is given in Section 4. The proof
> starts by considering the interaction of the old chain selection
> procedure from \[14\] (called maxvalid-mc here, the protocol using it
> is dubbed Ouroboros-Praos) with honest parties assumed to be connected
> to the network and synchronized (Section 4.2), gradually incorporates
> the new maxvalid-bg procedure which allows the protocol to bootstrap
> from the genesis block (Section 4.3), along with proofs that this
> procedure is sufficient to provide all the guarantees offered to newly
> joining and temporarily offline parties (Section 4.4). Finally, there
> results are transformed into the full UC statement in Section 4.5.

# 2 The Model

> This section includes the main components of the computation model
> including the real and ideal functionalities used in this work. We
> assume the reader has some familiarity with the universal composition
> (UC) framework \[8\]. In addition to the new functionalities, we make
> use of the number of already existing functionalities from the
> literature. For completeness we nonetheless include these
> functionalities in Section A of the supplementary material.
>
> UC defines security via the simulation paradigm: the protocol
> execution in the real world is compared to an ideal execution, where
> the parties have access to an ideal functionality *F* which abstracts
> the goals of the protocol. In the ideal world honest parties act as
> simply relayers between their environment *Z* and the functionality
> *F* (i.e., they run the so called *dummy* protocol \[8\]). Informally,
> security requires that the attack of any adversary against the
> (real-world) protocol can be simulated in the ideal world. More
> concretely, for any real-world adversary *A* there should exists an
> ideal-world simulator *S* that corrupts the same parties as *A* and
> makes the ideal-world execution indistinguishable from the real-world
> in the eyes of any environment *Z*.
>
> Importantly, the (real-world) protocol might be given access to some
> functionalities (often called *hybrids*), which capture the resources
> that the parties have available, e.g., their communication network. In
> standard UC, these resources appear only in the real-world---in fact
> they are formally treated as part of the protocol--- whereas GUC \[9\]
> allows such resources to be preserved in the ideal world and as such
> be accessible directly by the environment (instead of their interface
> being filtered by the protocol.) To avoid confusion with standard UC
> functionalities, the GUC resources of the above type as often referred
> to as (global) *setups*. They capture, among others, settings where
> different protocols might share a common state, and allow to address
> deniability issues that the original UC framework has \[9\].
> Furthermore, the fact that they do not disappear in the ideal world
> makes global setups more suitable for capturing universally accessible
> resources such as deterministic hash functions as discussed in the
> introduction.
>
> In the following, we describe the real-world resources that are needed
> in Ouroboros Genesis, along with the ideal world functionality that
> the protocol implements. Before doing so, we discuss some common
> conventions that we will use in the descriptions.
>
> **Dynamically available party sets.** A significant extension in the
> model of computation in our work, is the high granularity in the
> treatment of the protocol participant's availability. Concretely,
> already in \[3\] all functionalities, protocols, and global setups
> have a dynamic party set. I.e., they all include special instructions
> allowing parties to register, deregister, and allowing the adversary
> to learn the current set of registered parties. Additionally, global
> setups allow any other setup (or functionality) to register and
> deregister with them, and they also allow other setups to learn their
> set of registered parties.[^6] These registration commands, as
> outlined in Section A.1 will be part of the code of *all* (hybrid and
> ideal) functionalities and setups considered in this work. For
> simplicity, we will not write them explicitly in the pseudo-code of
> the functionalities.
>
> Having such a flexible and dynamic registration/deregistration
> schedule, requires special care in the blockchain setting. E.g., in
> \[3\] it is observed that parties that have very recently joined the
> Bitcoin network cannot receive all guarantees of honest parties.
> Intuitively, the reason is that, due to network delays, these parties,
> called *desynchronized*, might be temporarily tricked into working on
> a fake (adversarial) chain. In this work we go one step further
> towards capturing all availability scenarios, and the corresponding
> guarantees that can be offered to parties with different availability
> patterns. We refer to Section 2.2 for more details.
>
> **The adversary.** We assume a central adversary *A* who corrupts
> miners and uses them to attack the protocol. The adversary is
> *adaptive* meaning that he can add miners to his corrupted set at any
> point in the protocol execution and can do so depending on his current
> view of it.
>
> **Assumptions on the environment/adversary as setup-functionality
> wrappers.** In order to prove statements about cryptographic
> protocols, one often makes assumptions about what the environment (or
> the adversary) can or cannot do. For example, to prove resistance
> against sleepy parties \[28\], one needs to assume that awake
> (non-sleepy) honest parties are always in the majority. Such
> assumptions can be captured by a restricted environment and/or
> adversary. However, this is against the spirit of a general
> composition theorem and technically prevents us from applying it in a
> further construction step (where for example the ledger is used as a
> hybrid). To circumvent this undesirable property, we follow the
> paradigm of \[3\] to capture such assumption by means of a
> functionality wrapper that wraps the (local setup) functionalities
> that the protocol accesses and forces the required assumptions on the
> adversary/environment. In some sense, we shift such assumption or
> restrictions from the environment into the setup resources. We refer
> to \[3\] for a more detailed discussion. Looking ahead, the wrapper
> used in our security statements is sketched in Section D (This wrapper
> will only become relevant to interpret Theorem 3 without the need of a
> restricted environment or adversary).

## 2.1 The Real World Execution

> Protocol participants are represented as parties---formally
> Interactive Turing Machine instances (ITIs)---in a multi-party
> computation. The main aspects of this computation are as follows:
>
> **Communication.** The parties interact which each other by means of a
> network of eventual delivery unicast channels \[3\]---informally,
> every party *U~p\ ~*has an open incoming-connections interface where
> he might receive messages on from arbitrary other parties. This
> captures the natural joining procedure of real-worlds blockchains
> where new parties find a point of contact and use it to communicate
> with other parties by means of a gossiping (flooding) protocol. As
> argued in \[3\] assuming the honest parties are strongly connected,
> this network can be used to build the (UC version of the) standard
> multicast network with eventual delivery assumed in \[17, 27, 22\].
> The abstraction of this network as a (local)[^7] UC functionality and
> its implementation from unicast channels was described in \[3\]. For
> completeness, we include this functionality in Section A.2.
>
> For the remainder of this work we will assume parties have access to
> such a multicast network. This network, denoted as *F*~N-MC~*^∆^* ,
> has an upper bound *∆* in the delay that the adversary can incur on
> the delivery of any message; we stress, however, that the protocol is
> oblivious of *∆* and this bound in only used in the security
> statement. Hence from the protocol's point of view the network is no
> better that an eventual delivery network (without a concrete bound).
>
> **Synchrony.** All known PoS-based blockchains, including Ouroboros
> Genesis, are (partially) synchronous, i.e., they proceed in
> synchronized rounds with either a known (or an unknown, in the case of
> partial synchrony) message delay. We model synchronous computation
> using the synchronous-UC paradigm introduced in \[21\] and adapted to
> GUC in \[3\]. Concretely, the parties are assumed access to a global
> clock setup, denoted as *G*~clock~ (see Section A.3.) Each registered
> party can signal the clock that it is done with the current round, and
> once all honest registered parties (and functionalities) have done so,
> the clock advances by one tick. In addition, every party can query the
> clock to read the (logical) time.
>
> As observed in \[3\], to obtain UC realization in such a globally
> synchronized setting, the target ideal functionality needs to keep
> track of the number of activations that an honest party gets---so that
> it can enforce in the ideal world the same pace of the clock as in the
> real world. This can be achieved by describing the protocol so that it
> has a predictable behavior when it comes to the pattern of activations
> that it needs before it sends the clock an update command. To capture
> this, \[3\] defines a function predict-time*~Π~*(*I^\~^~H~^T\ ^*) that
> predicts the time in which the clock is supposed to be according to
> the given protocol, given as input the timed honest-input sequence.
> [^8] For self-containment, we restate this property formalized in
> \[3\] in Definition 7 in Section A.3, where we also prove that
> Ouroboros Genesis indeed satisfies it.
>
> **Hash functions as global random oracles.** Ouroboros Genesis assumes
> that parties can query a hash function. As typically in cryptographic
> proofs the queries to hash function are modeled by assuming access to
> a random oracle (functionality): Upon receiving a query
> (eval*,*sid*,x*) from a registered party, if *x* has not been queried
> before, a value *y* is chosen uniformly at random from
> *{*0*,*1*}^κ\ ^*(for security parameter *κ*) and returned to the party
> (and the mapping (*x,y*) is internally stored). If *x* has been
> queried before, the corresponding *y* is returned.
>
> The random oracle is typically captured as a local UC functionality.
> As discussed in the introduction, this raises a number of issues, both
> with respect to how natural this abstraction of a hash function is,
> and with respect to the induced programmability that comes from this
> choice. Instead in this work we choose to capture it as a global
> setup, referred to as GRO and denoted as *G*~RO~ (see Section A.4 for
> a detailed description.) The fact that our security proof can be
> carried out in this model serves as an indication of the augmented
> composability that PoSs bring to the blockchain ecosystem. As
> mentioned before, Bitcoin cannot be proved secure in the GRO model.
>
> **The genesis block generation and distribution.** Agreement on the
> first, so-called *genesis* block, is a necessary condition in all
> common blockchains for the parties to achieve eventual consensus. In
> Ouroboros Genesis, this block includes the keys, signatures, and
> original stake distribution of the parties that are around at the
> beginning of the protocol. This assumption--- i.e., that the genesis
> block is properly created and distributed to the initial parties, and
> that it is properly distributed to anyone who joins even later---is
> captured in \[14\] by assuming access to a (local) functionality
> *F*~INIT~. For each stakeholder registered at the beginning of the
> protocol, *F*~INIT~ records his key in the genesis block; this block
> is distributed to anyone who requests it in any future round. To
> simplify the protocol description, we will assume throughout the paper
> that the first round---i.e., the genesis round---of the protocol
> occurs when the global time is *τ* = 0. This is wlog as the actual
> genesis-round index is written on the genesis block and we assume that
> all parties are synchronized with the global clock. For completeness
> we include a description of *F*~INIT~ in Section A.5.
>
> **Hybrids used in the security proof.** Ouroboros Genesis requires
> only access to the above functionalities and global setups, i.e.,
> *F*~N-MC~*^∆^ ,F*~INIT~*,G*~clock~*,* and *G*~RO~. However, for a
> clearer protocol description it is convenient to assume hybrid access
> to two more functionalities, one that abstracts verifiable random
> functions (VRF), denoted as *F*~VRF~, and another one that abstracts
> key-evolving signature schemes (KES), denoted as *F*~KES~. They first
> appeared in \[14\] and naturally allow for a cleaner and more modular
> protocol description and proof. For completeness we include their
> description in Section A.6 and refer to \[14\] for concrete
> realizations.

## 2.2 The Ideal World Execution

> We next turn to the functionalities available in the ideal-world.
> Recall that in this world, the parties execute the so-called dummy
> protocol. Since the clock and the random oracle are modeled as global
> setups, i.e., *G*~clock~ and *G*~RO~, they are available also in the
> ideal world. However, the big change in the ideal world, is that the
> Ouroboros Genesis protocol (and the corresponding network and
> initialization functionality) are replaced by the ideal functionality
> that abstracts the protocol's goals. We call this functionality the
> *(ideal) ledger* and formally specify it in the following.
>
> **The Ledger Functionality.** The ledger that Ouroboros Genesis
> realizes is almost identical to the abstract ledger that was proved in
> \[3\] to be implemented by (the UC adaptation of) Bitcoin. In fact,
> the abstract ledger proposed in \[3\] is parameterizable by a
> collection of four algorithms. The ledger implemented by Ouroboros
> Genesis is effectively derived by appropriately instantiating these
> algorithms. This similarity can be seen as a confirmation of the
> ledger abstraction, and as an affirmation that Ouroboros Genesis meets
> strong composable security.
>
> Given their common core, in order to describe the Ouroboros Genesis
> ledger its is helpful to start with a briefly recap of the abstract
> ledger from \[3\].
>
> The ledger from \[3\] maintains a central and unique ledger state
> denoted by state. Each registered party can request to see the state,
> but is guaranteed to receive a only a sufficiently long prefix of it;
> the size of each party's view of the state is captured by
> (monotonically) increasing pointers that define which part of the
> state each party can read; the adversary has a limited control on
> these pointers. The dynamics of this can be seen as a sliding window
> over the sequence of state blocks, with width windowSize and starting
> at the head of the state, and each party's pointer points to a
> location withing this window. (The adversary can choose the position
> of the pointers within this sliding window.) As is common in UC,
> parties advance the ledger when they are instructed to (activated with
> specific maintain-ledger input by their environment *Z*.) The ledger
> uses these queries along with the function predict-time(*·*) to ensure
> that the ideal world execution advances with the same pace (relatively
> to the clock) as the protocol does.[^9]
>
> Any party can input a transaction to the ledger (upon instructed by
> *Z*); upon reception, transactions are validated using a predicate
> Validate and, if found valid, are added to a buffer. Each new block of
> the state consists of transactions which were previously accepted to
> the buffer. (Note that transaction are treated as abstract
> objects/input-values.) To give protocols syntactic freedom of how a
> state block looks like, a vector of transactions, say *N^\~^~i\ ~*is
> mapped to the *i*th state block via function Blockify(*N^\~^~i~*).
> Validate and Blockify are two of the ledger's parametrization
> algorithms.
>
> A defining part of the behavior of the ledger is the (parameterizable)
> procedure which defines when/how to extend state. One needs to allow
> the adversary enough influence, since this is the case in the real
> protocol, but the ledger should impose certain policies/restrictions
> regarding such extensions. For example it should require a minimum
> chain growth rate, a certain chain quality, and liveness of
> transactions, which are properties studied in \[14\] for Ouroboros
> Praos. The procedure ExtendPolicy is responsible for enforcing such a
> policy. In nutshell, to enable adversarial influence, ExtendPolicy
> takes as an input a proposal from the adversary for extending the
> state, and can decide to follow this proposal if it satisfies its
> policy; if it does not, ExtendPolicy can ignore the proposal (and
> enforce a default extension). This mechanism is flexible enough to
> model different kind of scenarios; in particular, as we show in this
> work, it enables to capture the composable guarantees of
> proof-of-stake as well.
>
> Setting the ledger functionality parameters. To specify the ledger
> achieved by Ouroboros Genesis, we need to instantiate the relevant
> parameters/procedures from above. Blockify, Validate, and predict-time
> are chosen to mimic the input/output format restrictions of the
> protocol; concretely, Blockify := blockify~OG~, predict-time :=
> predict-time~OG~ (defined in Lemma 3), and
>
> Validate(BTX*,*state*,*buffer) := ValidTx~OG~(tx*,*state)*,*
>
> where blockify~OG~, predict-time~OG~, and ValidTx~OG~ are identical to
> what the real protocol uses, whose description appears in Section 3.
> As in \[3\], blockify~OG~ and ValidTx~OG~ must not disqualify each
> other[^10] (see \[3, Definition 2\]). This is easily ensured and also
> the case for Ouroboros Genesis.
>
> The procedure ExtendPolicy policy is trickier, but it again follows
> the same principles as in \[3\]. It enforces the following properties:
> First, all blocks of state are semantically valid. Furthermore, it
> ensures the following properties:

1.  The state grows at a minimal rate of blocks over a time interval.
    This is formalized by specifying a value maxTime~window~ in which at
    least windowSize blocks have to be inserted into the ledger state.

2.  A substantial fraction of blocks added to the state are declared as
    being what we call "honestly generated" and formally have to fulfill
    higher standards than other blocks.[^11] This fraction of good
    blocks is enforced by requiring a limit advBlcks~window~ of
    adversarial blocks (i.e., contributed blocks that do not need to
    employ higher standards) in each window of windowSize state blocks.

> Note that honestly generated blocks are crucial to ensure a liveness
> guarantee for transactions. The liveness guarantee captures that if a
> transaction is old enough and still valid, then it is guaranteed to be
> inserted into the state. This guarantee can be enhanced by using
> digital signatures in a modular next step, i.e., within a
> ledger-hybrid protocol. We refer to \[3\] for details. A detailed
> specification of the Ouroboros Genesis ExtendPolicy can be found in
> Section A.8.
>
> Party sets maintained by the ledger. The analysis (and ledger) of
> \[3\], and also in this work, separates the honest parties into two
> different basic categories called *synchronized* and *desynchronized*.
> A party is considered synchronized if it has been continuously
> connected to all its resources for a sufficiently long interval and
> has maintained connectivity to these resources, except maybe the GRO,
> until the current time. Formally, here, "sufficiently long" refers to
> Delay-many rounds, where Delay is a parameter of the ledger that
> depends on the network delay (we defer a formal definition of
> (de)synchronized parties to Section 4.4); as a consequence, the chains
> held by synchronized parties satisfy common prefix property as defined
> in \[17\]. Honest parties that are registered to the ledger but are
> not synchronized are called desynchronized. Because we cannot
> guarantee that these parties' view is consistent with the rest of the
> honest network, the ledger assigns them less guarantees. As soon as
> the interval of Delay rounds from registration passes (during which
> the party needs to have continuous access to the GRO and the clock),
> these parties become synchronized and obtain the best guarantees the
> ledger can assign. This party set corresponds to what we call alert
> parties in this work (and will be outlined in more detail in the next
> section). We give a detailed overview of all relevant party sets, and
> how they are reflected in the ideal-world, in the next section.

## 2.3 On Modeling Dynamic Availability

> As already discussed in the introduction, in this work we aim (and
> achieve) the highest granularity in the guarantees that honest parties
> receive, with respect to their availability status. To define the
> important classes, we first assign the following attributes to define
> an honest party's status at a given point in the execution: a party is
> considered *offline* if it is not registered with the network and
> otherwise it is considered *online*. A party is *time-aware* if it is
> registered with the clock. And finally, we say that a party is
> *operational* if it is registered with the second global setup, namely
> the random oracle (and otherwise considered as stalled). While this
> gives us a clean technical definition of being operational or stalled,
> it assigns a rather negative meaning to the term *stalled*. One could
> alternatively introduce an explicit protocol feature to allow a
> higherlevel application to choose to stall the operation for a while
> (but still being connected to the blockchain network for example); we
> plan to consider such a change in a future revision. For a concise
> overview, we refer to Figure 1. Based on the four basic attributes
> mentioned, we can define the types or categories of parties discussed
> in the introduction. The basic types, such as online/offline parties
> or operational/stalled parties, simply refer to the subset of honest
> parties possessing a certain attribute at a given point in the
> execution.
>
> We further define two more complex party types. First, we have the
> *alert* parties that can be considered the core set of honest parties
> establishing the desired properties of the blockchain and are those
> honest parties that have a synchronized state and are connected to all
> resources needed to execute the protocol.

**Fig.1. Classification of honest parties.** Based on access to
resources (random oracle *G*~RO~, clock *G*~clock~, network *F*~N-MC~)
and presence in their current non-offline status for more than Delay
rounds (synchronized or desynchronized).

  -----------------------------------------------------------------------
                       **Basic types of *honest*  
                       parties**                  
  -------------------- -------------------------- -----------------------
  **Resource**         **Resource unavailable**   **Resource available**

  random oracle        *stalled*                  *operational*
  *G*~RO~                                         

  clock *G*~clock~     *time-unaware*             *time-aware*

  network *F*~N-MC~    *offline*                  *online*

  synchronized state   *desynchronized*           *synchronized*
  -----------------------------------------------------------------------

> **Derived party types.**
>
> *alert* :*⇔ operational ∧ time-aware ∧ online ∧ synchronized active*
> :*⇔* (*operational ∧ time-aware ∧ online*) *∨ adversarial ∨
> time-unaware*

Note that while *alert* parties are honest, the set of *active* parties
also contains all adversarial parties.

> Next, in view of the security statements of later sections, we also
> define in Figure 1 the derived type of *potentially active* parties
> (or *active* for short). This class contains any (honest or corrupted)
> party that can potentially propose a block in its current status.
> Formally, it includes all honest parties with access to all resources
> (be they synchronized or not), all corrupted (i.e., adversarial)
> parties, and moreover any party that is time-unaware (independently of
> the other attributes). In the case of time-unaware parties, note that
> those parties are in particular not capable of evolving their signing
> keys reliably and hence it cannot be excluded that if they later get
> corrupted, they might retroactively perform protocol operations in a
> malicious way.
>
> The definition of a party type is extended from a single point in an
> execution to a single round in an execution, where a round, say *t*,
> consists of all system configurations where the value of the clock is
> *t*. We say a party is alert in round *t*, if it is alert at any point
> in the execution when the clock's time is *t*. We say a party is
> potentially active in round *t* if it is considered active at some
> point in the execution when the clock's time is *t*. We will recall
> the above classes and their respective role in our security arguments
> in Section 4 and Appendix E.
>
> Ideal-world correspondence. As described in the previous section, as
> in \[3\], the ledger keeps an updated track of registered parties with
> all global setups so it can know which category each party belongs in.
> As described above, the ledger can thereby distinguish between
> desynchronized parties (with reduced security guarantees), stalled
> parties (that obtain no output), alert parties (full security
> guarantees), and offline parties (which are ignored). We note in
> passing that, although not included in \[3\], an analogous level of
> granularity is an interesting extension to the Bitcoin analysis too.
> In fact, as an exercise the reader can be convinced that Bitcoin does
> also implement the ledger with respect to such a fine-grained,
> dynamic-availability model.[^12]A minor deviation: Fitting the
> functionality to the PoS setting.
> ~There\ is\ one\ minor\ point\ where~ the PoS ledger needs to deviate
> from the Bitcoin one. Concretely, in Bitcoin the contents of the
> genesis block are irrelevant (i.e., the ledger can simply have this
> block hardwired.) However, in PoS it is inherent that the initial
> stake (or tokens) is distributed in a trustworthy manner. This is
> reflected in the need for initialization, where the parties associated
> to this setup need to register in the very first round. To make sure
> that the ledger execution is indistinguishable from Ouroboros Genesis,
> we equip the ledger with an additional parameter, the initial
> stakeholders set and corresponding stake distribution *S*~initStake~
> := *{*(*U*~1~*,s*~1~)*,\...,*(*U~n~,s*~1~)*}*. If some honest
> stakeholder abstains from registering in the first round, the ledger
> stops execution. In this work, this parameter is defined to be
> identical to the stake-distribution parameter of *F*~INIT~.
>
> Given its strong similarities with the abstract ledger from \[3\], the
> complete and formal specification of the concrete ledger that
> Ouroboros Genesis realizes can be found in Section A.7.

# 3 Ouroboros Genesis as a UC-Protocol

> In this section we provide a detailed description of our protocol
> Ouroboros-Genesis as a synchronous (G)UC protocol. The protocol has a
> similar structure as Ouroboros Praos \[14\], but differs considerably
> in the novel chain selection rule, which allows parties to join at any
> point without the need of external checkpointing. As already
> discussed, the protocol only assumes access to the network
> functionalities and global setups, i.e., *F*~N-MC~*^∆^
> ,F*~INIT~*,G*~clock~*,* and *G*~RO~. However, for clarity we describe
> the protocols as having access to two additional functionalities
> *F*~VRF~ and *F*~KES~; as mentioned in the Section 2.1, these latter
> two functionalities can be implemented using the former.
>
> The section is organized as follows: First we discuss how the hybrids
> are used and provide a high level description of the protocol. Then we
> proceed to the detailed protocol specification.
>
> **Protocol overview.** The protocol Ouroboros-Genesis assumes as
> hybrids a network *F*~N-MC~*^∆^* , a verifiable random function
> *F*~VRF~, a key-evolving signature scheme *F*~KES~, a global random
> oracle *G*~RO~, and a global clock *G*~clock~.
>
> The protocol execution proceeds in disjoint, consecutive time
> intervals called *slots*. Importantly, time is divided in such a way
> that all parties know when a new slot starts---in our specification,
> every slot is one round, hence the parties can compute the current
> slot by comparing the round, i.e., clock value, recorded on the
> genesis block with the current round. Without loss of generality we
> will assume that the protocols starts when the global time is *τ* = 0;
> in this case the current slot index will always be *τ*.
>
> In each slot sl, the parties execute a so-called *staking procedure*
> to extend the blockchain. At a high level, the staking procedure
> consists of the following steps: First, the parties execute an
> implicit lottery to elect a *slot leader* from a distribution which,
> roughly, is biased by the stake distribution---the more stake a party
> has in the system, the more likely he is to be elected slot leader.
>
> In any given slot, the elected slot leaders are in charge of extending
> the blockchain. Concretely, slot leaders are allowed to propose an
> updated blockchain. To this direction, the slot leader creates and
> signs a block for the current slot. Each such block contains
> transactions that may move stake among stakeholders. The slot leader
> then broadcasts the new chain extended by its block to its peers via
> *F*~N-MC~^bc^ . We remark that as in \[14\], in order to achieve
> adaptive security the blocks are signed using a key-evolving signature
> scheme *F*~KES~ instead of a standard signature, and honest parties
> are mandated to update their private key in each slot.
>
> A chain proposed by any party might be adopted only if it satisfies
> the following two conditions: (1) it is valid according to a well
> defined validation procedure, and (2) the block corresponding to each
> slot is signed by a corresponding certified slot leader.
>
> To ensure the second property we need the implicit slot-leader lottery
> to provide its winners (slot leaders) with a certificate/proof of
> slot-leadership. For this reason, we implement the slot-leader
> election as follows: Each party *U~p\ ~*checks whether or not it is a
> slot leader, by locally evaluating a verifiable random function (VRF,
> \[15\], modeled by *F*~VRF~) using the secret key associated with its
> stake, and providing as inputs to the VRF both the slot index sl and
> the so-called epoch randomness *η* (we will discuss shortly where this
> randomness comes from). If the VRF output *y* is below a certain
> threshold *T~p~*---which depends on *U~p~*'s stake---then *U~p\ ~*is
> an eligible slot leader; furthermore, he can use the verifiability of
> the VRF to generate a proof *π* of the function's output, thereby
> certifying his own eligibility to act as a slot leader. In particular,
> in addition to transactions, each new block broadcast by a slot leader
> also contains the VRF output *y* and a proof *π* of its validity to
> certify the party's eligibility to act as a slot leader.
>
> Using the output of a VRF to identify the slot leaders as above not
> only allows for certifying the winner, but it also ensures that slot
> leaders are chosen from the appropriate distribution. In a nutshell,
> this is achieved as follows: Multiple slots are collected into
> *epochs*, each of which contains *R ∈* N slots.[^13] The idea of
> having epochs is that it allows to use stake reference points that are
> old enough to be stable---with high probability---and are therefore
> appropriate to be used in a universally verifiable proof. Concretely,
> during an epoch ep, the stake distribution S~ep~ that is used for
> deriving the threshold *T~p~*^ep^ used for the slot-leader election
> corresponds to the distribution recorded in the ledger up to the last
> block of epoch ep*−*2. Additionally, the *epoch randomness η*~ep~ for
> sampling slot leaders in epoch ep is derived as a hash of additional
> VRF-values *y~ρ\ ~*that were included (together with their respective
> VRF-proofs *π~ρ~*) into blocks from the first two thirds of epoch
> ep*−*1 for this purpose by the respective slot leaders. (To unify
> block structure, our protocol includes these values into *all* blocks,
> but this would not be necessary in practice.) The values S~ep~ and
> *η*~ep~ are updated at the beginning of each epoch.
>
> A delicate point of the above staking procedure is that there will
> inevitably be some slots with zero or several slot leaders. This means
> that the parties might receive valid chains from several certified
> slot leaders. To determine which of these chains to adopt as the new
> state of the blockchain, each party collects all valid broadcast
> chains and applies a chain selection rule maxvalid-bg. In fact, the
> power of the protocol Ouroboros-Genesis and its superiority over all
> existing PoS-based blockchains stems from this new chainselection rule
> which we discuss in detail below.
>
> We next turn to the formal specification of the protocol
> Ouroboros-Genesis. The protocol describes the code that each party
> *U~p\ ~*executes. Recall that in UC parties can be dynamically created
> by the environment; upon its creation a party is assigned a session
> ID, sid, and connects to all global setups, to the adversary, and to
> all functionalities with which it shares the same session ID sid. Then
> the party becomes idle (releases the activation) and waits for the
> environment's input or for a message by a party with which it has been
> connected. (Using a standard UC convention, we assume that newly
> created parties do not register to any functionality or setup unless
> they are explicitly instructed to, by receiving a special input from
> their environment. Thus the party generation process is decoupled from
> the protocol itself.)
>
> To make the protocol description modular, we describe different
> components as subprotocols and include in their header the parameters
> they need to be aware of. All protocols described here are
> *{G*~clock~*,G*~RO~*,F*~N-MC~*^∆^
> ,F*~INIT~*,F*~VRF~*,F*~KES~*}*-hybrid protocols, i.e., have access to
> all these functionalities (and protocol participants share the same
> session ID with all local functionalities in this set.)

## 3.1 The Formal Protocol Description

> We start with some notation. We use *x ≺ y* to indicate that the
> string *x* is a prefix of the string *y*. Consider an arbitrary
> partitioning of the time axis into subsequent, non-overlapping,
> equally long intervals called *slots*. For the purpose of this
> section, a *block* is an arbitrary piece of data that contains an
> identification of a time slot to which it belongs. A blockchain (or
> *chain*, for short) is a sequence of blocks with increasing time
> slots, starting with a special *genesis block* and with each
> subsequent block containing a hash of the previous one. A more
> concrete description of blocks and chains created by the Ouroboros
> Genesis protocol will be given in Section 3.
>
> We denote the length of a chain *C* (i.e., the number of its blocks)
> by len(*C*). For a chain *C* and an interval of slots *I* ,
> \[sl*~i~,*sl*~j~*\], we denote by *C*\[*I*\] = *C*\[sl*~i~* :
> sl*~j~*\] the sequence of blocks in *C* such that their slot numbers
> fall into the interval *I*. We replace the brackets in this notation
> with parentheses to denote intervals that do not include endpoints;
> e.g., (sl*~i~,*sl*~j~*\] = *{*sl*~i~* + 1*,\...,*sl*~j~}*. Finally, we
> denote by \#~*i*:*j\ *~(*C*) , \#*~I~* (*C*) , *\|C*\[*I*\]*\|* the
> number of blocks in *C*\[*I*\].
>
> Before giving the formal specification we introduce some necessary
> terminology and notation. Each party
>
> U stores a local blockchain *^C^*~loc~*^Up^*---*U~p~*'s local view of
> the blockchain.[^14] Such a local blockchain is a sequence of blocks
> *B~i\ ~*(*i \>* 0) where each *B ∈ C*~loc~ has the following format:
> *B* = (*h,*st*,*sl*,crt,ρ,σ*). The first block *B*~0~ is special and
> is referred to as the *genesis block* **G**. In each following block
> *B~i~,i \>* 0, *h* is a hash of the previous block, st is the encoded
> data of this block, and sl is the slot number this block belongs to.
> The value *crt* = (*U~p~,y,π*) certifies that the block was indeed
> proposed by an eligible slot leader *U~p\ ~*for slot sl by providing
> the output *y* of *U~p~*'s VRF evaluation for this slot, along with
> the corresponding VRF proof *π*.
>
> Additionally, *ρ* = (*y~ρ~,π~ρ~*) is an independent VRF output---along
> with its proof---that is also inserted into the block by *U~p\ ~*and
> is later used to derive the future epoch randomness. Finally, *σ* is
> the signature by *U~p\ ~*on the entire block (using a key-evolving
> signature scheme).
>
> If *C*~loc~ = *B*~0~*\|\|···\|\|B~\`\ ~*is a (local) chain, we define
> its associated *encoded state* st*\~* as the sequence
> st~0~*\|\|\...\|\|*st*~\`~*, where each st*~i~*---referred to as the
> *i*th *state block* of the state---is the encoded data stored
>
> *dk* in block *B~i~*. (The genesis data is defined to be st~0~ :=
> *ε*.) The *exported state* is then a specific prefix st*\~* of this
> state (we define this expression to be *ε* if *k* is larger than the
> size of the chain). The exact format of the state blocks depends on
> the actual implementation and is enforced by use of the function
> blockify~OG~. Concretely, each state block st is formed by applying
> this predicate on a vector *N* of transactions to derive an
> appropriately formatted version of the block. This parameterization
> allows flexibility in the way the exported state is formatted.
>
> To enable dynamic availability every party stores in a variable
> *t*~on~ (initially set to 1) the time/slot it was last online (and not
> stalled). It also store in a variable *t*~work~ (initially set to 0)
> the last time when the staking procedure run to completion. Every
> protocol machine also stores the current (local) state st*\~* encoded
> in the chain *C*~loc~ and the local buffer buffer (corresponding to
> the transactions seen so far on the network and not added on the
> blockchain); st*\~ ,C*~loc~ and buffer are all initially empty.
>
> For brevity, whenever in the protocol we say that a party *uses the
> clock to update, τ,ep, and sl* we mean the following step:
>
> Send (clock-read*,*sid*~C~*) to *G*~clock~; receive the current time
> *τ* and update ep := *dτ/Re* and slot index sl = *τ*,
> accordingly.[^15]
>
> **Handling interrupts in a UC protocol.** A protocol command might
> consists of a sequence of operations. In UC, certain operations, such
> as sending a message to another party, outputting a message to the
> environment, or the inability to conclude a task because a resource is
> unavailable, result into the protocol machine having to loose its
> activation. Thus, one needs a mechanism for ensuring that a party that
> looses the activation in the middle of such a multi-step command is
> able to resume and complete this command. Such a mechanism is
> implicitly described in \[21\]. This mechanism can be made explicit by
> introducing an anchor *a* that stores a pointer to the current
> operation; the protocol associates each anchor with such a multiple
> command and an input *I*, so that when such an input is received it
> directly jumps to the stored anchor, executes the next operation(s)
> and updates (increases) the anchor before releasing the activation. We
> refer to execution in such a manner as *I-interruptible*.
>
> For clarity we include an example of an interruptible execution.
> Assume that the protocol mandates that upon receiving input *I*, the
> party should run a command that consists of *m* steps Step 1, Step
> 2*,\...,* Step *m*, but some of these steps might result in the
> executing party releasing its activation. Running this command in an
> *I*-*interruptible* manner means executing the following code: Upon
> receiving input *I* if *a \< m* go to Step *a* and increase *a* =
> *a* + 1 before executing the first operation that releases the
> activation; otherwise go to Step 1 and set *a* = 2 before executing
> any operation that releases the activation.
>
> The Ouroboros Genesis protocol is described in detail in Figure 2.
> Aside of the core operation of the protocol, the description already
> includes a block of commands (in the bottom of the description) which
> specify what parties do when they receive external queries to their
> global setups, such as queries to the global random oracle. Note that
> since the ideal-world (dummy) parties would forward such queries to
> their setups, the protocol needs to do basically this, except possibly
> for some book-keeping actions in case they are not fully operational
> (such as making sure that at least the signing key evolves before
> moving to the next round).

## 3.2 Registration and Deregistration

> The first thing a party needs to do in order to have any role in the
> protocol is register with its resources.
>
> Registration (and deregistration) is dictated to the (honest) parties
> by the environment. This captures the

**Protocol**
Ouroboros-Genesis*~k~*(*U~p~,*sid;*G*~ledger~*,G*~clock~*,G*~RO~*,F*~N-MC~*^∆^*
)

> **Global Variables:**
>
> Read-only (parameters): *R*, *k*, *f*, *s*
>
> Read-write: *v~p~*^vrf^, *v~p~*^kes^, *τ*, ep, sl, *C*~loc~,
> *T~p~*^ep^, isInit, *t*~on~, *t*~work~, buffer
>
> **Registration/Deregistration *(cf. Section 3.2):***
>
> Upon receiving input (register*,R*), where *R ∈
> {G*~ledger~*,G*~clock~*,G*~RO~*}* execute protocol
>
> Registration-Genesis(*U~p~,*sid*,*Reg*,R*).
>
> Upon receiving input (de-register*,R*), where *R ∈
> {G*~ledger~*,G*~clock~*,G*~RO~*}* execute protocol
>
> Deregistration-Genesis(*U~p~,*sid*,*Reg*,R*).
>
> Upon receiving input (is-registered*,*sid) return (register*,*sid*,*1)
> if the local registry Reg indicates that this party has successfully
> completed a registration with *R* = *G*~ledger~ (and did not
> de-register since then). Otherwise, return (register*,*sid*,*0).
>
> **Interacting with the Ledger *(cf. Section 3.3):***
>
> Upon receiving a ledger-specific input *I ∈
> {*(submit*,\...*)*,*(read*,\...*)*,*(maintain-ledger*,\...*)*}* verify
> first that all resources are available. **If** not all resources are
> available, **then** ignore the input; **else** (i.e., the party is
> operational and time-aware) execute one of the following steps
> depending on the input *I*:
>
> **If** *I* = (submit*,*sid*,*tx) **then** set buffer *←*
> buffer*\|\|*tx, and send (multicast*,*sid*,*tx) to *F*~N-MC~*^∆^* .
> **If** *I* = (maintain-ledger*,*sid*,*minerID) **then** invoke
> protocol LedgerMaintenance(*C*~loc~*,U~p~,*sid*,k,s,R,f*); if
> LedgerMaintenance halts **then** halt the protocol execution (all
> future input is ignored).
>
> **If** *I* = (read*,*sid) **then** invoke protocol
> ReadState(*k,C*~loc~*,U~p~,*sid*,R,f*).
>
> **Handling external (protocol-unrelated) calls to the clock and the
> RO:**
>
> Upon receiving (clock-read*,*sid*~C~*) forward it to *G*~clock~ and
> output *G*~clock~'s response.
>
> Upon receiving (clock-update*,*sid*~C~*), record that a clock-update
> was received in the current round. If this instance is currently
> time-aware but otherwise stalled or offline, then evolve the KES
> signing key by sending (USign*,*sid*,U~p~,*0*,τ*) to *F*~KES~, where
> *τ* is the current time, and forward (clock-update*,*sid*~C~*) to
> *G*~clock~.
>
> Furthermore, consider any active interruptible execution as completed.
>
> Upon receiving (eval*,*sid*~RO~,x*) forward the query to *G*~RO~ and
> output *G*~RO~'s response.
>
> **Fig.2.** The Ouroboros Genesis Protocol
>
> fact that resource availability is not something controlled by the
> protocol itself. For example, a crash of the timing or hashing process
> of the party's computer is captured by the environment instructing the
> party to deregister from the clock or the GRO, respectively. To
> capture our high-resolution (dynamic) availability, the environment is
> allowed to register and deregister parties from any of the resources
> at will.
>
> In the following we describe the protocol that the parties execute
> upon receiving a registration/deregistration request. For clarity, we
> assume that every party keeps a local registry, denoted by Reg, that
> includes a registration-flag for each of the functionalities (local
> and global) the party is connected to; whenever the party registers or
> deregisters with some functionality/setup the corresponding flag is
> updated accordingly. The protocols for registration and deregistration
> are described in the following. Since such commands are addressed to
> setups or to the ledger, they are only effecting in the real-world
> protocol if they are addressed to one of the functionalities/setups
> that are present, i.e., to some *G ∈
> {G*~clock~*,G*~RO~*,G*~ledger~*}*. Any registration input with session
> ID different than that of those three functionalities will be ignored
> by the protocol. Without loss of generality, we do not write the
> session IDs of global setups and refer to them simply with their name.

### 3.2.1 Registration

> The registration with any of the global setups *G*~RO~ and *G*~clock~
> is straightforward. However, registering with the ledger is a little
> more complicated. Upon receiving a ledger-registration query from the
> environment, the party first checks that it is registered with the
> global functionalities *G*~RO~ and *G*~clock~. If not, then it ignores
> the input (and is still considered offline). Otherwise, it registers
> with each functionality---excluding the already registered-to global
> setup functionalities *G*~RO~ and *G*~clock~. Moreover, once a party
> registers with its network it also stores the current time in variable
> *t*~on~. (Recall that *t*~on~ stores the last time the party was
> online, i.e., connected to all its resources.)
>
> Note that the registration to and from the global functionalities has
> to stay under the control of the environment. Only once this procedure
> is completed, the party becomes operational and otherwise is
> considered de-registered and does not answer any ledger-specific
> queries (i.e., it is offline). The activation after any
> (de)registration goes back to the environment. The registration
> process is detailed in Figure 3.
>
> **Fig.3.** The registration process.

### 3.2.2 De-registration

> The deregistration process is described in Figure 4. De-registering
> from global setups is analogous to above, while for simplicity, we
> model de-registering from the "ledger" as disconnecting from the
> network and hence becoming an offline party.

## 3.3 Interacting with the Ledger

> At the core of the Ouroboros Genesis protocol is the process that
> allows parties to maintain the ledger. There are three types of
> processes that are triggered by three different commands provided that
> the party is already registered to all its local and global
> functionalities---if this in not the case, the corresponding command
> is ignored.[^16]
>
> **Fig.4.** The deregistration process.
>
> The command (submit*,*sid*,*tx) is used for sending a new transaction
> to the ledger (to be included in one of the upcoming blocks). It
> results in the party storing the submitted transaction in its local
> transaction buffer and multicasting it to the network so that other
> parties also add it to their buffers.

The command (read*,*sid) is used for the environment to ask for a read
of the current ledger state. It

> *dk* results in the party outputting a prefix st*\~* of the state
> st*\~* extracted from its most recently updated (local) blockchain. As
> we argue any such output will be a prefix of any output given by any
> other party (this will follow from the common-prefix property).
>
> The command (maintain-ledger*,*sid*,*minerID) triggers the main ledger
> update and maintenance procedure which is the most involved part. A
> party receiving this command first fetches from its network all
> information relevant for the current round, then it uses the received
> information to update its local info---i.e., asks the clock for the
> current time *τ*, updates its epoch counter ep, its slot counter sl,
> and its (local view of) stake distribution parameters, accordingly;
> and finally it invokes the staking procedure unless it has already
> done so in the current round. If this is the first time that the party
> processes a (maintain-ledger*,*sid*,*minerID) message then before
> doing anything else, the party invokes an initialization protocol to
> receive the initial information it needs to start executing the
> protocol---in particular the genesis block. Furthermore, in order
> accommodate stalled parties, if the party is registered with the
> network but not with all other setups, this stalled party remembers
> the time it was stalled and returns the activation back to the
> environment. Also, since a stalled party remembers the last time it
> was online---thereby also the time it became stalled---in variable
> *t*~on~, once such a party gets reconnected---i.e., re-registers with
> the ledger in the ideal world (resp. with the network, the VRF and the
> KES in the real world)---then upon its next activation to maintain the
> ledger, the party fetches all messages it has missed by comparing the
> current time *τ* to *t*~on~ and querying the network the corresponding
> number of times. Details of this procedure are given in Section 3.3.2.
>
> The relevant sub-processes involved in the handling of a
> maintain-ledger query are detailed in the following
>
> Sections 3.3.1 to 3.3.4. After introducing each of these basic
> ingredients, we conclude with a technical overview of the main ledger
> maintenance protocol LedgerMaintenance in Figure 12 and a detail
> specification of the protocol ReadState for answering requests to read
> the ledger's state (see Figure 13.)

### 3.3.1 Party Initialization

> A party that has been registered with all its resources and setups
> becomes operational by invoking the initialization protocol
> Initialization-Genesis upon processing its first maintain-ledger
> command (see Figure 5 for detailed description). As a first step the
> party receives its keys from *F*~VRF~ and *F*~KES~. Subsequently,
> protocol Initialization-Genesis proceeds in one of the following two
> modes depending on whether or not the current round is the genesis
> round. Concretely:
>
> In the *genesis mode,* which is only executed during the genesis round
> *τ* = 0, the party interacts with the initialization functionality
> *F*~INIT~ to claim its stake.
>
> In the non-genesis mode, i.e., when *τ \>* 1, the protocol
> Initialization-Genesis queries *F*~INIT~ to receive the genesis block
> and uses the received stake distribution to determine the initial
> threshold *T~p~*^ep^ for each stakeholder *U~p~*. Additionally, in
> order for the party to receive transactions and chains that were
> circulated over the network prior to this current round, the party
> multicasts a special message hello upon its first maintain-ledger
> activation (in addition to its normal round messages). Looking ahead,
> any *U~p\ ~*receiving this message will set a special welcome flag to
> 1 will trigger (at first chance) *U~p\ ~*to multicast his local buffer
> and chain; receiving these messages will enable the newly joining
> party to get up to speed. Recall that in order to ensure that the
> genesis round has been completed (and all initial stakeholders have
> claimed their stake) before the protocol starts advancing, the
> functionality *F*~INIT~ throws an exception (halts with an error) if
> the environment does not allow all stakeholder to claim their stake in
> the genesis round. If this occurs, the calling protocol (i.e.,
> Ouroboros Genesis) also halts (cf. Figure 2).
>
> Independent of the round, the protocol concludes with the party
> setting isInit *←* true (to make sure that it is never re-initialized)
> and *t*~on~ *← τ* to remember the last time it became online---which
> in this case is also the first one.
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image1.png){width="6.506667760279965in"
> height="5.6033333333333335in"}
>
> **Fig.5.** The initialization protocol of Ouroboros Genesis (run only
> the first time a party joins).

### 3.3.2 Fetching Information from the Network

> The first thing that an already initialized (and fully online) party
> does is to attempt to read its incoming messages. Recall that in our
> network setting, a party accesses its network interface by sending a
> fetch command to its network. A network latency of, say, *∆* rounds,
> in the delivery of any given messages is then captured by the network
> withholding this message until *∆* fetch commands are issued (cf.
> \[21\]). In order to ensure that parties which have been stalled (but
> were not taken offline) can catch up with the messages sent to them
> while they where stalled, we use the following mechanism. The party
> first gets the current time *τ* from the clock, and then sets a
> counter fetchcount to *τ − t*~on~. (Since *t*~on~ stores the last
> round that the party was online, fetchcount will be the number of
> rounds this party was stalled.) Subsequently the party issues
> fetchcount fetch-queries to its network. Recall that a party that was
> offline and becomes online is considered de-synchronized for (at
> least) as many rounds as it needs for that party to receive all the
> relevant information and for the chain-selection rule to bootstrap
> it[^17] ---by detecting a chain that is guaranteed to originate from
> an honest and synchronized party. This party does not get to
> retrospectively receive messages sent to it while it was offline,
> which is is reflected in our protocol by the fact that this party will
> execute the network-registration procedure from scratch and will
> therefore set *t*~on~ = *τ*.
>
> There are three types of messages that are exchanged through the
> network, namely: blockchains---e.g,. when a slot leader creates a new
> block; regular messages, also referred to as transactions---which are
> broadcasted to the network when received by the environment; and
> hello-messages, as described above, sent by newly joining parties. To
> simplify the exposition, in our description we make the convention
> that each of these three types of messages is multicasted by its own
> network. Concretely, we will assume a network used for disseminating
> transactions, denoted as *^F^*~N-MC~^tx^ , a network used for
> circulating hello message, denoted as *F*~N-MC~^new^ , and a network
> used for disseminating other information (in particular new
> blockchains) as *F*~N-MC~^bc^ . We stress that this distinction of
> networks is only for sake of clarity, as these three networks can be
> simulated over the original multicast network *F*~N-MC~ by appending a
> special identifier indicating the type of the exchanged message.
>
> The protocol FetchInformation performing the above operations can be
> found in Figure 6.
>
> **Fig.6.** Fetching new information circulated through the multicast
> network.

### 3.3.3 The Staking Procedure

> The next part of the ledger-maintenance protocol is the staking
> procedure which is used for the slot leader to compute and send the
> next block.
>
> Recall that a party *U~p\ ~*is an eligible slot leader for a
> particular slot sl in an epoch ep if its VRF-output (for an input
> dependent on sl) is smaller than a threshold value *T~p~*^ep^. We next
> discuss how this threshold is computed for the party's current (local)
> blockchain, where we use the following notation: *\`*~VRF~ denotes the
> VRF output length in bits. The (local) stake distribution S~ep~ at
> epoch ep corresponding to the (local) blockchain *C*~loc~ is a mapping
> from a party (identified by its public keys) to its stake and can be
> derived solely based on encoded transactions in *C*~loc~ (and the
> genesis block).[^18] The relative stake of *U~p\ ~*in the stake
> distribution S~ep~, denoted as *α~p~*^ep^ *∈* \[0*,*1\], is the
> fraction of stake that is associated with this party (more precisely,
> its public key) in S~ep~ out of all stake. The mapping *φ~f~*(*·*) is
> defined as

*φ~f~*(*α*) , 1 *−* (1 *− f*)*^α^* (1)

> and is parametrized by a quantity *f ∈* (0*,*1\] called the *active
> slots coefficient* \[14\], which is an important parameter of the
> protocol Ouroboros-Genesis (cf. Section 3.3.3).
>
> Given the above, the threshold *T~p~*^ep^ is determined as

*Tp*ep = 2*\`*VRF*φf*(*αp*ep) *.* (2)

> Note that by (2), a party with relative stake *α ∈* (0*,*1\] becomes a
> slot leader in a particular slot with probability *φ~f~*(*α*),
> independently of all other parties. We clearly have *φ~f~*(1) = *f*,
> hence *f* is the probability that a hypothetical party controlling all
> 100% of the stake would be elected leader for a particular slot.
> Furthermore, the function *φ* has an important property called
> "independent aggregation" \[14\]:

!

1 *− φ* ^X^*α~i\ ~*= ^Y^(1 *− φ*(*α~i~*)) *.* (3)

*i i*

> In particular, when leadership is determined according to *φ~f~*, the
> probability of a stakeholder becoming a slot leader in a particular
> slot is independent of whether this stakeholder acts as a single party
> in the protocol, or splits its stake among several "virtual" parties.
> Therefore, we can conclude that under arbitrary stake distribution, a
> particular slot has *some* slot leader with probability *f*, giving
> the active slots coefficient its intuitive meaning.
>
> The technical description of the staking procedure appears in Figure
> 7. It starts by two calls evaluating the VRF in two different points,
> using constants NONCE and TEST to provide domain separation, and
> receiving (*y~ρ~,π~ρ~*) and (*y,π*), respectively. The value *y* is
> used to evaluate slot leadership: if *y \< T~p~*^ep^ then the party is
> a slot leader and continues by processing its current transaction
> buffer to form a new block *B*. Aside of this application data, each
> block contains control information as described in Section 3.1. The
> information includes the proof of leadership (*y,π*), additional
> VRF-output (*y~ρ~,π~ρ~*) that influences the epoch-randomness for the
> next epoch, and the block signature *σ* produced^19^ using *F*~KES~.
> Finally, an updated blockchain *C*~loc~ containing the new block *B*
> is multicast over the network (note that in practice, the protocol
> would only diffuse the new block *B*).
>
> **Transaction Validity.** Blockchain ledgers typically put
> restrictions on transactions that can be added to a block. For
> example, Bitcoin only allows transactions that are properly signed and
> are spending an unspent coin. Although this is not directly related to
> the consistency guarantees, similarly to \[3\], our ledger also has
> such a transaction filter in place (this makes it suitable for
> applications like cryptocurrencies). This filter is implemented by
> means of a predicate ValidTx~OG~. To decide which transactions can be
> included in the state of a new block, the party checks for each
> transaction contained in its buffer whether it is valid, according to
> ValidTx~OG~, with respect to the current state of the chain. Note that
> to allow for full generality we leave ValidTx~OG~ as a protocol/ledger
> parameter (the same for both); this will allow to use the same
> protocol and ledger for different definitions of transaction validity.
>
> The transaction validity predicate ValidTx~OG~ induces a natural
> transaction validity on blockchain-states. This is captured by the
> predicate isvalidstate(st*\~* ) that decides whether a state consists
> of valid transactions according to ValidTx~OG~. The predicate simply
> checks that each transaction tx of any state-block st*~i~* included in
> the state st*\~* = st~0~*\|\|\...\|\|*st*~\`~* includes transactions
> that are valid with respect to the state
> st~0~*\|\|\...\|\|*st~*i−*1~*\|\|*st*^−^~i\ ~*^tx^, where
> st*^−^~i\ ~*^tx^ is the *i*-th state block st*~i~* with tx removed.
>
> *Remark 1 (Building a Cryptocurrency Ledger).* Consistently with the
> cryptographic literature on blockchains, we use the term *transaction*
> to refer to input values tx given to the ledger protocol (and the
> ledger functionality). It is important to recall that in order to
> achieve the standard ledger functionality of this work, where *weak*
> transaction liveness is enforced, transactions need not be signed (cf.
> \[17, 3\]). [^19]Using composition, a protection to amplify the
> liveness of transactions can be applied as a next modular step, on top
> of our ledger functionality. We note in passing that such an
> amplification has been achieved assuming a signature scheme combined
> with an explicit encoding of transactions to contain the source and
> destination addresses of the involved parties that relate to their
> public keys and/or identities; an honest protocol participant would
> consequently only sign its transactions but no others, and signature
> verification would be part of the validity check ValidTx~OG~. We refer
> to \[3\] for details on how to build a UC cryptocurrency ledger on top
> of a generic transaction ledger using the composability guarantees of
> the UC framework.

### 3.3.4 Chain Selection

> The most novel component of our protocol is the way in which a party
> decides which chain to adopt given a set of alternatives it
> (repeatedly) receives over the network. The chain selection protocol
> is invoked once a party has collected all chains he can in the current
> round---denote the set of all these chains by *N* =
> *{C*~1~*,\...,C~M~}*--- and is trying to decide whether to keep his
> current local chain *C*~loc~, or adopt one of the newly received
> chains in *N*. As we prove, the power of the new rule lies in the fact
> that it allows a desynchronized or even a newly joining party---whose
> *C*~loc~ is empty---to eventually converge to a good chain. We refer
> to this process as *bootstrapping from genesis,* and denote the new
> chain selection algorithm as maxvalid-bg.
>
> The chain selection process proceeds in three steps: First the party
> *U~p\ ~*uses the clock to make sure the time-relevant parameters,
> i.e., *τ,*ep*,* and sl, are up-to-date, and updates its local state
> accordingly (see below). Second, *U~p\ ~*filters all the received
> chains, one-by-one, to keep only the ones that satisfy a syntactic
> validity property. Informally, those are chains whose signatures are
> consistent with the genesis block, and their block-contents are
> consistent with the keys recorded in KES, the VRF, and the global
> random oracle. The filtering of any given chain *C* is done by an
> invocation of protocol IsValidChain described below. Finally, the
> party applies our new chain selection rule maxvalid-bg on the filtered
> list of chains to (possibly) update its local chain. The above three
> steps are detailed in the following.
>
> **Step 1: Updating the local state and time variables.** Every time a
> party fetches new information from the network, it needs to refresh
> its local view, and in particular to update the current epoch counter
> ep using the current clock time, as well as its view of the state
> parameters: the current epoch stake distribution S~ep~, the relative
> stake *α~p~*^ep^, and epoch randomness *η*~ep~, and the staking
> threshold *T~p~*^ep^. This is achieved by the protocols
> UpdateStakeDist (see Figure 8) and (the very simple) UpdateTime in
> Figure 9. The algorithm used to update the stake parameters, in
> particular the threshold *T~p~*^ep^ was discussed in Section 3.3.3.
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image2.png){width="6.506667760279965in"
> height="4.553333333333334in"}
>
> **Fig.7.** The Ouroboros Genesis staking procedure.
>
> **Protocol** UpdateStakeDist(*k,U~p~,R,f*)
>
> 1: Set S~ep~ to be the stakeholder distribution at the end of epoch ep
> *−* 2 in *C*~loc~ in case ep *≥* 2 (and keep the initial stake
> distribution in case ep *\<* 2).
>
> 2: Set *α~p~*^ep^ to be the relative stake of *U~p\ ~*in S~ep~ and
> *T~p~*^ep^ *←* 2^*\`*VRF^*φ~f~*(*α~p~*^ep^).
>
> 3: Set *η*~ep~ *← H*(*η*~ep*−*1~ *k*ep*kv*) where *v* is the
> concatenation of the VRF outputs *y~ρ\ ~*from all blocks in *C*~loc~
> from the first 2*R/*3 slots of epoch ep *−* 1.
>
> Output: The protocol outputs
> *τ,*ep*,*sl*,*S~ep~*,α~p~*^ep^*,T~p~*^ep^, and *η*~ep~ to its caller
> (but not to *Z*).
>
> **Fig.8.** The protocol for updating the local stake distribution
> parameters.
>
> **Step 2: Filtering out invalid chains.** The protocol IsValidChain
> which filters out invalid chains is the same as the corresponding
> protocol from \[14\]. For completeness we include it in Appendix B
> (see Figure 15).
>
> **Step 3: The new chain selection rule.** The chain selection rule
> maxvalid from \[14\] (which, to avoid confusion, we hereafter refer to
> as maxvalid-mc for "moving checkpoint", cf. Section 4) prefers longer
> chains, unless the new chain *C~i\ ~*forks more than *k* blocks
> relative to the currently held chain *C*~max~ (in which case the new
> chain would be discarded). This so-called *moving checkpointing* is
> crucial for the security proof in \[14\]; indeed, maxvalid-mc only
> guarantees satisfactory blockchain properties when coupled with a
> checkpointing functionality that provides newly joining, or
> re-joining, parties with a recent trusted chain. In particular, such
> checkpointing provides resilience against so-called "long-range
> attacks" (see \[18\] for a detailed discussion).
>
> **Fig.9.** The protocol for updating the time variables.
>
> Our new chain selection rule, formally specified as algorithm
> maxvalid-bg(*·*) (see Figure 10), surgically adapts maxvalid-mc by
> adding an additional condition (Condition B). When satisfied, the new
> condition can lead to a party adopting a new chain *C~i\ ~*even if
> this chain did fork more than *k* blocks relative to the currently
> held chain *C*~max~. Specifically, the new chain would be preferred if
> it grows more quickly in the *s* slots following the slot associated
> with the last block common to both *C~i\ ~*and *C*~max~ (here *s* is a
> parameter of the rule that we discuss in full detail in the proof).
> Roughly, this "local chain growth"---appearing just after the chains
> diverge---serves as an indication of the amount of participation in
> that interval. The intuition behind this criterion is that in a time
> interval shortly after the two chains diverge, they still agree on the
> leadership attribution for the upcoming slots, and out of the eligible
> slot leaders, the (honest) majority has been mostly working on the
> chain that ended up stabilizing.
>
> Thus the new rule substitutes a "global" longest chain rule with a
> "local" longest chain rule that prefers chains that demonstrate more
> participation after forking from the currently held chain *C*~max~. As
> proven in Section 4, this additional condition allows an honest party
> that joins the network at an arbitrary point in time to bootstrap
> based only on the genesis block (obtained from *F*~INIT~) and the
> chains it observes by listening to the network for a sufficiently long
> period of time. In prior work, a newly spawned party had to be assumed
> to be bootstrapped by obtaining an honest chain from an external, and
> fully trusted, mechanism (or, alternatively, be given a list of
> trustworthy nodes from which to request an honest chain); our solution
> does not rely on any such assumption. We refer to this
> process/assumption as *checkpointing*; provably avoiding this process
> by means of an updated chain selection rule is one of the major
> contributions of our work.
>
> The protocol executed by the parties to select a new chain, denoted as
> SelectChain, can be found in Figure 11.
>
> **Fig.11.** The protocol for parties to adopt a (new) chain.
>
> We conclude this section by referring to Figure 12 for the technical
> overview of the main ledger maintenance protocol LedgerMaintenance
> which makes use of the previously introduced sub-processes.
>
> **Protocol** LedgerMaintenance(*C*~loc~*,U~p~,*sid*,k,s,R,f*)
>
> The following steps are executed in an
> (maintain-ledger*,*sid*,*minerID)-interruptible manner:
>
> 1: **if** isInit is false **then** invoke
> Initialization-Genesis(*U~p~,*sid*,R*); if Initialization-Genesis
> halts then halt (this will abort the execution).
>
> **end if**
>
> 2: // From here the variables
> *v~p~*^vrf^*,v~p~*^kes^*,τ,*ep*,*sl*,C*~loc~*,T~p~*^ep^*,*isInit,
> *t*~on~,*t*~work~ can be used to read from as they are guaranteed to
> be initialized.
>
> 3: Invoke FetchInformation(*U~p~,*sid) to receive the newest messages
> for this round; denote the output by (*C*~1~*,\...,C~M~*),
> (tx~1~*,\...,*tx*~k~*), and record the flag welcome if not yet
> recorded for this round.
>
> 4: Set buffer *←* buffer*\|\|*(tx~1~*,\...,*tx*~k~*) and define *N ←
> {C*~1~*,\...,C~M~}* 5: Invoke UpdateTime(*U~p~*) to update *τ,*ep and
> sl.
>
> 6: Set *t*~on~ *← τ*
>
> 7: Invoke SelectChain(*U~p~,*sid*,C*~loc~*,N,k,s,R,f*) to replace
> *C*~loc~.
>
> 8: **if** *t*~work~ *\< τ* **then**

9: Invoke UpdateStakeDist(*k,U~p~,R,f*) to update
S~ep~*,α~p~*^ep^*,T~p~*^ep^, and *η*~ep~.

> 10: Call StakingProcedure(*U~p~,*sid*,k*ep*,*sl*,*buffer*,C*~loc~) //
> Eexecution stays (maintain-ledger*,*sid*,*minerID)interruptible.

11: Set *t*~work~ *← τ* // React on a joining party

> 12: If welcome = 1 in this round, then send (multicast*,*sid*,C*~loc~)
> to *F*~N-MC~^bc^ and (multicast*,*sid*,*buffer) to *F*~N-MC~^tx^ .
> Otherwise, give up activation and resume below upon next maintenance
> activation.
>
> **end if**
>
> 13: Invoke FinishRound(*U~p~*)
>
> **Fig.12.** The main ledger maintenance protocol.

### 3.3.5 Reading the State

> The last command related to the interaction with the ledger is the
> read command (read*,*sid) that is used to read the current contents of
> the state. Note that in the ideal world, the result of issuing such a
> command is for the ledger to output a (long enough prefix) of the
> current state of the ledger. Analogously, in the real world, the
> result is for the party receiving it to execute protocol ReadState
> which works as follows: the party, first, gets up to speed with time,
> and updates its local blockchain using the blockchains that have been
> sent to it,[^20] and then it computes and outputs the prefix of its
> local chain (chopping of *k* blocks.) The protocol ReadState is
> detailed in Figure 13.
>
> **Protocol** ReadState(*k,C*~loc~*,U~p~,*sid*,R,f*)
>
> 1: If isInit is false output the empty state (read*,*sid*,ε*) (to
> *Z*). Otherwise, do the following:
>
> 2: Invoke FetchInformation(*U~p~,*sid) to receive the newest messages
> for this round; denote the output by (*C*~1~*,\...,C~M~*),
> (tx~1~*,\...,*tx*~k~*), and read the flag welcome.
>
> 3: Set buffer *←* buffer*\|\|*(tx~1~*,\...,*tx*~k~*); *N ←
> {C*~1~*,\...,C~M~}*; Record if welcome = 1 (for later usage).
>
> 4: Invoke UpdateTime(*U~p~*) to update *τ,*ep and sl.
>
> 5: Set *t*~on~ *← τ*
>
> 6: Invoke Protocol SelectChain(*U~p~,*sid*,C*~loc~*,N,k,s,R,f*).
>
> 7: Extract the state st*\~* from the current local chain *C*~loc~.
>
> 8: Output (read*,*sid*,*st*\~ ^dk^*) (to *Z*). // st*\~ ^dk\ ^*denotes
> the prefix of st*\~* with the last *k* state blocks chopped off
>
> **Fig.13.** The protocol for parties to adopt a (new) chain.

# 4 Security Analysis

## 4.1 Blockchain Security Properties

> We first define the standard security properties of blockchain
> protocols: *common prefix*, *chain growth* and *chain quality*. While
> the security guarantees we prove in this paper are formulated in the
> UC setting, these standalone properties will turn out to be useful
> tools for our analysis.
>
> **Common Prefix (**CP**); with parameters** *k ∈* N**.** The chains
> *C*~1~*,C*~2~ possessed by two alert parties at the onset of the slots
> sl~1~ *≤* sl~2~ are such that *^C^*~1~*^dk^ C*~2~, where
> *^C^*~1~*^dk^* denotes the chain obtained by removing the last *k*
> blocks from *C*~1~, and denotes the prefix relation.
>
> **Chain Growth (**CG**); with parameters** *τ ∈* (0*,*1\] **and** *s
> ∈* N**.** Consider a chain *C* possessed by an alert party at the
> onset of a slot sl. Let sl~1~ and sl~2~ be two previous slots for
> which sl~1~ + *s ≤* sl~2~ *≤* sl, so sl~1~ is at least *s* slots prior
> to sl~2~. Then *\|C*\[sl~1~ : sl~2~\]*\| ≥ τ · s*. We call *τ* the
> speed coefficient.
>
> **Chain Quality (**CQ**); with parameters** *µ ∈* (0*,*1\] **and** *k
> ∈* N**.** Consider any portion of length at least *k* of the chain
> possessed by an alert party at the onset of a slot; the ratio of
> blocks originating from alert parties in this portion is at least *µ*.
> We call *µ* the chain quality coefficient.
>
> Note that previous work identified and studied a stronger version of
> chain growth (denoted below as CG2), which controls the relative
> growth of chains held by potentially distinct honest parties.
>
> **(Strong) Chain Growth (**CG2**); with parameters** *τ ∈* (0*,*1\]
> **and** *s ∈* N**.** Consider the chains *C*~1~*,C*~2~ possessed by
> two alert parties at the onset of two slots sl~1~*,*sl~2~ with sl~1~
> at least *s* slots prior to sl~2~. Then it holds that len(*C*~2~) *−*
> len(*C*~1~) *≥ τ · s*. We call *τ* the speed coefficient.
>
> We remark that the notion of chain growth CG2 follows from CP and CG
> (with some appropriate decay in parameters). However, it appears that
> CG is a preferable formulation in our setting, as it can be
> established with stronger parameters than CG2 and more naturally
> dovetails with several aspects of the security proofs. Finally, we
> will also consider a slight variant of chain quality called
> *existential chain quality*:
>
> **Existential Chain Quality (***∃*CQ**); with parameter** *s ∈* N**.**
> Consider a chain *C* possessed by an alert party at the onset of a
> slot sl. Let sl~1~ and sl~2~ be two previous slots for which sl~1~ +
> *s ≤* sl~2~ *≤* sl. Then *C*\[sl~1~ : sl~2~\] contains at least one
> alertly generated block.
>
> As a side remark, the CG (resp. CQ) property follows from *∃*CQ and an
> additional property called *honestbounded chain growth* HCG (resp.
> *honest-bounded chain quality*, HCQ). We define HCG and HCQ and
> establish these relationships in Appendix E.5.
>
> Note that typically these security properties for blockchain protocols
> are formulated so that they grant the above-described guarantees to
> all *honest* parties. However, in our more fine-grained modeling of
> parties' availability, a natural choice is to analyze these properties
> for the *alert* parties only. In particular, the properties CQ and
> *∃*CQ guarantee sufficient presence of blocks generated by alert
> parties in the chain, i.e., generated by parties that were fully
> up-to-date with the state of the protocol and capable of contributing
> to it. In the following treatment, we often talk about
> *honestly-generated blocks*, but this always refers to blocks
> generated by such alert parties. Similarly, *adversarial blocks* don't
> necessarily have to come from corrupted parties, rather from any
> parties that are not fully alert.

## 4.2 Security of Ouroboros Genesis with maxvalid-mc

> The original Ouroboros Praos protocol given in \[14\] differs from
> Ouroboros Genesis in a single point: it employs a different chain
> selection rule, which we call maxvalid-mc here and outline below. The
> difference in maxvalid-mc compared to maxvalid-bg is that if the
> considered chain *C~i\ ~*forks from the current chain *C*~loc~ more
> than *k* blocks in the past, it is immediately discarded, without
> evaluating Condition B as in maxvalid-bg. This can be seen as a
> "moving checkpoint" *k* blocks behind the current tip of the chain,
> which is what the suffix "-mc" stands for. To preserve clarity, we
> will use Ouroboros-Praos to refer to the protocol that is identical to
> the one given in Section 3 except that is uses maxvalid-mc instead of
> maxvalid-bg as its chain-selection rule.
>
> Our first goal is to establish that the useful properties of common
> prefix, chain growth, and chain quality are achieved by
> Ouroboros-Praos, when executed in a slightly restricted environment.
> Namely, we start by assuming that all parties participate in the
> protocol run from the beginning and never get deregistered from the
> network *F*~N-MC~ (i.e., honest parties are always *online*); we refer
> to this setting as the *setting with static F*~N-MC~*-registration*.
> We will drop this assumption later.
>
> The desired statement for this limited environment is given in Theorem
> 1, the rest of Section 4.2 will be dedicated to sketching its proof,
> which is fully spelled out in Appendix E. First, we need to define
> some relevant quantities.
>
> **Definition 1 (Classes of parties and their relative stake).** *Let
> P*\[*t*\] *denote the set of all parties in slot t, and let
> P~type~*\[*t*\] *for any* type *of party described in Figure 1 (e.g.
> alert, active) denote the set of all parties of the respective type in
> slot t. For a set of parties P~type~*\[*t*\]*, let
> S^−^*(*P~type~*\[*t*\]) *∈* \[0*,*1\] *(resp. S*^+^(*P~type~*\[*t*\])
> *∈* \[0*,*1\]*) denote the minimum (resp., maximum), taken over the
> views of all alert parties, of the total relative stake of all the
> parties in P~type~*\[*t*\] *in the stake distribution used for
> sampling the slot leaders in slot t.*
>
> Looking ahead, we remark that even though we give the general
> definition above, our protocol will have the property that for all
> party types and all time slots, *S^−^*(*P*~type~\[*t*\]) =
> *S*^+^(*P*~type~\[*t*\]) with overwhelming probability, as all the
> alert parties will agree on the distribution used for sampling slot
> leaders with overwhelming probability.
>
> **Definition 2 (Alert ratio, participating ratio).** *At any time slot
> t during the execution, we let:*
>
> **--** *the* alert stake ratio *be the fraction
> S^−^*(*P~alert~*\[*t*\])*/S*^+^(*P~active~*\[*t*\])*; and* **--** *the
> (potentially)* participating stake ratio *be the fraction
> S^−^*(*P~active~*\[*t*\])*.*
>
> It is instructive to see that the potentially active stake ratio
> allows to conclude the ratio of stake belonging to parties that cannot
> participate in slot *t*.
>
> Note that in the setting with static *F*~N-MC~-registration, all
> honest parties are online from the beginning, and therefore also
> synchronized. The set of active parties hence consists only of alert,
> adversarial and timeunaware parties. In the general case it also
> contains honest parties that are online but desynchronized, we will
> discuss these in detail in Section 4.4.
>
> **Theorem 1.** *Consider the execution of Ouroboros-Praos with
> adversary A and environment Z in the setting with static
> F*~N-MC~*-registration. Let f be the active-slot coefficient, let ∆ be
> the upper bound on the network delay and let Q be an upper bound on
> the total number of queries issued to G*~RO~*. Let α,β ∈* \[0*,*1\]
> *denote a lower bound on the alert ratio and participating ratio
> throughout the whole execution, respectively. Let R and L denote the
> epoch length and the total lifetime of the system (in slots). If for
> some ∈* (0*,*1) *we have*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image3.png){width="1.5766666666666667in"
height="0.17in"}*,* (4)

> *and R ≥* 144*∆/βf then Ouroboros-Praos achieves the following
> guarantees:*

-   ***Common prefix.** The probability that Ouroboros-Praos violates
    the common prefix property with parameter k is no more than*

, 19*L −* ~4~*k/*18) + ~lift~ ;

~CP~(*k*) ~4~ exp(*∆*

-   ***Chain growth.** The probability that Ouroboros-Praos violates the
    chain growth property with parameters
    s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image4.png){width="0.7833333333333333in"
    height="0.14666666666666667in"} *and τ*~CG~ = *βf/*16 *is no more
    than*

> *sL*^2^
>
> CG(*τ*~CG~*,s*) , exp *−*(*βf*)^2^*s/*256 + ~lift~ ; 2

-   ***Existential chain quality.** The probability that Ouroboros-Praos
    violates the existential chain quality property with parameter
    s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image5.png){width="0.78in"
    height="0.14666666666666667in"} *is no more than*

> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image6.png){width="2.4266666666666667in"
> height="0.18in"} ~lift~ ;

-   ***Chain quality.** The probability that Ouroboros-Praos violates
    the chain quality property with parameters
    k*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image7.png){width="0.7833333333333333in"
    height="0.14666666666666667in"} *and µ* = *βf/*16 *is no more than*

> ~CQ~(*µ,k*) , *kL*2 exp *−*(*βf*)2*k/*256 + lift ; 2
>
> *where* ~lift~ *is a shorthand for the quantity*

(*βf*)2*R* 38*R* 4*βfR*

lift , *QL · R*3 *·* exp *−* + 4 *·* exp *∆ −* 864 *.*

768

> *Proof (sketch).* The proof is inspired by the proof of property-based
> security of Ouroboros Praos given in \[14\]; however, a major
> extension of the techniques is necessary. To appreciate the need for
> this extension, let us first recall in very broad terms how the proof
> in \[14\] proceeds:

1.  First, the above security properties (or slight variations of them,
    cf. Section 4.1) are proven for a single epoch. For this, the
    dynamics of the protocol execution is abstracted into combinatorial
    objects called *forks*, while the slot leader selection (assuming
    static corruption) is captured by sampling a so-called
    *characteristic string*.

2.  A recursive rule is given that identifies whether a characteristic
    string allows for "dangerous" forks, and a probabilistic analysis
    shows that under static corruption, leader schedules corresponding
    to such characteristic strings are extremely rare.

3.  Given the rarity of such undesirable characteristic strings, the CP,
    CG, and CQ properties are established for a single epoch and a
    static-corruption adversary.

4.  The analysis is generalized to fully adaptive corruption by showing
    a static-corruption adversary that dominates any adaptive one.

5.  The analysis is extended to an arbitrary number of epochs by
    analyzing the subprotocol for generating new randomness to be used
    in the following epoch to sample the leader schedule.

> The main improvement of Theorem 1 over the analysis in \[14\] is that
> it captures stalled and time-unaware parties (and making honest
> parties stalled or time-unaware is a fully adaptive decision of the
> environment). This is done in two different ways: broadly speaking,
> while stalled parties don't pose a threat as long as the majority of
> active parties is honest, time-unaware parties are problematic (as
> they cannot evolve their keys) and have to be counted as adversarial
> until they regain their time-awareness.
>
> Unfortunately, the adaptive nature of the above environment's control
> makes it impossible to start with a static analysis of the slot-leader
> selection as done above in steps 1--3. Moreover, the argument in step
> 4 completely breaks down as the static adversary given in \[14\] no
> longer dominates any possible adaptive combination of corruption and
> stalling. Therefore, our proof needs to revisit the steps 1--4 and
> replace the analysis of a sequence of binomially distributed random
> variables (representing the characteristic string) by considering
> inter-slot dependence right from the beginning. This is done via a
> martingale framework that is an important contribution of this paper
> and might prove useful also outside of the analysis of the Ouroboros
> protocols. We give all the details of our approach in Appendix E,
> where we also describe the parts of the framework from \[14\] that are
> necessary to follow our proof. *tu*

## 4.3 Adopting the New maxvalid-bg Rule

> **Theorem 2.** *Consider the protocol Ouroboros-Genesis using
> maxvalid-bg as described in Section 3, executed in the setting with
> static F*~N-MC~*-registration, under the same assumptions as in
> Theorem 1. If the maxvalid-bg parameters, k and s, satisfy*

*k \>* 192*∆/*(*β*) *and
R/*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image8.png){width="1.7366666666666666in"
height="0.14333333333333334in"}

> *then the guarantees given in Theorem 1 for common prefix, chain
> growth, chain quality, and existential chain quality are still valid
> except for an additional error probability*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image9.png){width="4.136666666666667in"
height="0.14666666666666667in"} *.* (5)

> *Proof.* We show that when replacing maxvalid-mc with maxvalid-bg, the
> overall execution of the protocol remains the same except with
> negligible probability. To see this, consider a run of the protocol
> with maxvalid-mc, and let sl*~b~* denote the first slot when any
> honest party discards a received candidate chain *C*~cand~ (longer
> than *C*~loc~) because it forks from its *C*~loc~ by more than *k*
> blocks, as described by maxvalid-mc. Until sl*~b~*, the whole
> execution would proceed identically if parties were using maxvalid-bg
> instead, as in both cases they would always prefer the longer of the
> compared chains using Condition A.
>
> Consider now the decision that a party running maxvalid-bg would make
> regarding this chain *C*~cand~ in the slot sl*~b~*. We will argue that
> it will also favor *C*~loc~ with overwhelming probability. This will
> then imply the full statement, as the reasoning can be applied
> inductively to each of the slots where maxvalid-mc discards a longer
> chain, throughout the whole execution.
>
> Let sl*~a~* be the slot associated with the last common block of
> *C*~loc~ and *C*~cand~. Recall that by the design of the protocol
> (independently of the underlying maxvalid rule), for every slot
> sl*~i~* there is an event *E~i\ ~*such that: (i.) Pr\[*E~i~*\] = 1 *−
> f*; (ii.) the events *E*~1~*,E*~2~*,\...* are independent; (iii.) if
> *E~i\ ~*occurs, then no valid block can be created for the slot
> sl*~i~*. Therefore, using a Chernoff bound (cf. Appendix F) and a
> union bound over the running time *L* of the system, we can also
> lower-bound the number of slots between sl*~a~* and sl*~b~* as *a − b
> ≥ k/*(2*f*), except with error probability exp(ln*L − Ω*(*k*)). For
> the remainder of the proof, we will assume that the execution
> satisfies this property (that is, sl*~b~ −* sl*~a~ \> k/*(2*f*) for
> all pairs of slots bounding *k* blocks on an honestly held chain) and,
> further, that:
>
> **(**CP**)** there is no *kβ/*64-CP violation;
>
> **(***∃*CQ**)** there is no *s*-*∃*CQ violation; and **(**CG**)**
> there is no (*βf/*16*,s*)-CG violation.
>
> As indicated in the statement of the theorem, *s* is fixed to be
> *k/*(4*f*). Observe that the error probabilities associated with these
> events are then precisely those appearing in (5).
>
> By the definition of maxvalid-bg, the chain *C*~cand~ can only be
> adopted in favor of *C*~loc~ if

*C*cand\[0 : sl*a* + *s*\] *\> C*loc\[0 : sl*a* + *s*\]*.* (6)

> We will show that under the assumptions described above, this is not
> possible. For convenience, we consider two disjoint, consecutive
> subintervals of (sl*~a~,*sl*~b~*\]:

*I*growth = (sl*a,*sl*a* + *s*\] and *I*stabilize = (sl*a* + *s,*sl*a* +
2*s*\]*.* (7)

> Note that by the choice of *s*, both *I*~growth~ and *I*~stabilize~
> are indeed subintervals of (sl*~a~,*sl*~b~*\]. Moreover, since 2*s ≤
> R/*3, the chains *C*~loc~ and *C*~cand~ use the same stake
> distribution and randomness to determine slot leaders for the interval
> *I*growth *∪ I*stabilize.
>
> First, we observe that *C*~loc~ exhibits significant growth over the
> interval *I*~growth~: specifically, by the chain
>
> growth property established in Theorem 1 and the assumption *s*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image10.png){width="1.33in"
> height="0.14666666666666667in"}), we have
>
> *C*loc\[*I*growth\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image11.png){width="0.16666666666666666in"
> height="0.18in"} *sβf/*16 = *kβ/*64*.*
>
> Similarly, observe that *C*~loc~ possesses at least one
> honestly-generated block over the interval *I*~stabilize~:
> specifically, by the existential chain quality property established in
> Theorem 1 and the assumption *s* = *k/*(4*f*) *≥*
>
> 24*∆/*(*βf*), there must exists a slot sl*^∗^ ∈ I*~stabilize~ for
> which *C*~loc~\[sl*^∗^*\] was honestly generated.
>
> To complete the argument, we observe that the assertion (6) would
> yield a violation of common prefix. To argue this, we take advantage
> of the notions of characteristic strings, forks, (viable) tines and
> divergence, defined in Appendix E.1.
>
> Specifically, consider the characteristic string *W* and the fork *F
> \`~∆~ W* associated with this execution of the protocol. (The fork *F*
> reflects all valid chains adopted by honest players during the
> execution---the local chains that result from application of the
> maxvalid rule.) Let *t*~loc~ denote the tine associated with the chain
> *C*~loc~\[0 : sl*^∗^ −* 1\] and *t*~cand~ denote the tine associated
> with the chain *C*~cand~\[0 : sl*~a~* + *s*\]. The tine *t*~loc~ is
> viable, as the honest leader associated with sl*^∗^* chose *C*~loc~ to
> extend. To construct a viable tine from *t*~cand~, we extend it using
> the adversarial slots associated with the portion of *t*~loc~ in
> *I*~stabilize~. Specifically, recalling that sl*^∗^* is associated
> with the first honestly generated block of *C*~loc~ in *I*~stabilize~,
> any blocks of *C*~loc~ associated with slots in the interval
> (sl*~a~* + *s,*sl*^∗^*) are associated with adversarial slots of *W*,
> and we may use these adversarial slots to extend *t*~cand~: ^Let^
> ~b~*t*~cand~ denote the extension of the tine *t*~cand~ formed by
> adding an adversarial node for each slot in (sl*~a~* + *s,*sl*^∗^*)
> associated with a block of *t*~loc~. Note, also, that ~b~*t*~cand~ is
> viable, as length(~b~*t*~cand~) *\>* length(*t*~loc~). (Note that
> *\|C*~loc~\[0 : sl*~a~*\]*\| \< \|C*~cand~\[0 : sl*~a~*\]*\|* by
> assumption, and the tines *t*~loc~ and *t*~cand~ have the same number
> of blocks in the region (sl*~a~* +*s,*sl*^∗^*).) Thus these two tines
> form a divergence-violation (that is, a CP-violation) with parameter
> *C*~loc~\[sl*~a~* + 1*,*sl*~a~*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image12.png){width="0.4266666666666667in"
> height="0.18in"} *sβf/*16 = *kβ/*64 (by the chain growth guarantee
> above). *tu*

## 4.4 Newly Joining Parties

> In this section we prove that the guarantees on common prefix, chain
> growth and (existential) chain quality obtained for Ouroboros-Genesis
> in Section 4.3 remain valid also when new parties join the protocol
> later during its execution.
>
> To capture this, we proceed as follows. For any new party *U* that
> joins the protocol later during its execution (say at slot sl~join~),
> we consider a "virtual" party ^*U*˜^ that holds no stake, but was
> participating in the protocol since the beginning and was alert all
> the time. Moreover, we assume that starting from sl~join~, ^*U*˜^ is
> receiving the same messages (in the same slots) as *U*. Clearly, the
> run of the protocol up to sl~join~ would look the same with and
> without *U*^˜^, as *U*^˜^ would never be elected a slot leader, and
> would not affect *α* or *β*. Therefore, the execution of the protocol
> up to the point when the first party *U* tries to join is covered by
> the statements proven in Section 4.3 (even when also considering the
> participation of *U*^˜^).
>
> **Definition 3 (Adopting and discarding chains).** *We say that an
> honest party* adopts *a chain C when an execution of the procedure
> maxvalid-bg by this party returns C. An honest party* discards *a
> chain C when an execution of the procedure maxvalid-bg by this party
> takes C as one of its inputs, but does not output C.*
>
> **Definition 4 (Virtual executions and virtual parties).** *We say
> that an honest party U is* joining the protocol execution *at slot
> sl*~join~ *if sl*~join~ *is the slot in which U becomes operational,
> time-aware and online for the first time. For a party U joining the
> execution E of the protocol Ouroboros-Genesis at slot sl*~join~*,
> consider an execution E^0^ that only differs from E by one additional
> party U*^˜^ *being present from the beginning, registering* 0 *stake,
> remaining alert throughout the execution, and receiving the same
> messages as U from sl*~join~ *on. We call E^0^ (resp. U*^˜^*) the*
> virtual execution *(resp. the* virtual party*) for U.*
>
> **Definition 5 (Synchronizing chains).** *We call (a message
> containing) a chain C*~sync~ synchronizing for *U, if this is the
> first chain that its virtual party U*^˜^ *adopts after slot
> sl*~join~*.*
>
> **Definition 6 (Synchronized parties).** *A party U is called*
> synchronized *at time t (cf. Fig. 1) with respect to synchronization
> parameter t*~sync~ *≥* 0*, if either U has been online and time-aware
> since the beginning; or the last time it registered to the network
> F*~N-MC~ *was at time t*~0~ *and there is a slot t*~1~ *∈
> {t*~0~*,\...,t−t*~sync~*} such that the following conditions are
> satisfied:*

(i) *U has been online and time-aware since t*~1~*;*

(ii) *U was operational in slots t*~1~*,\...,t*~1~ + *t*~sync~ *−* 1*.*

> *Otherwise, the party is called* desynchronized*.*
>
> The above definition leaves flexibility when a party is considered
> synchronized, or more importantly, for how long after joining it is
> considered de-synchronized. Note that during the time a party is
> de-synchronized, the bad impact on the protocol run is that it could
> potentially extend chains that are purely adversarial. Thus, a lower
> value of *t*~sync~ is generally preferable to get a stronger
> statement, but could come at the cost of higher network traffic.
> Before we instantiate the parameter *t*~sync~ of Definition 6 for the
> specific case of Ouroboros Genesis, which is done in Lemma 2, we first
> need to examine the joining process in general.
>
> In the following, whenever we refer to the set of
> synchronized/desynchronized parties, we implicitly refer to a generic
> synchronization parameter *t*~sync~.
>
> The heart of our argument for newly joining parties is captured in the
> following lemma.
>
> **Lemma 1.** *In the same setting as Theorem 2 but with dynamic
> F*~N-MC~*-registrations, any newly joining party that remains
> operational, time-aware and online until it receives its synchronizing
> chain, will adopt it except with probability (5).*
>
> *Proof.* We assume that none of the bad events considered in the proof
> of Theorem 2 occurs. Let *U* be a new party joining the protocol at
> slot sl~join~. Moreover, let *U* be the first such party in this
> execution, the argument can then inductively be applied to other
> parties joining later.
>
> Consider the virtual execution *E^0\ ^*for *U*, let ^*U*˜^ be its
> corresponding virtual party, let *C*~sync~ be its synchronizing chain,
> and let sl~sync~ be the slot in which *U* and *U*^˜^ receive
> *C*~sync~. For the sake of contradiction, assume that *U* does not
> adopt *C*~sync~, and let *C*~1~ denote the chain that *U* is holding
> as its local chain *C*~loc~ when running maxvalid-bg in slot sl~sync~.
> Additionally, let sl~*j*1~ denote the slot that contains the last
> common block of *C*~1~ and *C*~sync~. Finally, let *C*~2~ denote the
> chain that *U*^˜^ is holding as its local chain *C*~loc~ when running
> maxvalid-bg in slot sl~sync~. As *C*~sync~ is the first chain *U*^˜^
> adopts after sl~join~, we know that *C*~2~ was adopted by *U*^˜^
> before sl~join~. Let sl~*j*2~ denote the slot that contains the last
> common block of *C*~2~ and *C*~sync~.
>
> We have to analyze two possible cases here, depending on which
> condition in the procedure maxvalid-bg was used by *U* to discard
> *C*~sync~.

-   *U* **discards** *C***~sync~ using Condition A.** Since Condition A
    was invoked, this means that \#~*j*1:sync~ (*C*~1~) *≤ k*, and since
    *C*~sync~ was discarded, we have *\|C*~1~*\| ≥ \|C*~sync~*\|*.

> However, since *U*^˜^ adopted *C*~sync~, we argue that *\|C*~sync~*\|
> \> \|C*~2~*\|*. This holds because *U*^˜^ always adopts a new chain
> using Condition A, which is a direct consequence of the arguments
> given in the proof of Theorem 2. Hence, we can derive *\|C*~1~*\| \>
> \|C*~2~*\|*. To obtain a contradiction with the fact that ^*U*˜^ did
> not adopt *C*~1~ to replace *C*~2~, we only need to show that when it
> received *C*~1~ it used Condition A to make its adoption decision,
> i.e., that *C*~1~ does not fork more than *k* blocks back from *C*~2~.
> This can be shown by case analysis. We need to consider two subcases:
>
> **Case** *j*~1~ *≤ j*~2~**:** This means that *C*~2~ forks from
> *C*~sync~ not earlier than *C*~1~ does and hence *C*~1~ forks from
> *C*~2~ in slot sl~*j*1~. Since we know that \#~*j*1:sync~ (*C*~1~) *≤
> k* and *\|C*~1~*\| ≥ \|C*~sync~*\| \> \|C*~2~*\|*, we can easily
> conclude \#~*j*1:sync~ (*C*~2~) *≤ k* in this case.
>
> **Case** *j*~1~ *\> j*~2~**:** Here *C*~2~ forks from *C*~sync~
> earlier than *C*~1~, and hence *C*~1~ forks from *C*~2~ in slot
> sl~*j*2~. The desired inequality \#~*j*2:sync~ (*C*~2~) *≤ k* in this
> case follows from the common prefix property.

-   *U* **discards** *C***~sync~ using Condition B.** The contradiction
    in this case is obtained by using exactly the same argument as in
    the proof of Theorem 2 to show that if *U* invokes Condition B on
    *C*~sync~, it must actually adopt it.

> Namely, observe that we have \#~*j*1:sync~ (*C*~1~) *\> k* and hence
> with overwhelming probability sync *− j*~1~ *\> k/*(2*f*). For
> intervals *I*~growth~*,I*~stabilize~ defined as in (7) for *a* :=
> *j*~1~ and *b* := sync, on *C*~sync~ we again have a guarantee of
> sufficient chain growth in *I*~growth~ and at least one honest block
> in *I*~stabilize~. Hence, by the same argument, Condition B in
> maxvalid-bg will favor *C*~sync~, otherwise a violation of common
> prefix would occur. *tu*
>
> Based on Lemma 1, what remains is to upper-bound the time interval
> that a newly joining party has to be considered desynchronized, i.e.,
> the time it takes until it obtains its synchronizing chain (which it
> will adopt). We present some alternatives beyond the default
> mechanism.
>
> **Lemma 2.** *Consider the same setting as Lemma 1 and let ∆ be the
> network delay. Consider an honest party U~p~ in slot sl, which newly
> joined the protocol execution (and hence being registered to the
> network) at some slot sl*~join~ *≤ sl. If party U~p~ is considered
> synchronized in slot sl according to Definition 6 with parameter
> t*~sync~ *≥* 2*∆, then it has also received its synchronizing chain.*

*Furthermore, if alert parties multicast their local state every
(constant) T rounds, we obtain the statement for t*~sync~ *≥ T* + *∆
even without any active request by the newly joining party.*

> *Proof.* Both cases follow from observing when the alert party *U*^˜^
> would receive a synchronizing chain in the respective case. Clearly,
> for the first (and default) case this is no more than the round-trip
> time 2*∆* after the actual new party joins the network, as any other
> alert party multicasts its local state by sl~join~ +*∆* (and in case
> of any later state update, it will multicast such a newer state by
> definition of the protocol). The second part follows similarly by
> observing that the above argument still holds, but where other alert
> parties multicast their local state by sl~join~ + *T*. *tu*
>
> Hence, a party is considered synchronized in an execution of the
> protocol Ouroboros Genesis, if it satisfies Definition 6 with respect
> to parameter *t*~sync~ = 2*∆*.
>
> *Remark 2 (Self-synchronization).* Note that the protocol
> Ouroboros-Genesis is self-synchronizing in the sense that even without
> any active request, the newly joining party will receive its
> synchronizing chain by slot sl~join~ +*t*~sync~ except with error
> probability ~CG2~(*t*~sync~) of the event that *U*^˜^ does not adopt a
> new chain during a period of *t*~sync~, which directly contradicts the
> CG2 security property for the respective parameters. A bound on
> CG2-violation (and hence also ~CG2~(*t*~sync~)) could be established
> as described in Section 4.1, however it would lead to longer
> synchronization times. We therefore do not pursue this option further,
> and instead choose to consider the default synchronization process as
> presented in Section 3.
>
> The analysis of the synchronization process that was outlined above
> applies also to resynchronization of parties that have already
> participated in the protocol, acquired some stake, and then got
> deregistered from *F*~N-MC~ and hence became offline. The only
> difference is that, since the joining party does not know which of the
> messages it receives is actually its synchronizing message containing
> *C*~sync~, it starts participating in the protocol immediately after
> rejoining. Hence, before it receives *C*~sync~ its participation is to
> some extent controlled by the adversary and hence its stake has to be
> counted towards the adversarial stake even though the party is not
> formally corrupted. This is already captured in the general form of
> Definition 2, and hence we have established the following corollary.
>
> **Corollary 1.** *Consider the protocol Ouroboros-Genesis as described
> in Section 3, executed in an environment with dynamic
> F*~N-MC~*-registrations and deregistrations. Then, under the
> assumptions of Theorem 2, the guarantees it gives for common prefix,
> chain growth, and chain quality are valid also in this general
> setting.*

## 4.5 Composable Guarantees

> In this section, we conclude the analysis by showing how the
> property-focused statement of Corollary 1 can be turned into a
> universally composable security statement. This concludes the
> UC-analysis of Ouroboros-Genesis. The statement is conditioned again
> on the honest majority assumption introduced above. As explained in
> \[3\] for fully composable statements, it is desirable not to restrict
> the environment, but rather model these restrictions as part of the
> setup. In \[3\], they put forth a general methodology to model such
> restrictions as wrapper functionalities that control the interaction
> between an adversary and the assumed setup functionality to enforce
> the restrictions. For completeness, we provide the corresponding
> wrapper in Section A.
>
> To prove composable security, the properties proven above for the
> real-world UC-execution play a crucial role in realizing the ledger
> *G*~ledger~ functionality (implementing a certain policy): first, the
> common-prefix property ensures that the ledger can maintain a unique
> ledger-state (a chain of state-blocks). Second, the chain quality
> ensures that the ledger can enforce a fraction of honestly generated
> blocks. Third, chain growth ensures that the ledger functionality can
> enforce its state to grow. The remaining arguments are given in the
> proof below. We now state the composable version of Corollary 1 (again
> for the default *t*~sync~ = 2*∆* case) as a theorem:
>
> **Theorem 3.** *Let k be the common-prefix parameter and let R be the
> epoch-length parameter (restricted as in Theorem 2), let ∆ be the
> network delay, let τ*~CG~ *and µ be the speed and chain-quality
> coefficients, respectively (both defined as in Theorem 1), and let α
> and β refer to the respective bounds on the participation ratios (as
> in Theorem 1). Let G*~ledger~ *be the ledger functionality defined in
> Section 2.2 and instantiate its parameters by*
>
> windowSize = *k* and Delay = 2*∆* windowSize

maxTime~window~ *≥* and advBlcks~window~ *≥* (1 *− µ*)windowSize*.*

> *τ*CG

*The protocol Ouroboros-Genesis (with access to its specified hybrids)
securely UC-realizes G*~ledger~ *under the assumptions required by
Theorem 1 (which are formally enforceable by a real-world wrapper
functionality W*~OG~*^PoS^*(*·*) *as given in Section D). In addition,
the corresponding simulation is perfect except with negligible
probability in the parameter k when setting R ≥ ω*(log*k*)*.*

> *Proof.* We prove the theorem by proving the security with respect to
> the EUC version of UC (which stands for externalized UC) and we treat
> the clock and the random oracle as the only two shared
> functionalities. Our proof then implies naturally standard UC security
> (where all hybrids are local, i.e., not shared) and, by the
> equivalence shown in \[9\], full GUC security. Secure realization is
> proven by providing a simulator *S*~ledg~ in the ideal world (with
> access to the ledger, global clock and random oracle) such that the
> protocol execution is indistinguishable from the ideal-world execution
> with the ledger functionality and the simulator. The simulator
> *S*~ledg~ is given in detail in Section C. The simulator basically
> runs internally an entire protocol execution and emulates this
> real-world view in a black-box way towards the real world adversary
> *A*. This simulation can be done perfectly, as nothing restricts the
> simulator in evaluating, in each round what the corresponding party
> does in the protocol upon a maintain command (including aborts of
> protocols due to key collisions in *F*~INIT~ for example). Also, the
> simulator can extract the ledger state from the emulated blockchains
> (procedure ExtendLedgerState), and the views of honest parties on this
> state (procedure AdjustView).
>
> The only events that prevent a successful simulation are therefore
> when the ledger functionality does not allow the simulator to specify
> the state and the view appropriately. Simulating a ledger state fails,
> if the simulator encounters a violation of the common prefix property
> (in this case the simulation aborts as seen in the code of *S*~ledg~
> when flag BAD-CP is triggered). Similarly, if the state grows too
> slowly, the simulator aborts (flag BAD-CG), or the state contains too
> few honestly generated blocks (flag BAD-CQ). This events, however,
> hold except with negligible probability in the parameter *k* which
> follows exactly as proven in the previous sections (under the given
> assumptions). Considering that the analysis conditions no collisions
> among random oracle outputs, the corresponding total error probability
> of Theorem 2 can be invoked here and yields an upper bound of
> exp(*−Ω*(*κ*)) + exp(ln poly(*κ*) *− Ω*(*k*)) + exp(ln poly(*κ*) *−
> Ω*(*R*)), where poly(*κ*) denotes the polynomial upper bound on the
> runtime of *Z* measured with respect to the security parameter *κ*.
> Note that in particular, the parameters *L* and *Q* of the security
> bound can simply be upper bounded by this polynomial.
>
> The remaining technical properties are straightforward to verify:
> first, pointers of alert parties are monotonically increasing, since
> the chains adopted by alert parties are monotonically increasing in
> size (recall from 6.2 that the new maxvalid-bg applied by alert
> parties essentially implements the longest-chain-rule but does not
> need checkpointing). The pointers of alert parties can also not be too
> far apart, i.e., the slackness is upper bounded by windowSize = *k*
> (meaning they fall within a window of size windowSize), as otherwise
> the common-prefix property is violated in that execution (if the
> prefix of the chain known to any honest party was further away than
> *k* blocks from the prefix of the actual longest chain, this would
> yield a fork and violate common-prefix). Second, the synchronization
> time does not take more than Delay time as given in the theorem
> statements, as this is exactly the time until the a newly joining
> party will have received a synchronizing chain and all honest
> transactions that were sent out (and still are valid) before this
> party joined the network (note that the round-trip time is just 2*∆*).
> Hence, the overall bound is exactly the time it takes to receive a
> synchronizing chain as by Lemma 2.
>
> Overall, this means that except with negligible probability, the
> simulator will not abort and does never violate the ledger's policy
> (as specified by (ExtendPolicy) or the additional restrictions on
> pointers into the unique ledger state. *tu*

# References

1.  Marcin Andrychowicz and Stefan Dziembowski. PoW-based distributed
    > cryptography with no trusted setup. In Rosario Gennaro and
    > Matthew J. B. Robshaw, editors, *CRYPTO 2015, Part II*, volume
    > 9216 of *LNCS*, pages 379--399. Springer, Heidelberg, August 2015.

2.  Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and
    > Lukasz Mazurek. Secure multiparty computations on bitcoin. In
    > *2014 IEEE Symposium on Security and Privacy*, pages 443--458.
    > IEEE Computer Society Press, May 2014.

3.  Christian Badertscher, Ueli Maurer, Daniel Tschudi, and Vassilis
    > Zikas. Bitcoin as a transaction ledger: A composable treatment. In
    > Jonathan Katz and Hovav Shacham, editors, *CRYPTO 2017, Part I*,
    > volume 10401 of *LNCS*, pages 324--356. Springer, Heidelberg,
    > August 2017.

4.  Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair
    > protocols. In Juan A. Garay and Rosario Gennaro, editors, *CRYPTO
    > 2014, Part II*, volume 8617 of *LNCS*, pages 421--439. Springer,
    > Heidelberg, August 2014.

5.  Vitalik Buterin. A next-generation smart contract and decentralized
    > application platform, 2013. [https://
    > github.com/ethereum/wiki/wiki/White-Paper.](https://github.com/ethereum/wiki/wiki/White-Paper)

6.  Vitalik Buterin and Virgil Griffith. Casper the friendly finality
    > gadget. *CoRR*, abs/1710.09437, 2017.

7.  Jan Camenisch, Robert R. Enderlein, Stephan Krenn, Ralf Ku¨sters,
    > and Daniel Rausch. Universal composition with responsive
    > environments. In Jung Hee Cheon and Tsuyoshi Takagi, editors,
    > *ASIACRYPT 2016, Part II*, volume 10032 of *LNCS*, pages 807--840.
    > Springer, Heidelberg, December 2016.

8.  Ran Canetti. Universally composable security: A new paradigm for
    > cryptographic protocols. In *42nd FOCS*, pages 136--145. IEEE
    > Computer Society Press, October 2001.

9.  Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish.
    > Universally composable security with global setup. In Salil P.
    > Vadhan, editor, *TCC 2007*, volume 4392 of *LNCS*, pages 61--85.
    > Springer, Heidelberg, February 2007.

10. Ran Canetti and Marc Fischlin. Universally composable commitments.
    > In Joe Kilian, editor, *CRYPTO 2001*, volume 2139 of *LNCS*, pages
    > 19--40. Springer, Heidelberg, August 2001.

11. Ran Canetti, Abhishek Jain, and Alessandra Scafuro. Practical UC
    > security with a global random oracle. In Gail-Joon Ahn, Moti Yung,
    > and Ninghui Li, editors, *ACM CCS 14*, pages 597--608. ACM Press,
    > November 2014.

12. Ran Canetti, Daniel Shahaf, and Margarita Vald. Universally
    > composable authentication and key-exchange with global PKI. In
    > Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang,
    > editors, *PKC 2016, Part II*, volume 9615 of *LNCS*, pages
    > 265--296. Springer, Heidelberg, March 2016.

13. Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Provably secure
    > proofs of stake. Cryptology ePrint Archive,

> Report 2016/919, 2016.
> [https://eprint.iacr.org/2016/919.](https://eprint.iacr.org/2016/919)

14. Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell.
    > Ouroboros praos: An adaptively-secure, semi-synchronous
    > proof-of-stake blockchain. In Jesper Buus Nielsen and Vincent
    > Rijmen, editors, *EUROCRYPT 2018, Part II*, volume 10821 of
    > *LNCS*, pages 66--98. Springer, Heidelberg, April / May 2018.

15. Yevgeniy Dodis and Aleksandr Yampolskiy. A verifiable random
    > function with short proofs and keys. In Serge Vaudenay, editor,
    > *PKC 2005*, volume 3386 of *LNCS*, pages 416--431. Springer,
    > Heidelberg, January 2005.

16. Marc Fischlin, Anja Lehmann, Thomas Ristenpart, Thomas Shrimpton,
    > Martijn Stam, and Stefano Tessaro. Random oracles with(out)
    > programmability. In Masayuki Abe, editor, *ASIACRYPT 2010*, volume
    > 6477 of *LNCS*, pages 303--320. Springer, Heidelberg, December
    > 2010.

17. Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin
    > backbone protocol: Analysis and applications. In Elisabeth Oswald
    > and Marc Fischlin, editors, *EUROCRYPT 2015, Part II*, volume 9057
    > of *LNCS*, pages 281-- 310. Springer, Heidelberg, April 2015.

18. Peter Gaˇzi, Aggelos Kiayias, and Alexander Russell. Stake-bleeding
    > attacks on proof-of-stake blockchains. Cryptology ePrint Archive,
    > Report 2018/248, 2018.
    > [https://eprint.iacr.org/2018/248.](https://eprint.iacr.org/2018/248)

19. Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and
    > Nickolai Zeldovich. Algorand: Scaling byzantine agreements for
    > cryptocurrencies. Cryptology ePrint Archive, Report
    > 2017/454, 2017.
    > [http://eprint.iacr.](http://eprint.iacr.org/2017/454)

> [org/2017/454.](http://eprint.iacr.org/2017/454)

20. Martin Hirt and Vassilis Zikas. Adaptively secure broadcast. In
    > Henri Gilbert, editor, *EUROCRYPT 2010*, volume 6110 of *LNCS*,
    > pages 466--485. Springer, Heidelberg, May / June 2010.

21. Jonathan Katz, Ueli Maurer, Bjo¨rn Tackmann, and Vassilis Zikas.
    > Universally composable synchronous computation. In Amit Sahai,
    > editor, *TCC 2013*, volume 7785 of *LNCS*, pages 477--498.
    > Springer, Heidelberg, March 2013.

22. Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman
    > Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain
    > protocol. In Jonathan Katz and Hovav Shacham, editors, *CRYPTO
    > 2017, Part I*, volume 10401 of *LNCS*, pages 357--388. Springer,
    > Heidelberg, August 2017.

23. Ranjit Kumaresan and Iddo Bentov. How to use bitcoin to incentivize
    > correct computations. In Gail-Joon Ahn, Moti Yung, and Ninghui Li,
    > editors, *ACM CCS 14*, pages 30--41. ACM Press, November 2014.

24. Ranjit Kumaresan and Iddo Bentov. Amortizing secure computation with
    > penalties. In Edgar R. Weippl, Stefan Katzenbeisser, Christopher
    > Kruegel, Andrew C. Myers, and Shai Halevi, editors, *ACM CCS 16*,
    > pages 418--429. ACM Press, October 2016.

25. Rajeev Motwani and Prabhakar Raghavan. *Randomized Algorithms*.
    > Cambridge University Press, New York, NY, USA, 1995.

26. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash
    > system, 2008.
    > [http://bitcoin.org/bitcoin.pdf.](http://bitcoin.org/bitcoin.pdf)

27. Rafael Pass, Lior Seeman, and abhi shelat. Analysis of the
    > blockchain protocol in asynchronous networks. In Jean-S´ebastien
    > Coron and Jesper Buus Nielsen, editors, *EUROCRYPT 2017, Part II*,
    > volume 10211 of *LNCS*, pages 643--673. Springer, Heidelberg,
    > April / May 2017.

28. Rafael Pass and Elaine Shi. The sleepy model of consensus. In
    > Tsuyoshi Takagi and Thomas Peyrin, editors, *ASIACRYPT 2017, Part
    > II*, volume 10625 of *LNCS*, pages 380--409. Springer, Heidelberg,
    > December 2017.

29. Alexander Russell, Cristopher Moore, Aggelos Kiayias, and Saad
    > Quader. Forkable strings are rare. Cryptology ePrint Archive,
    > Report 2017/241, 2017.
    > [https://eprint.iacr.org/2017/241.](https://eprint.iacr.org/2017/241)

# A The Model (Cont'd)

> This appendix includes complementary material to Section 2.

## A.1 Functionalities With Dynamic Party Sets

> All our functionalities and global setups handle a dynamic party set.
> The employed mechanism works as follows: such functionalities include
> the instructions that allow honest parties to join or leave the set
> *P* of players that the functionality interacts with, and inform the
> adversary about the current set of registered parties:[^21] Unless
> otherwise specified, the term party refers to an active protocol
> machine and, as usual in UC, includes the session information. The
> standard mechanism is as follows (and applies to all functionalities
> unless otherwise indicated by the functionality specification).

-   Upon receiving (register*,*sid) from some party *U~p\ ~*(or from *A*
    on behalf of a corrupted *U~p~*), set *P* = *P ∪ {U~p~}*. Return
    (register*,*sid*,U~p~*) to the caller.

-   Upon receiving (de-register*,*sid) from some party *U~p~ ∈ P*, the
    functionality sets *P* := *P \\ {U~p~}* and returns
    (de-register*,*sid*,U~p~*) to the caller.

-   Upon receiving (is-registered*,*sid) from some party *U~p~*, return
    (register*,*sid*,b*) to the caller, where the bit *b* is 1 if and
    only if *U~p~ ∈ P*.

-   Upon receiving (get-registered*,*sid) from *A*, the functionality
    returns (get-registered*,*sid*,P*) to *A*.

> For simplicity in the description of the functionalities, for a party
> *U~p~ ∈ P* we will use *U~p\ ~*to refer to this party's ID. In
> addition to the above registration instructions, global setups, i.e.,
> shared functionalities that are available both in the real and in the
> ideal world and allow parties connected to them to share state \[9\],
> allow also UC functionalities to register with them. We note in
> passing that although we allow no communication between
> functionalities, we will allow functionalities to communicate with
> global setups along the lines of \[12, Section 2\].
>
> Concretely, global setups include, in addition to the above party
> registration instructions, two registration/de-registration
> instructions for functionalities:

-   Upon receiving (register*,*sid*~C~*) from a functionality *F* (in
    session sid), set *F* := *F ∪ {*(*F,*sid)*}*.

-   Upon receiving (de-register*,*sid*~C~*) from a functionality *F* (in
    session sid, set *F* := *F \\ {*(*F,*sid)*}*. **--** Upon receiving
    (get-registered-f*,*sid*~C~*) from *A*, return
    (get-registered-f*,*sid*~C~,F*) to *A*.

## A.2 The Communication Network

> We specify the multicast network with bounded delay in the following.
> The network is modeled as a local functionality. However, we
> conjecture that it is straightforward to make it global since the
> simulator has to simulate all the messages on the network. Since we do
> not consider properties such as network congestion, we choose not to
> model it as a global functionality for simplicity. As it is sometimes
> useful to distinguish (the same kind of network) according to the
> values sent over the network, we use the notation
> *^F^*~N-MC~^bc*,∆\ *^and
>
> *F*~N-MC~^tx*,∆\ *^to distinguish chain and transaction multicast in
> the protocol. However, since both networks can be realized from a
> single network we often just refer to *F*~N-MC~*^∆^* for simplicity.
>
> **Functionality** *F*~N-MC~*^∆^*
>
> The functionality is parameterized with a set possible senders and
> receivers *P*. Any newly registered (resp. deregistered) party is
> added to (resp. deleted from) *P*.

-   **Honest sender multicast.** Upon receiving (multicast*,*sid*,m*)
    > from some *U~p~ ∈ P*, where *P* = *{U*~1~*,\...,U~n~}* denotes the
    > current party set, choose *n* new unique message-IDs
    > mid~1~*,\...,*mid*~n~*, initialize 2*n* new variables

> *D*mid1 := *D*mid*MAX*1 *\...* := *D*mid*n* := *D*mid*MAXn* := 1, set
> *M\~* := *M\~
> \|\|*(*m,*mid1*,D*mid1*,U*1)*\|\|\...\|\|*(*m,*mid*n,D*mid*n,Un*), and
> send
> (multicast*,*sid*,m,U~p~,*(*U*~1~*,*mid~1~)*,\...,*(*U~n~,*mid*~n~*))
> to the adversary.

-   **Adversarial sender (partial) multicast.** Upon receiving
    > (multicast*,*sid*,*(*m~i~*~1~*,U~i~*~1~)*,\...,*(*m~i\`~,U~i\`~*)
    > from the adversary with *{U~i~*~1~*,\...,U~i\`~} ⊆ P*, choose *\`*
    > new unique message-IDs mid~*i*1~*,\...,*mid*~i\`~*, initialize
    > *\`* new variables *D*mid*i*1 := *D*mid*MAXi*1 := *\...* :=
    > *D*mid*i\`* := *D*mid*MAXi\`* := 1, set

> *M^\~\ ^*:= *M^\~^
> \|\|*(*m~i~*~1~*,*mid~*i*1~*,D*~mid*i*~1*,U~i~*~1~)*\|\|\...\|\|*(*m~i\`~,*mid*~i\`~,D*~mid*i*~*\`,U~i\`~*),
> and send
> (multicast*,*sid*,*(*m~i~*~1~*,U~i~*~1~*,*mid~*i*1~)*,\...,*(*m~i\`~,U~i\`~,*mid*~i\`~*)
> to the adversary.

-   **Honest party fetching.** Upon receiving (fetch*,*sid) from *U~p~ ∈
    > P* (or from *A* on behalf of *U~p\ ~*if *U~p\ ~*is corrupted):

    1.  For all tuples (*m,*mid*,D*~mid~*,U~p~*) *∈ M^\~\ ^*, set
        *D*~mid~ := *D*~mid~ *−* 1.

    2.  Let *M^\~\ ^*~0~*^Up^* denote the subvector *M^\~\ ^*including
        all tuples of the form (*m,*mid*,D*~mid~*,U~p~*) with *D*~mid~ =
        0 (in the same order as they appear in *M^\~\ ^*). Delete all
        entries in *M^\~\ ^*~0~*^Up^* from *M^\~\ ^*, and send
        *M^\~\ ^*~0~*^Up^* to *U~p~*.

-   **Adding adversarial delays.** Upon receiving
    > (delays*,*sid*,*(*T*~mid*i*~1*,*mid~*i*1~)*,\...,*(*T*~mid*i*~*\`,*mid*~i\`~*))
    > from the adversary do the following for each pair
    > (*T*~mid*i*~*j,*mid*~ij~*):

> If *D*~mid~*^MAX^ij* + *T*~mid*i*~*j ≤ ∆* and mid is a message-ID
> registered in the current *M^\~\ ^*, set *D*~mid*i*~*j* :=
> *D*~mid*i*~*j* + *T*~mid*i*~*j* and set *D*~mid~*^MAX^ij* :=
> *D*~mid~*^MAX^ij* + *T*~mid*i*~*j*; otherwise, ignore this pair.

-   **Adversarially reordering messages.** Upon receiving
    > (swap*,*sid*,*mid*,*mid*^0^*) from the adversary, if mid and
    > mid*^0^* are message-IDs registered in the current *M^\~\ ^*, then
    > swap the triples (*m,*mid*,D*~mid~*,·*) and
    > (*m,*mid*^0^,D*~mid~*0,·*) in *M\~* . Return (swap*,*sid) to the
    > adversary.

## A.3 Modeling Synchrony

> As in \[3\], the basic functionality to capture a round-based protocol
> is the clock-functionality described below. In this functionality,
> each registered party can update the clock and once all honest parties
> have done so, the clock advances by one tick. In addition, every party
> can query the clock to read the (logical) time. A shared (global)
> clock allows each party to synchronize each session it participates
> in.
>
> An important property thereby is that for an ideal-world functionality
> to be UC implementable by a synchronous protocol, it needs to keep
> track of the number of activations that an honest party gets---such
> that the advancement of the ideal process is identical to advancement
> of the real world process. This requires that the protocol itself,
> when described as a UC interactive Turing-machine instance, has a
> predictable behavior (per session) when it comes to the pattern of
> activations that it needs before it sends the clock an update command.
> This is captured by defining a predictor
> predict-time*~Π~*(*I^\~^~H~^T\ ^*) of the time, given as input the
> timed honest-input sequence.[^22] We restate this property formalized
> in \[3\] here for completeness in Definition 7.
>
> **Definition 7.** *A G*~clock~*-hybrid protocol Π has a* predictable
> synchronization pattern *iff there exist an algorithm*
> predict-time*~Π~*(*·*) *such that for any possible execution of Π in a
> session sid (i.e., for any adversary and environment, and any choice
> of random coins) the following holds: If I^\~^~H~^T\ ^*=
> ((*x*~1~*,id*~1~*,τ*~1~)*,\...,*(*x~m~,id~m~,τ~m~*)) *is the
> corresponding timed honest-input sequence for this execution, then for
> any i ∈* \[*m −* 1\] :
>
> predict-time*~Π~*((*x*~1~*,id*~1~*,τ*~1~)*,\...,*(*x~i~,id~i~,τ~i~*))
> = *τ~i~*~+1~*,*
>
> *where τ~i~*~+1~ *refers to the clock time of this session.*
>
> Having such a predictor is beneficial in modeling synchronous
> protocols in UC, as the theorems and the proofs only depend on this
> function but not on the *exact* number of activations of a party in
> each round. For example, if an additional computation step requires
> one activation more, then the only thing that changes is the concrete
> specification of the function predict-time*~Π~* but the theorems stay
> the same.
>
> **Functionality** Functionality *G*~clock~
>
> The functionality manages the set *P* of registered identities, i.e.,
> parties *U~p\ ~*= (pid*,*sid). It also manages the set *F* of
> functionalities (together with their session identifier). Initially,
> *P* := *∅* and *F* := *∅*.
>
> For each session sid the clock maintains a variable *τ*~sid~. For each
> identity *U~p\ ~*:= (pid*,*sid) *∈ P* it manages variable *d~Up~*. For
> each pair (*F,*sid) *∈ F* it manages variable *d*~(*F,*sid)~ (all
> integer variables are initially 0).
>
> *Synchronization:*

-   Upon receiving (clock-update*,*sid*~C~*) from some party *U~p~ ∈ P*
    > set *d~Up\ ~*:= 1; execute *Round-Update* and forward
    > (clock-update*,*sid*~C~,U~p~*) to *A*.

-   Upon receiving (clock-update*,*sid*~C~*) from some functionality *F*
    > in a session sid such that (*F,*sid) *∈ F* set *d*~(*F,*sid)~ :=
    > 1, execute *Round-Update* and return (clock-update*,*sid*~C~,F*)
    > to this instance of *F*.

-   Upon receiving (clock-read*,*sid*~C~*) from any participant
    > (including the environment on behalf of a party, the adversary, or
    > any ideal---shared or local---functionality) return
    > (clock-read*,*sid*,τ*~sid~) to the requestor (where sid is the sid
    > of the calling instance).

> *Procedure Round-Update:* For each session sid do: If *d*~(*F,*sid)~
> := 1 for all *F ∈ F* and *d~Up\ ~*= 1 for all honest parties *U~p\ ~*=
> (*·,*sid) *∈ P*, then set *τ*~sid~ := *τ*~sid~ + 1 and reset
> *d*~(*F,*sid)~ := 0 and *d~Up\ ~*:= 0 for all parties *U~p\ ~*=
> (*·,*sid) *∈ P*.
>
> We next show that the protocol has a predictable synchronization
> pattern according to Definition 7.
>
> **Lemma 3.** *The protocol Ouroboros-Genesis satisfies Definition 7.*
>
> *Proof.* We will show that there is an easy and efficient algorithm
> predict-time~OG~(*·*) that, given any possible execution of the
> protocol in some session sid (for any adversary, environment, and
> choice of random coins), we have that if *I^\~^~H~^T\ ^*=
> ((*x*~1~*,id*~1~*,τ*~1~)*,\...,*(*x~m~,id~m~,τ~m~*)) is the
> corresponding timed honest-inputs sequence for this execution, then
> for any *i ∈* \[*m −* 1\] :
>
> predict-time*~Π~*((*x*~1~*,id*~1~*,τ*~1~)*,\...,*(*x~i~,id~i~,τ~i~*))
> = *τ~i~*~+1~*.*
>
> The basic mechanism to predict the clock time is an inductive process.
> The first advancement of the clock from *τ* = 0 to *τ* = 1 is after
> all parties *U~p~ ∈ S*~initStake~ have received a registration query
> from the environment and if all additionally registered, uncorrupted
> parties have sent a clock-update message to the clock. The advancement
> from *τ* to *τ* + 1 follows by observing that each honest miner that
> is registered with all global functionalities needs one activation
> query maintain-ledger followed by an clock-update request from the
> environment to send his clock-update message (other honest miners do
> not send such a request).

Once every honest party registered with the clock has sent its
clock-update message, the clock advances. *tu*

## A.4 The Global Random Oracle Setup

## A.5 The Genesis Block Distribution

> The functionality *F*~INIT~ describe below was introduces in \[14\] to
> formalize the procedure of genesis block creation and distribution.
>
> **Functionality** *F*~INIT~
>
> The functionality *F*~INIT~ is parameterized by the set
> *U*~1~*,\...,U~n\ ~*of initial stakeholders *n* and their respective
> stakes *s*~1~*,\...,s~n~*. It maintains the set of registered parties
> *P*.
>
> **--** Upon receiving any message from a party, the functionality
> first sends (clock-read*,*sid*~C~,τ*) to the clock to receive the
> current round. Subsequently:

-   ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image13.png){width="6.506667760279965in"
    height="2.6566666666666667in"}If this is the first (genesis) round
    and the message is request from some initial stakeholder *U~i\ ~*of
    the form (ver keys*,sid,U~i~,v~i~*^vrf^*,v~i~*^kes^), then *F*~INIT~
    stores the verification keys tuple (*U~i~,v~i~*^vrf^*,v~i~*^kes^)
    and acknowledges its receipt. If some of the registered public keys
    are equal, it outputs an error and halts. Otherwise, it samples

> \$ *^λ^* and stores a random value *η*~1~ *← {*0*,*1*}* and constructs
> a genesis block (S~1~*,η*~1~), where
>
> S1 = (*U*1*,v*1vrf*,v*1kes*,s*1)*,\...,*(*Un,vn*vrf*,vn*kes*,sn*).

-   If this is not the first round, then do the following

> *∗* If any of the *n* initial stakeholders has not send a request of
> the above form, i.e., a

(ver keys*,sid,U~i~,v~i~*^vrf^*,v~i~*^kes^)-message, to *F*~INIT~ in the
genesis round then *F*~INIT~ outputs an error and halts.

> *∗* Otherwise, if the currently received input is a request of the
> form (genblock req*,sid,U~i~*) from any (initial or not) stakeholder
> *U*, *F*~INIT~ sends (genblock*,sid,*(S~1~*,η*~1~)) to the requester.

## A.6 Additional Functionalities/Hybrids Used in the Security Proof

> The security of Ouroboros Praos and Genesis is proven in a hybrid
> world with access to a multicast-network with upper bound on the
> message delay (unknown to the protocol), a global random oracle, a
> functionality that idealizes verifiable random functions (VRF), a
> functionality that idealizes key-evolving signature schemes (KES), and
> a setup functionality that distributes the initial tokens for
> proof-of-stake blockchains. The network, clock, RO, and initialization
> (genesis block), are assumed resources (see Section 2). On the other
> hand the VRF and KES functionalities are only hybrids used in the
> proof and are shown to be UCrealizable in \[14\] by concrete
> constructions. Therefore, hence they are only employed for simplicity
> in the proof (the overall security once instantiated by the
> constructions follows from the UC composition theorem). For
> completeness we include their definition below.
>
> **Verifiable Random Functions.** The following functionality *F*~VRF~
> capturing a verifiable random function was introduced in \[14\].
>
> **Functionality** *F*~VRF~
>
> *F*~VRF~ interacts with its set of registered parties *P* (denoted by
> *U*~1~*,\...,U~\|P\|~*) as follows:

-   **Key Generation.** Upon receiving a message (KeyGen*,sid*) from a
    > stakeholder *U~i~*, hand (KeyGen*,sid,U~i~*) to the adversary.
    > Upon receiving (VerificationKey*,sid,U~i~,v*) from the adversary,
    > if *U~i\ ~*is honest, verify that *v* is unique, record the pair
    > (*U~i~,v*) and return (VerificationKey*,sid,v*) to *U~i~*.
    > Initialize the table *T*(*v,·*) to empty.

-   **Malicious Key Generation.** Upon receiving a message
    > (KeyGen*,sid,v*) from *S*, verify that *v* has not being recorded
    > before; in this case initialize table *T*(*v,·*) to empty and
    > record the pair (*S,v*).

-   **VRF Evaluation.** Upon receiving a message (Eval*,sid,m*) from
    > *U~i~*, verify that some pair (*U~i~,v*) is recorded. If not, then
    > ignore the request. Then, if the value *T*(*v,m*) is undefined,
    > pick a random value *y* from *{*0*,*1*}^\`^*^VRF^ and set
    > *T*(*v,m*) = (*y,∅*). Then output (Evaluated*,sid,y*) to *U~i~*,
    > where *y* is such that *T*(*v,m*) = (*y,S*) for some *S*.

-   **VRF Evaluation and Proof.** Upon receiving a message
    > (EvalProve*,sid,m*) from *U~i~*, verify that some pair (*U~i~,v*)
    > is recorded. If not, then ignore the request. Else, send
    > (EvalProve*,sid,U~i~,m*) to the adversary. Upon receiving
    > (EvalProve*,sid,m,π*) from the adversary, if value *T*(*v,m*) is
    > undefined, verify that *π* is unique, pick a random value *y* from
    > *{*0*,*1*}^\`^*^VRF^ and set *T*(*v,m*) = (*y,{π}*). Else, if
    > *T*(*v,m*) = (*y,S*), set *T*(*v,m*) = (*y,S ∪ {π}*). In any case,
    > output (Evaluated*,sid,y,π*) to *U~i~*.

-   **Malicious VRF Evaluation.** Upon receiving a message
    > (Eval*,sid,v,m,π*) from *S* for some *v*, do the following. First,
    > if (*S,v*) is recorded and *T*(*v,m*) is undefined, then choose a
    > random value *y* from *{*0*,*1*}^\`^*^VRF^ and set *T*(*v,m*) =
    > (*y,S*) and output (Evaluated*,sid,y*) to *S*. The same is
    > performed in case (*U~i~,v*) is recorded and *U~i\ ~*corrupted.
    > Else, if *T*(*v,m*) = (*y,S^0^*) for some *S^0^ 6*= *∅*, union *S*
    > to *S^0\ ^*and output (Evaluated*,sid,y*) to *S*, else ignore the
    > request.

-   **Verification.** Upon receiving a message (Verify*,sid,m,y,π,v^0^*)
    > from some party *P*, send

> (Verify*,sid,m,y,π,v^0^*) to the adversary. Upon receiving
> (Verified*,sid,m,y,π,v^0^*) from the adversary do:

1.  If *v^0\ ^*= *v* for some (*·,v*) and the entry *T*(*v,m*) equals
    (*y,S*) with *π ∈ S*, then set *f* = 1.

2.  Else, if *v^0\ ^*= *v* for some recorded pair of the form (*·,v*),
    but no entry *T*(*v,m*) of the form (*y,{\...,π,\...}*) is recorded,
    then set *f* = 0.

3.  Else, initialize the table *T*(*v^0^,·*) to empty, and set *f* = 0.
    Output (Verified*,sid,m,y,π,f*) to *P*.

> **Key-Evolving Signatures.** Ouroboros Praos and Genesis also make use
> of a key-evolving signature scheme for signing blocks. In our
> treatment, we reflect the fact that signing a message is a local
> operation performed by a slot-leader and invoke the proposed formalism
> of Camenisch et al. \[7\] and declare signing request as
> *restricting*. This means that although activated to provide a
> signature, the adversary has to provide the answer, i.e. the signature
> string, to this request immediately (no other output to another
> protocol machine is allowed) and return the activation token back to
> the functionality *F*~KES~. In this sense, the adversary and the
> environment are called *responsive* on signing queries.
>
> The following formalization of key-evolving signatures was given in
> \[14\] and we adopt it slightly using the notation from \[7, Section
> 6\] to indicate that signing request have to be answered immediately:
> we indicate the request by prefixing the query with the keyword
> Respond (and hence this query is considered to be restricting).
>
> **Functionality** *F*~KES~
>
> *F*~KES~ is parameterized by the total number of signature updates
> *T*, interacting with a signer *U~S\ ~*and registered parties in *P*
> (denoted by *U*~1~*,\...,U~\|P\|~*) as follows:

-   **Key Generation.** Upon receiving a message (KeyGen*,sid,U~S~*)
    > from a stakeholder *U~S\ ~*, send (KeyGen*,sid,U~S~*) to the
    > adversary. Upon receiving (VerificationKey*,sid,U~S~,v*) from the
    > adversary, send (VerificationKey*,sid,v*) to *U~S~*, record the
    > triple (*sid,U~S~,v*) and set counter k~ctr~ = 1.

-   **Sign and Update.** Upon receiving a message (USign*,sid,U~S~,m,j*)
    > from *U~S~*, verify that (*sid,U~S~,v*) is recorded for some *sid*
    > and that k~ctr~ *≤ j ≤ T*. If not, then ignore the request. Else,
    > set k~ctr~ = *j* + 1 and send (Respond*,*(Sign*,sid,U~S~,m,j*)) to
    > the adversary. Upon receiving (Signature*,sid,U~S~,m,j,σ*) from
    > the adversary, verify that no entry (*m,j,σ,v,*0) is recorded. If
    > it is, then output an error message to *U~S\ ~*and halt.

> Else, send (Signature*,sid,m,j,σ*) to *U~S~*, and record the entry
> (*m,j,σ,v,*1).

-   **Signature Verification.** Upon receiving a message
    > (Verify*,sid,m,j,σ,v^0^*) from some stakeholder *U~i\ ~*do:

    1.  If *v^0\ ^*= *v* and the entry (*m,j,σ,v,*1) is recorded, then
        set *f* = 1. (This condition guarantees completeness: If the
        verification key *v^0\ ^*is the registered one and *σ* is a
        legitimately generated signature for *m*, then the verification
        succeeds.)

    2.  Else, if *v^0\ ^*= *v*, the signer is not corrupted, and no
        entry (*m,j,σ^0^,v,*1) for any *σ^0\ ^*is recorded, then set *f*
        = 0 and record the entry (*m,j,σ,v,*0). (This condition
        guarantees unforgeability: If *v^0\ ^*is the registered one, the
        signer is not corrupted, and never signed *m*, then the
        verification fails.)

    3.  Else, if there is an entry (*m,j,σ,v^0^,f^0^*) recorded, then
        let *f* = *f^0^*. (This condition guarantees consistency: All
        verification requests with identical parameters will result in
        the same answer.)

    4.  Else, if *j \<* k~ctr~, let *f* = 0 and record the entry
        (*m,j,σ,v,*0). Otherwise, if *j* = k~ctr~, hand

> (Verify*,sid,m,j,σ,v^0^*) to the adversary. Upon receiving
> (Verified*,sid,m,j,φ*) from the adversary let *f* = *φ* and record the
> entry (*m,j,σ,v^0^,φ*). (This condition guarantees that the adversary
> is only able to forge signatures under keys belonging to corrupted
> parties for time periods corresponding to the current or future
> slots.)
>
> Output (Verified*,sid,m,j,f*) to *U~i~*.
>
> Following the treatment of \[7\], the above functionality is realized
> by the same construction as in \[14\] because the simulator in that
> proof is responsive upon signing requests. We refer to \[7\] for more
> details.

## A.7 The Ouroboros Genesis Ledger

> We next provide the complete description of the ledger functionality
> that, as we prove, is implemented by Ouroboros Genesis.
>
> **Functionality** *G*~ledger~
>
> **General:** The functionality is parameterized by four algorithms,
> Validate, ExtendPolicy, Blockify, and predict-time, along with three
> parameters: windowSize*,*Delay *∈* N, and *S*~initStake~ :=
> *{*(*U*~1~*,s*~1~)*,\...,*(*U~n~,s~n~*)*}*. The functionality manages
> variables state, NxtBC, buffer, *τ~L~*, and *\~τ*~state~, as described
> above. The variables are initialized as follows: state := *\~τ*~state~
> := NxtBC := *ε*, buffer := *∅*, *τ~L\ ~*= 0. For each party *U~p~ ∈ P*
> the functionality maintains a pointer pt*~i~* (initially set to 1) and
> a current-state view state*~p~* := *ε* (initially set to empty). The
> functionality also keeps track of the timed honest-input sequence in a
> vector *I^\~^~H~^T\ ^*(initially *I^\~^~H~^T\ ^*:= *ε*).
>
> **Party Management:** The functionality maintains the set of
> registered parties *P*, the (sub-)set of honest parties *H ⊆ P*, and
> the (sub-set) of de-synchronized honest parties *P~DS~ ⊂ H* (as
> discussed below). The sets *P,H,P~DS\ ~*are all initially set to *∅*.
> When a (currently unregistered) honest party is registered at the
> ledger, *if it is registered with the clock and the global RO
> already,* then it is added to the party sets *H* and *P* and the
> current time of registration is also recorded; if the current time is
> *τ~L~ \>* 0, it is also added to *P~DS~*. Similarly, when a party is
> deregistered, it is removed from both *P* (and therefore also from
> *P~DS\ ~*or *H*). The ledger maintains the invariant that it is
> registered (as a functionality) to the clock whenever *H 6*= *∅*.
>
> **Handling initial stakeholders:** If during round *τ* = 0, the ledger
> did not received a registration from each initial stakeholder, i.e.,
> *U~p~ ∈ S*~initStake~, the functionality halts.
>
> **Upon receiving any input** *I* from any party or from the adversary,
> send (clock-read*,*sid*~C~*) to *G*~clock~ and upon receiving response
> (clock-read*,*sid*~C~,τ*) set *τ~L\ ~*:= *τ* and do the following if
> *τ \>* 0 (otherwise, ignore input):
>
> 1\. Updating synchronized/desynchronized party set:

(a) Let *P ⊆ P*~b~ *DS* denote the set of desynchronized honest parties
    that have been registered (continuously) to the ledger, the clock,
    and the GRO since time *τ^0^ \< τ~L~ −* Delay. Set *P~DS\ ~*:=
    *P~DS~ \\ ^P^*~b~.

(b) For any synchronized party *U~p~ ∈ H \\ P~DS~*, if *U~p\ ~*is not
    registered to the clock, then consider it desynchronized, i.e., set
    *P~DS~ ∪ {U~p~}*.

> 2\. If *I* was received from an honest party *U~p~ ∈ P*:

(a) Set *I^\~^~H~^T\ ^*:= *I^\~^~H~^T^ \|\|*(*I,U~p~,τ~L~*);

(b) Compute *N^\~\ ^*= (*N^\~^*~1~*,\...,N^\~^~\`~*) :=
    ExtendPolicy(*I^\~^~H~^T^ ,*state*,*NxtBC*,*buffer*,\~τ*~state~) and
    if *N^\~^ 6*= *ε* set state :=
    state*\|\|*Blockify(*N^\~^*~1~)*\|\|\...\|\|*Blockify(*N^\~^~\`~*)
    and *\~τ*~state~ := *\~τ*~state~*\|\|τ~L~^\`^*, where *τ~L~^\`\ ^*=
    *τ~L~\|\|\...,\|\|τ~L~*.

(c) For each BTX *∈* buffer: if Validate(BTX*,*state*,*buffer) = 0 then
    delete BTX from buffer. Also, reset NxtBC := *ε*.

(d) If there exists *U~j~ ∈ H \\ P~DS\ ~*such that *\|*state*\| −*
    pt*~j~ \>* windowSize or pt*~j~ \< \|*state*~j~\|*, then set pt*~k~*
    := *\|*state*\|* for all *U~k~ ∈ H \\ P~DS~*.

> 3\. If the calling party *U~p\ ~*is *stalled or time-unaware*
> (according to the defined party classification), then no further
> actions are taken. Otherwise, depending on the above input *I* and its
> sender's ID, *G*~ledger~ executes the corresponding code from the
> following list:

-   *Submitting a transaction:*

> If *I* = (submit*,*sid*,*tx) and is received from a party *U~p~ ∈ P*
> or from *A* (on behalf of a corrupted party *U~p~*) do the following

(a) Choose a unique transaction ID txid and set BTX :=
    (tx*,*txid*,τ~L~,U~p~*)

(b) If Validate(BTX*,*state*,*buffer) = 1, then buffer := buffer *∪
    {*BTX*}*.

(c) Send (submit*,*BTX) to *A*.

-   *Reading the state:*

> If *I* = (read*,*sid) is received from a party *U~p~ ∈ P* then set
> state*~p~* := state*\|*~min*{*pt*p*~*,~\|~*~state*\|}\ *~and return
> (read*,*sid*,*state*~p~*) to the requester. If the requester is *A*
> then send (state*,*buffer*,I\~~H~^T\ ^*) to *A*.

-   *Maintaining the ledger state:*

> If *I* = (maintain-ledger*,*sid*,*minerID) is received by an honest
> party *U~p~ ∈ P* and (after updating *I\~~H~^T\ ^*as above)
> predict-time(*I\~~H~^T\ ^*) = *τ \> τ*~b~ *L* then send
> (clock-update*,*sid*~C~*) to *G*~clock~. Else send *I* to *A*.

-   *The adversary proposing the next block:*

> If *I* = (next-block*,*hFlag*,*(txid~1~*,\...,*txid*~\`~*)) is sent
> from the adversary, update NxtBC as follows: (a) Set listOfTxid *←*

(b) For *i* = 1*,\...,\`* do: if there exists BTX :=
    (*x,*txid*,*minerID*,τ~L~,U~j~*) *∈* buffer with ID txid = txid*~i~*
    then set listOfTxid := listOfTxid*\|\|*txid*~i~*.

(c) Finally, set NxtBC := NxtBC*\|\|*(hFlag*,*listOfTxid) and output
    (next-block*,ok*) to *A*.

-   *The adversary setting state-slackness:*

> If *I* = (set-slack*,*(*U~i~*~1~*,*pt~b~ *i*1)*,\...,*(*U~i\`~,*pt~b~
> *i\`*))*,* with *{U~pi~*1*,\...,U~pi~\`} ⊆ H \\ P~DS\ ~*is received
> from the adversary *A* do the following:

(a) If for all *j ∈* \[*\`*\] : *\|*state*\| −* ptb *~i~j ≤* windowSize
    and pt~b~ *ij ≥ \|*state*~ij~\|*, set pt*~i~*1 := pt~b~ *i*1 for
    every *j ∈* \[*\`*\] and return (set-slack*,ok*) to *A*.

(b) Otherwise set pt*~i~j* := *\|*state*\|* for all *j ∈* \[*\`*\].

-   *The adversary setting the state for desychronized parties:*

> If *I* =
> (desync-state*,*(*U~i~*~1~*,*state*^0^~i~*~1~)*,\...,*(*U~i\`~,*state
> *~\`~ ,* with *{U~i~*~1~*,\...,U~i\`~} ⊆ P~DS\ ~*is received from the
> adversary *A*, set state*~ij~* := state*^0^~ij\ ~*for each *j ∈*
> \[*\`*\] and return (desync-state*,ok*) to *A*.

## A.8 Formal Specification of ExtendPolicy for the PoS Ledger

> The detailed ExtendPolicy for Ouroboros is given below.
>
> // The function must not have side-effects: Only modify copies of
> relevant values.
>
> Create local copies of the values buffer, state, and *\~τ*~state~.
>
> // Now, parse the proposed block by the adversary
>
> Parse NxtBC as a vector ((hFlag~1~*,*NxtBC~1~)*,···
> ,*(hFlag*~n~,*NxtBC*~n~*))

*N\~ ← ε* // Initialize Result

> // Determine the time of the state block which is windowSize blocks
> behind the head of the state **if** *\|*state*\| ≥* windowSize
> **then**
>
> Set *τ*~low~ *← \~τ*~state~\[*\|*state*\| −* windowSize + 1\] **else**
>
> Set *τ*~low~ *←* 1 **end if** oldValidTxMissing *←* false // Flag to
> keep track whether old enough, valid transactions are inserted.
>
> **for** each list NxtBC*~i~* of transaction IDs **do**
>
> // Compute the next state block
>
> // Verify validity of NxtBC*~i~* and compute content
>
> Use the txid contained in NxtBC*~i~* to determine the list of
> transactions
>
> Let tx*\~* = (tx~1~*,\...,*tx~*\|*NxtBC*i*~*\|*) denote the
> transactions of NxtBC*~i~* **if** tx~1~ is not a coin-base transaction
> **then return** *N^\~^*~df~
>
> **else**
>
> *N\~i ←* tx1 **for** *j* = 2 to *\|*NxtBC*~i~\|* **do** Set st*~i~ ←*
> blockify~[B]{.underline}~ (*N^\~^~i~*) **if** ValidTx~[B]{.underline}~
> (tx*~j~,*state*\|\|*st*~i~*) = 0 **then return** *N^\~^*~df~
>
> **end if**
>
> *N\~i ← N\~i\|\|*tx*j* **end for**
>
> Set st*~i~ ←* blockify~[B]{.underline}~ (*N^\~^~i~*) **end if**
>
> // Test that all old valid transaction are included
>
> **if** the proposal is declared to be an honest block, i.e.,
> hFlag*~i~* = 1 **then for** each BTX = (tx*,*txid*,τ^0^,U~p~*) *∈*
> buffer of an honest party *U~p\ ~*with time *τ^0^ \< τ*~low~ *−*
> ^Delay^~2~ **do if** ValidTx~[B]{.underline}~
> (tx*,*state*\|\|*st*~i~*) = 1 but tx *6∈ N^\~^~i\ ~***then**
> oldValidTxMissing *←* true
>
> **end if**
>
> **end for**
>
> **end if** *N\~ ← N\~\|\|N\~~i\ ~*state *←* state*\|\|*st*~i~*
>
> *\~τ*state *← \~τ*state*\|\|τL*
>
> // Must not proceed with too many adversarial blocks *i ←*
> max*{{*windowSize*} ∪ {k \|* st*~k~ ∈* state *∧* proposal of st*~k~*
> had hFlag = 1*}}* // Determine most // recent honestly-generated block
> in the interval behind the head.
>
> **if** *\|*state*\| − i ≥* advBlcks~window~ **then return**
> *N^\~^*~df~
>
> **end if**
>
> // Update *τ*~low~: the time of the state block which is windowSize
> blocks behind the head of the
>
> // current, potentially already extended state **if** *\|*state*\| ≥*
> windowSize **then**
>
> Set *τ*~low~ *← \~τ*~state~\[*\|*state*\| −* windowSize + 1\] **else**
>
> Set *τ*~low~ *←* 1 **end if**

+-----------------------------------------------------------------------+
| > **end for**                                                         |
| >                                                                     |
| > // Final checks (if policy is violated, it is enforced by the       |
| > ledger):                                                            |
| >                                                                     |
| > // Must not proceed too slow or with missing transaction.           |
| >                                                                     |
| > **if** *τ*~low~ *\>* 0 **and** *τ~L~ − τ*~low~ *\>* maxTime~window~ |
| > **then** // A sequence of blocks cannot take too much time.         |
| >                                                                     |
| > **return** *N^\~^*~df~                                              |
| >                                                                     |
| > **else if** *τ*~low~ = 0 **and** *τ~L~ − τ*~low~ *\>* 2 *·*         |
| > maxTime~window~ **then** // Bootstrapping cannot take too much      |
| > time.                                                               |
| >                                                                     |
| > **return** *N^\~^*~df~                                              |
| >                                                                     |
| > **else if** oldValidTxMissing **then** // If not all old enough,    |
| > valid transactions have been included.                              |
| >                                                                     |
| > **return** *N^\~^*~df~                                              |
|                                                                       |
| **end if return** *N^\~\ ^***end function**                           |
+=======================================================================+
+-----------------------------------------------------------------------+

> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image14.png){width="6.506667760279965in"
> height="6.186667760279965in"}
>
> **Fig.14.** Function to compute a policiy-compliant default
> ledger-state extension.

# B Ouroboros Genesis as a UC-Protocol (Cont'd)

> This appendix includes protocols that have been excluded from the
> body.
>
> **Chain validation.** The chain validation procedure is given in
> Figure 15.
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image15.png){width="6.506667760279965in"
> height="5.34in"}
>
> **Fig.15.** The chain validation (filtering) protocol.
>
> **The round finish procedure.** Once a party is done its actions in a
> round it has to advance the synchronous computation by sending the
> indication to *G*~clock~. Since the functionality is shared and and an
> update-request by the environment might not be well aligned with the
> round actions, the protocol simply remembers that such an update has
> been received. The procedure FinishRound enforces that the protocol
> only sends the clock-update once (1) the round operations are
> concluded and (2) the environment has given the command to advance the
> round.[^23]
>
> **Fig.16.** The UC-specific round conclusion of a synchronous
> protocol.

# C The Simulator

> Below we present the simulator used in the proof that the UC
> implementation of Ouroboros Genesis securely realizes the ledger
> functionality *G*~ledger~. The simulator shares the basic structure
> with the simulator provided in \[3\] and differs in several low-level
> details.
>
> **Simulator** *S*~ledg~ (Part 1 - Main Structure)
>
> **Overview:**

-   The simulator internally emulates all local UC functionalities by
    > running the code (and keeping the state) of

*F*VRF, *F*KES, *F*INIT, *F*N-MCbc , and *F*N-MCtx .

-   The simulator mimics the execution of Ouroboros-Genesis for each
    > honest party *U~p\ ~*(including their state and the interaction
    > with the hybrids).

-   The simulator emulates a view towards the adversary *A* in a
    > black-box way, i.e., by internally running adversary *A* and
    > simulating his interaction with the protocol (and hybrids) as
    > detailed below for each hybrid. To simplify the description, we
    > assume *A* does not violate the requirements by the wrapper
    > *W*~OG~*^PoS^*(*·*) as this would imply no interaction between
    > *S*~ledg~ (i.e., the emulated hybrids) and *A*.

-   For global functionalities, the simulator simply relays the messages
    > sent from *A* to the global functionalities (and returns the
    > generated replies). Recall that the ideal world consists of the
    > dummy parties, the ledger functionality, the clock, and the global
    > random oracle.

> **Party sets:**

-   As defined in the main body of this paper, honest parties are
    > categorized. We denote *S*~alert~ the alert parties

> (synchronized and executing the protocol) and use *S*~syncStalled~
> shorthand for parties that are synchronized (and hence time aware and
> online) but stalled. Finally, we denote by *P~DS\ ~*all honest but
> de-synchronized parties (both operational or stalled).

-   For each registered honest party, the simulator maintains the local
    > state containing in particular the local chain *^C^*~loc~^(*Up*)^,
    > the time *t*~on~ it remembers when last being online. For each
    > party *U~p\ ~*and clock time *τ*, the simulator stores a flag
    > update*~Up~,τ* (initially false) to remember whether this party
    > has updated its state already in this round. Note that an
    > registered party is registered with all its local hybrids.

-   Upon any activation, the simulator will query the current party set
    > from the ledger, the clock, and the random oracle to evaluate in
    > which category an honest party belongs to. If a new honest party
    > is registered to the ledger, it internally runs the initialization
    > procedure of Ouroboros-Genesis.

-   We assume that the simulator queries upon any activation for the
    > sequence *I^\~^~H~^T\ ^*, and the current time *τ* from the clock.
    > We note that the simulator is capable of determining
    > predict-time(*·*) of *G*~ledger~.

> **Messages from the Clock:**

-   Upon receiving (clock-update*,*sid*~C~,U~p~*) from *G*~clock~, if
    > *U~p\ ~*is an honest registered party, then remember that this
    > party has received such a clock update (and the environment gets
    > an activation). Otherwise, send (clock-update*,*sid*~C~,U~p~*) to
    > *A*.

> **Messages from the Ledger:**

-   Upon receiving (submit*,*BTX) from *G*~ledger~ where BTX :=
    > (tx*,*txid*,τ,U~p~*) forward (multicast*,*sid*,*tx) to the
    > simulated network *F*~N-MC~ in the name of *U~p~*. Output the
    > answer of *F*~N-MC~ to the adversary.

-   Upon receiving (maintain-ledger*,*sid*,*minerID) from *G*~ledger~,
    > extract from *I\~~H~^T\ ^*the party *U~p\ ~*that issued this
    > query. If *U~p\ ~*has already completed its round-task, then
    > ignore this request. Otherwise, execute SimulateStaking(*U~p~,τ*).

> **Simulator** *S*~ledg~ (Part 2 - Black-Box Interaction)
>
> *Simulation of Functionality F*~INIT~ *towards A:*

-   The simulator relays back and forth the communication between the
    > (internally emulated) *F*~INIT~ functionality and the adversary
    > *A* acting on behalf of a corrupted party.

-   If at time *τ* = 0, a corrupted party *U~p~ ∈ S*~initStake~
    > registers via (ver keys*,sid,U~p~,v~U~*^vrf^*~p~,v~U~*^kes^*~p~* )
    > to *F*~INIT~, then input (register*,*sid) to *G*ledger on behalf
    > of *U~p~*.

> *Simulation of the Functionalities F*~KES~ *and F*~VRF~ *towards A:*

-   The simulator relays back and forth the communication between the
    > (internally emulated) hybrids and the adversary *A* (either direct
    > communication, communication to *A* caused by emulating the
    > actions of honest parties, or communication of *A* on behalf of a
    > corrupted party).

*Simulation of the Network F*~N-MC~^bc^ *(over which chains are sent)
towards A:*

-   Upon receiving
    > (multicast*,*sid*,*(*C~i~*~1~*,U~i~*~1~)*,\...,*(*C~i\`~,U~i\`~*)
    > with a list of chains and corresponding parties from

> *A* (or on behalf some *corrupted P ∈ P~net~*), then do the following:

1.  Relay this input to the simulate network functionality and record
    its response to *A*.

2.  Execute ExtendLedgerState(*τ*)

3.  Provide *A* with the recorded output of the simulated network.

-   Upon receiving (multicast*,*sid*,C*) from *A* on behalf of some
    > *corrupted* party *P*, then do the following:

    1.  Relay this input to the simulate network functionality and
        record its response to *A*.

    2.  Execute ExtendLedgerState(*τ*)

    3.  Provide *A* with the recorded output of the simulated network.

-   Upon receiving (fetch*,*sid) from *A* on behalf some *corrupted P ∈
    > P~net\ ~*forward the request to the simulated *F*~N-MC~^bc^ and
    > return whatever is returned to *A*.

-   Upon receiving
    > (delays*,*sid*,*(*T*~mid*i*~1*,*mid~*i*1~)*,\...,*(*T*~mid*i*~*\`,*mid*~i\`~*))
    > from *A*: Forward the request to the simulated *F*~N-MC~^bc^ and
    > record the answer to *A*. Before giving this answer to *A*, query
    > the ledger state state and execute AdjustView(state).

-   Upon receiving (swap*,*sid*,*mid*,*mid*^0^*) from *A*: Forward the
    > request to the simulated *F*~N-MC~^bc^ and record the answer to
    > *A*. Before giving this answer to *A*, query the ledger state
    > state and execute AdjustView(state).

*Simulation of the Network F*~N-MC~^tx^ *(over which transactions are
sent) towards A:*

-   Upon receiving
    > (multicast*,*sid*,*(*m~i~*~1~*,U~i~*~1~)*,\...,*(*m~i\`~,U~i\`~*)
    > with list of transactions from *A* on behalf some *corrupted P ∈
    > P~net~*, then do the following:

    1.  Submit the transaction(s) to the ledger on behalf of this
        corrupted party, and receive for each transaction the
        transaction id txid

    2.  Forward the request to the internally simulated *F*~N-MC~^tx^ ,
        which replies for each message with a message-ID mid

    3.  Remember the association between each mid and the corresponding
        txid

    4.  Provide *A* with whatever the network outputs.

-   Upon receiving (multicast*,*sid*,m*) from *A* on behalf of some
    > *corrupted* party *P*, then execute the corresponding steps 1.
    > to 4. as above.

+-----------------------------------------------------------------------+
| -   Upon receiving (fetch*,*sid) from *A* on behalf some *corrupted P |
|     ∈ P~net\ ~*forward the request to the simulated *F*~N-MC~^tx^ and |
|     return whatever is returned to *A*.                               |
|                                                                       |
| -   Upon receiving                                                    |
|     (delays*,*                                                        |
| sid*,*(*T*~mid*i*~1*,*mid~*i*1~)*,\...,*(*T*~mid*i*~*\`,*mid*~i\`~*)) |
|     from *A* forward the request to the simulated                     |
|                                                                       |
| *F*~N-MC~^tx^ and return whatever is returned to *A*.                 |
|                                                                       |
| -   Upon receiving (swap*,*sid*,*mid*,*mid*^0^*) from *A* forward the |
|     request to the simulated *F*~N-MC~^tx^ and return whatever is     |
|     returned to *A*.                                                  |
+=======================================================================+
+-----------------------------------------------------------------------+

> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image16.png){width="6.506667760279965in"
> height="7.220001093613298in"}

+-----------------------------------------------------------------------+
| > **if** Fraction of blocks with hFlag = 0 in the recent *k* blocks   |
| > *\>* 1 *− µ* **then**                                               |
| >                                                                     |
| > **Abort** simulation: chain quality violation. // Event             |
| > BAD-CQ*~µ,k~* **else if** State increases less than *k* blocks      |
| > during the last *~τ~^[k]{.underline}^*CG rounds **then**            |
| >                                                                     |
| > **Abort** simulation: chain growth violation. // Event              |
| > BAD-CG~*τ*CG~*,k/τ*~CG~ **end if**                                  |
|                                                                       |
| // If no bad event occurs, we can adjust pointers into this new       |
| state. Execute AdjustView(state*\|\|*diff) **end procedure**          |
|                                                                       |
| **procedure** AdjustView(state*,τ*)                                   |
|                                                                       |
| > // Adjust the view of synchronized parties.                         |
| >                                                                     |
| > pointers *← ε* **for** *U~p~ ∈ P* of round *τ* **do**               |
| >                                                                     |
| > Let *C*~loc~^(*Up*)^ be the party's currently stored local chain.   |
| >                                                                     |
| > Determine the number of rounds *ρ*^(*Up*)^ this party legs behind   |
| > *τ*, i.e., *ρ*^(*Up*)^ = *τ − t*^(^~on~^*Up*)^.                     |
|                                                                       |
| Let *C*~1~^(*Up*)^*,\...,C~k~*^(*Up*)^ be the chains contained in the |
| receiver buffer *M^\~\ ^*^(*Up*)^ of *F*~N-MC~^bc^ with delay at most |
|                                                                       |
| > *ρ*(*Up*).                                                          |
| >                                                                     |
| > Evaluate *C~Up~ ←*                                                  |
| > maxvalid-bg(*C*~loc~^(*Up*)^*,C*~1~^(*Up*)^*,\...,C~k~*^(*Up*)^)    |
| > and let this chain's encoded state be st*\~ ~Up~*. **end for for**  |
| > each synchronized party *U~p~ ∈ S*~alert~ *∪ S*~syncStalled~ of     |
| > round *τ* **do**                                                    |
| >                                                                     |
| > Determine the pointer pt*~U~p* s.t. st*^\~\ d^~U~^k^~p\ ~*=         |
| > state*\|*~pt*U*~*p* **if** such a pointer value does not exist      |
| > **then return** // Call on invalid input or event BAD-CP*~k~*       |
| > occurred                                                            |
| >                                                                     |
| > **end if if** update*~Up~,τ* = false **then** // Party did not      |
| > start StakingProcedure in *τ*.                                      |
| >                                                                     |
| > pointers *←* pointers*\|\|*(*U~p~,*pt*~U~p*)                        |
|                                                                       |
| **end if** // As otherwise, the new state is only fetched in the next |
| round                                                                 |
|                                                                       |
| > **end for**                                                         |
| >                                                                     |
| > Output (set-slack*,*pointers) to *G*ledger                          |
| >                                                                     |
| > // Now, adjust the view of de-synchronized parties. pointers *← ε*  |
| > desyncStates *← ε*                                                  |
| >                                                                     |
| > **for** each de-synchronized party *U~p~ ∈ P~DS\ ~***do if**        |
| > update*~U~p,τ* = false **then** Set the pointer pt*~U~* to be       |
| > *\|*st*^\~\ d^~U~^k^~p~\|*                                          |
| >                                                                     |
| > *p*                                                                 |
| >                                                                     |
| > pointers *←* pointers*\|\|*(*U~p~,*pt*~U~p*)                        |
| >                                                                     |
| > *d* desyncStates *←* desyncState*\|\|*(*U~p~,*st*\~ ~U~^k^~p~*)     |
|                                                                       |
| **end if** // As otherwise, the new state is only fetched in the next |
| round                                                                 |
|                                                                       |
| > Output (set-slack*,*pointers) to *G*ledger                          |
|                                                                       |
| Output (desync-state*,*desyncStates) to *G*ledger **end for end       |
| procedure**                                                           |
+=======================================================================+
+-----------------------------------------------------------------------+

# D Proof-of-Stake Assumptions as a UC Wrapper

> This section includes complementary material for the main body. We
> sketch below the wrapper functionality that is applied to the hybrid
> functionalities used by Ouroboros-Genesis. For details on more
> background of functionality wrappers we refer to \[3\]. In a nutshell,
> the wrapper observes the advancement of the entire system and checks
> whether the proportional stake of alert parties, of corrupted or
> de-synchronized parties, and of stalled parties are withing the
> allowed range specified as required by our main theorems.
>
> **Functionality** *W*~OG~*^PoS^*(*·*)
>
> The wrapper functionality is parameterized by the bounds *α*,*β* on
> the alert and participating stake ratio (see Definition 2),
> respectively, the network delay and a value *ε \>* 0 (the parameter
> that describes the gap between the honest and adversarial stake). The
> wrapper is assumed to be registered with the global clock *G*~clock~
> and is aware of sets of registered parties, and the set of corrupted
> parties.
>
> *General:*

-   Upon receiving any request *I* from any party *U~p\ ~*or from *A*
    > (possibly on behalf of a party *U~p\ ~*which is corrupted) to a
    > wrapped hybrid functionality, record the request *I* together with
    > its source and the current time.

-   The wrapper keeps track of the active parties and their relative
    > share to the stake distribution.

> *Restrictions on obtaining VRF proofs:*

-   Upon receiving (EvalProve*,*sid*,·*) to *F*~VRF~ from *A* on behalf
    > of a party *U~p\ ~*which is corrupted or registered but
    > de-synchronized do the following:

    1.  If the fraction of alert stake relative to all active stake in
        this round *τ* so far does not satisfy the honest majority
        condition 4 (of Theorems 1 and 2) then ignore the request.

    2.  Otherwise, forward the request to *F*~VRF~ and return to *A*
        whatever *G*~RO~ returns. **--** Upon receiving
        (EvalProve*,*sid*,·*) to *F*~VRF~ from an alert party *U~p\ ~*do
        the following:

    ```{=html}
    <!-- -->
    ```
    1.  Forward the request to *F*~VRF~ and return to *A* whatever
        *G*~RO~ returns.

    2.  If the minimal fraction (in stake) of participation (of alert
        parties and in total) as demanded by Theorem 1 (and Theorem 2)
        is reached in round *τ*, send (clock-update*,*sid*~C~*) to
        *G*~clock~ to release the clock for this round.

-   Any other request is relayed to the underlying functionality (and
    > recorded by the wrapper) and the corresponding output is given to
    > the destination specified by the underlying functionality.

# E Proof of Theorem 1

> In this appendix we prove Theorem 1. We begin with a detailed
> treatment of the relevant machinery from \[14\] for reasoning about
> blockchain "forks" and the common prefix property in the
> semi-synchronous setting. Our setting---which provides the adversary
> adaptive control over availability of the participating
> parties---appears to require significant further considerations. In
> particular, the techniques of \[14\] assume that slot leaders are
> elected by an *independent* process, so that various relevant events
> (such as whether a unique party has been assigned to a particular
> slot) are independent across distinct slots. The stronger adversary in
> the dynamic availability setting can conspire to correlate such
> events. Our analysis handles such correlations by modeling the
> underlying process of leader assignment as a martingale, and
> constructs a parallel theory to that of \[14\] that supports these
> richer distributions. Our exposition is self-contained; however, in
> some cases where the particular arguments are similar in spirit to the
> treatment in \[14\], we only sketch them.
>
> In Sections E.1 and E.2 we briefly lay out the framework of forks,
> divergence, and *∆*-reduction developed by Kiayias et al. \[22\] and
> David et al. \[14\]. With these definitions set down, we proceed in
> Section E.3 to the new proofs of divergence for the richer
> distributions induced by an adversary in the setting with dynamic
> availability. We then describe the exact distribution of the
> characteristic strings that arises in the real experiment in Section
> E.4 and combine these results in E.5 to establish common prefix, chain
> growth, and chain quality for a single epoch. Finally, we lift these
> results into the multi-epoch setting in Section E.6.
>
> Note that Theorem 1, and hence also this whole section, works in the
> so-called setting with static *F*~N-MC~registration as defined in
> Section 4.2, postulating that all honest parties are registered with
> the network functionality *F*~N-MC~ from the beginning and never
> deregister. Therefore, all honest parties are guaranteed to be
> *online* and *synchronized*. However, not all honest parties are
> guaranteed to be *alert*, as some of them might still be
> *time-unaware* or *stalled* (cf. Fig. 1).
>
> We approach these two classes of parties in different ways in the
> formal treatment below: for *stalled* honest parties that are
> *time-aware*, we treat the slots where they would be the only slot
> leaders as empty slots. Looking ahead, this leads to the adaptive
> control of the environment over the emptiness of slots (via stalling
> alert parties), which warrants our martingale-based treatment. On the
> other hand, the honest parties that are *time-unaware* pose a risk for
> all slots for which they are eligible slot leaders, as even though
> they are not corrupted at the moment, they are not able to properly
> evolve their key and hence their later corruption would have
> detrimental effects for such slots. Therefore, we account for these
> parties by treating them identically to adversarial parties (namely,
> including them in the set of *active* parties), even though formally
> they are not adversarial.

## E.1 Forks and Divergence in the Semi-synchronous Setting

> We recall the notion of a *characteristic string*, which we use to
> record, for each slot in a sequence of slots, whether any leader is
> elected for the slot and, if that is the case, whether this leader is
> unique and alert.
>
> **Definition 8 (Characteristic string).** *Let S* =
> *{sl*~1~*,\...,sl~R~} be a sequence of slots of length R; consider an
> execution (with adversary A and environment Z) of the protocol. For a
> slot sl~j~, let* P(*j*) *denote the set of active parties assigned to
> be slot leaders for slot j by the protocol. We define the*
> characteristic string *w ∈ {*0*,*1*,⊥}^R^ of S to be the random
> variable so that*

+---------+----------------------------------------------------------+---+
| >  *⊥* | *if* P(*j*) = *∅, if \|*P(*j*)*\|* = 1 *and the assigned | \ |
| >       | party is alert, otherwise.*                              | ( |
| >     |                                                          | 8 |
|         |                                                          | \ |
| *w      |                                                          | ) |
| ~j\ ~*= |                                                          |   |
| 0       |                                                          |   |
|         |                                                          |   |
| > 1   |                                                          |   |
+=========+==========================================================+===+
+---------+----------------------------------------------------------+---+

> *For such a characteristic string w ∈ {*0*,*1*,⊥}^∗^ we say that the
> index j is* uniquely alert *if w~j\ ~*= 0*,* empty *if w~j\ ~*= *⊥,
> and* potentially active *if w~j~ ∈ {*0*,*1*}.*
>
> We emphasize that the characteristic string resulting from an
> execution is determined by both the nonce (and the effective leader
> selection process), the adaptive adversary *A*, and the environment
> *Z* (which, in particular, determines the stake distribution).
>
> *Remark 3.* A reader familiar with the treatment in \[14\] will notice
> that Definition 8 syntactically differs from the definition of a
> characteristic string in \[14\], by only considering *active* parties,
> and by assigning the symbol 0 only to slots that have a unique *alert*
> slot leader, as opposed to a unique *honest* one. This is because the
> analysis in \[14\] does not consider stalled parties, and hence there
> an honest party is always alert and all parties are active. The
> semantics of the definition is maintained: a slot labeled by 0 in both
> cases guarantees that there is will be exactly one block created for
> this slot, and it will be created according to the protocol.
> Additionally, a slot labeled by *⊥* guarantees that no party (either
> honest or adversarial) is in the position to create a block for this
> slot. This syntactic difference propagates also to some of the
> following definitions and statements, we will refrain from pointing it
> out repeatedly.
>
> The notion of a *∆*-fork is the analytic tool developed by David et
> al. \[14\] to reason about the various blockchains that can be induced
> by an adversary in the *∆*-synchronous setting with a particular
> characteristic string.
>
> **Definition 9 (***∆***-fork).** *Let w ∈ {*0*,*1*,⊥}^k^ and ∆ be a
> non-negative integer. Let A* = *{i\|w~i\ ~*=*6* *⊥} denote the set of
> potentially active indices, and let H* = *{i\|w~i\ ~*= 0*} denote the
> set of uniquely alert indices. A ∆*-fork *for the string w is a rooted
> tree F* = (*V,E*) *with a labeling \`* : *V → {*0*} ∪ A so that*

(i) *the root r ∈ V is given the label \`*(*r*) = 0*;*

(ii) *the labels along any (simple) path beginning at the root are
     strictly increasing;*

(iii) *each uniquely alert index i ∈ H is the label of exactly one
      vertex of F;*

(iv) *the function* **d** : *H → {*1*,\...,k}, defined so that*
     **d**(*i*) *is the depth in F of the unique vertex v for which
     \`*(*v*) = *i, satisfies the following ∆*-monotonicity *property:
     if i,j ∈ H and i* + *∆ \< j, then* **d**(*i*) *\<* **d**(*j*)*.*

> *For convenience, we direct the edges of forks so that depth increases
> along each edge; then there is a unique directed path from the root to
> each vertex and, in light of (ii), labels along such a path are
> strictly increasing. As a matter of notation, we write F \`~∆~ w to
> indicate that F is a ∆-fork for the string w. We typically refer to a
> ∆-fork as simply a "fork".*
>
> The relationship between executions and *∆*-forks is formally
> described in \[14\]. Here we only recall the basic intuition: With an
> execution of Ouroboros Genesis we may associate the collection of all
> valid blockchains that were adopted by honest players as a result of
> their application of the maxvalid rule. Observe that any two
> blockchains held by honest players agree on some common prefix
> (including, at the very least, the genesis block); on the other hand,
> aside from this common prefix, the blockchains are entirely disjoint.
> Thus the union of these blockchains forms a natural "tree of blocks",
> which is reflected by the notion of fork above. Indeed, the axiom (ii)
> reflects the fact that blocks in a valid blockchain must be associated
> with strictly increasing time slots, while axiom (iii) reflects the
> fact that an honest, alert slot leader emits exactly one block
> (associated with that slot). The axiom (iv) reflects the fact that an
> honest party *p* at time *t* must have received any blocks produced by
> honest parties at times prior to *t−∆*; thus the depth of any block
> produced by *p* must exceed the depths of those blocks produced by
> these earlier honest parties. Thus, while a fork is clearly an
> abstraction that neglects some aspects of the execution, it does
> capture its salient features with respect to common prefix violations;
> see Remark 4 below.
>
> **Definition 10 (Tines, length, and viability).** *A path in a fork F
> originating at the root is called a* tine*. For a tine t we let
> length*(*t*) *denote its* length*, equal to the number of edges on the
> path. For a vertex v, we call the length of the tine terminating at v
> the* depth of *v. For convenience, we overload the notation \`*(*·*)
> *so that it applies to tines by defining \`*(*t*) , *\`*(*v*)*, where
> v is the terminal vertex on the tine t. We say that a tine t is
> ∆*-viable *if length*(*t*) *≥* max~*h*+*∆≤\`*(*t*)~ **d**(*h*)*, this
> maximum extended over all uniquely alert indices h (appearing ∆ or
> more slots before \`*(*t*)*). Note that any tine terminating in a
> uniquely alert vertex is necessarily viable by the ∆-monotonicity
> property.*
>
> A remark on the intuition behind viability: A viable tine is one
> which---at least in principle---could have been accepted as the
> longest chain by an alert party. In particular, if the last block of
> the chain is associated with slot *t*, the chain must have length at
> least that of all honest chains produced no later than *t − ∆*, as
> these would necessarily be observed by any alert player at time *t* +
> 1.
>
> **Definition 11 (Divergence).** *Let F be a ∆-fork for a string w ∈
> {*0*,*1*,⊥}^∗^. For two ∆-viable tines t and t^0^ of F, we define the
> notation t/t^0^ by the rule*

*^t/t0^* = *length*(*t*) *− length*(*t ∩ ^t0^*)*,*

> *where t ∩ t^0^ denotes the common prefix of t and t^0^. Then define
> the* divergence *of two viable tines t*~1~ *and t*~2~ *to be the
> quantity*
>
> 
>
> ~~*t*~1~*/t*~2~ *if \`*(*t*~1~) *\< \`*(*t*~2~)*,*
> div(*t*~1~*,t*~2~) = *t*~2~*/t*~1~ *if \`*(*t*~2~) *\< \`*(*t*~1~)*,*

^^max(*t*~1~*/t*~2~*,t*~2~*/t*~1~) *if \`*(*t*~1~) = *\`*(*t*~2~)*.*

> *We extend this notation to the fork F by maximizing over viable
> tines:* div*~∆~*(*F*) , max~*t*1*,t*2~ div(*t*~1~*,t*~2~)*, taken over
> all pairs of ∆-viable tines of F. Finally, we define the ∆-divergence
> of a characteristic string w to be the maximum over all ∆-forks:*
> div*~∆~*(*w*) , max*~F\ \`∆w~* div*~∆~*(*F*)*.*
>
> *Remark 4.* Divergence provides an immediate bound on common prefix
> violations. In particular, any execution of the protocol inducing a
> characteristic string *w* produces honest blockchains satisfying the
> div*~∆~*(*w*)common prefix property.
>
> Given the above, we will now focus on bounding the *∆*-divergence of
> characteristic strings arising from protocol executions.

## E.2 The Reduction Mapping

> David et al. \[14\] provided a method for bounding *∆*-divergence by
> establishing a direct connection between *∆*-divergence and divergence
> in the synchronous setting (when *∆* = 0). We will rely on this
> machinery and here record its basic tools.
>
> **Definition 12 (Synchronous characteristic strings and forks).** *A*
> synchronous characteristic string *is an element of {*0*,*1*}^∗^. A*
> synchronous fork *F for a (synchronous) characteristic string w is a*
> 0*-fork F \`*~0~ *w.*
>
> **Definition 13 (Reduction mapping \[14\]).** *For ∆ ∈* N*, we define
> the function ρ~∆~*: *{*0*,*1*,⊥}^∗^ → {*0*,*1*}^∗^ inductively as
> follows:*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image17.png){width="0.47333333333333333in"
> height="0.14333333333333334in"} *,*
>
> *ρ~∆~*(*⊥kw^0^*) = *ρ~∆~*(*w^0^*)*,*

*ρ~∆~*(1*kw^0^*) = 1*kρ~∆~*(*w^0^*)*,* (9)

### ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image18.png){width="0.98in" height="0.42333333333333334in"}*if w^0^ ∈ ⊥^∆−^*^1^ *k{*0*,*1*,⊥}^∗^,*

> *ρ~∆~*(0*kw*
>
> *otherwise.*
>
> *We call ρ~∆~ the* reduction mapping for delay *∆. It will be
> convenient for us to naturally extend the definition of ρ~∆~ to
> infinite strings over the alphabet {*0*,*1*,⊥}.*
>
> The reduction map provides the basic connection between *∆*-divergence
> and (synchronous) divergence. This is reflected by the lemma below,
> established by David et al. \[14\].
>
> **Lemma 4 (\[14\]).** *Let w ∈ {*0*,*1*,⊥}^∗^. Then* div*~∆~*(*w*) *≤*
> div~0~(*ρ~∆~*(*w*))*.*
>
> We will require also a lemma controlling the behavior of reduction for
> prefixes of a given string. Here we use the notation *x ≺ y* to
> indicate the the string *x* is a prefix of the string *y*.
>
> **Lemma 5 (Implicit in \[14\]).** *If w,w^0^ ∈ {*0*,*1*,⊥}^∗^ and w ≺
> w^0^, then ρ~∆~*(*w*)*^d∆^ ≺ ρ~∆~*(*w^0^*)*.*
>
> *Proof.* The proof proceeds by induction on the length of *w*. When
> *\|w\| ≤ ∆*, observe that *\|ρ~∆~*(*w*)*\| ≤ \|w\| ≤ ∆* and hence
> *ρ~∆~*(*w*)*^d∆^* = . Otherwise *\|w\| \> ∆* and we may write *w* =
> *ax* for a single symbol *a* (and a substring *x*). According to the
> definition, *ρ~∆~*(*ax*) = *αρ~∆~*(*x*) for some
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image19.png){width="0.74in"
> height="0.14333333333333334in"} that is determined solely by the first
> *∆* symbols of *w*; these agree with *w^0^*. By induction *ρ*(*x*) =
> *ρ*(*x^0^*), where *w^0\ ^*= *ax^0^*, which concludes the proof. *tu*

## E.3 Reduction and Divergence with Stalled Parties

> With these definitions and lemmas behind us, we are prepared to bound
> divergence (and common prefix) in our setting with stalled parties.
>
> **Definition 14 (The characteristic conditions).** *Consider a family
> of random variables W*~1~*,\...,W~n~ taking values in {*0*,*1*,⊥}. We
> say that they satisfy the* (*f*;*γ*)-characteristic conditions *if,
> for each k ≥* 1*,*
>
> Pr\[*W~k\ ~*= *⊥\|W*~1~*,\...,W~k−~*~1~\] *≥* (1 *− f*)*,*
> Pr\[*W~k\ ~*= 0*\|W*~1~*,\...,W~k−~*~1~*,W~k~ 6*= *⊥*\] *≥ γ ,and
> hence* Pr\[*W~k\ ~*= 1*\|W*~1~*,\...,W~k−~*~1~*,W~k~ 6*= *⊥*\] *≤* 1
> *− γ .*
>
> *In the expressions above, conditioning on a collection of random
> variables indicates that the statement is true for any conditioning on
> the values taken by variables. We may naturally apply the same
> terminology to infinite sequences of variables taking values in
> {*0*,*1*,⊥}.*
>
> Specifically, for an adversary constrained to (1
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image20.png){width="0.31333333333333335in"
> height="0.14666666666666667in"}2 stake ratio, the characteristic
> string *w*~1~*,\...,w~R\ ~*induced for an epoch of length *R* roughly
> satisfies the (*f*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image21.png){width="0.53in"
> height="0.14666666666666667in"}2)-characteristic conditions. (We lay
> out the exact details in the next section.) Our strategy for bounding
> div*~∆~*(*w*) will be to analyze the structure of the induced
> distribution *ρ~∆~*(*w*) (assuming that *w* satisfies the
> characteristic conditions) and then directly bound the (synchronous)
> divergence of the resulting (synchronous) characteristic string.
>
> **The structure of the reduced distribution** *ρ~∆~*(*w*)**.** As
> mentioned above, we begin by analyzing the structure of the
> distribution given by *ρ~∆~*(*w*). Specifically, we will show that
> these random variables are almost *super*-binomial, in the sense that
> after trimming a short suffix, they satisfy a family of martingale
> conditions which guarantee that each random variable, conditioned on
> all prior values, takes the value 0 with probability at least
> *γ*(1*−f*)^*∆−*1^. Finally, we appeal to a theorem of Kiayias et al.
> \[22\] and Russell et al. \[29\] to establish that *ρ~∆~*(*w*) is
> unlikely to have large divergence.
>
> **Definition 15 (The super-binomial martingale conditions).**
> *Consider a family of random variables X*~1~*,\...,X~n~ taking values
> in {*0*,*1*}^n^. We say that they satisfy the γ*-super-binomial
> martingale *conditions (or, simply, the γ*-martingale *conditions) if*
>
> Pr\[*X~k\ ~*= 0*\|X*~1~*,\...,X~k−~*~1~\] *≥ γ ,and hence*
> Pr\[*X~k\ ~*= 1*\|X*~1~*,\...,X~k−~*~1~\] *≤* 1 *− γ .*
>
> *We may naturally apply the same terminology to infinite sequences of
> variables taking values in {*0*,*1*}.*
>
> It is convenient to explore first the structure of an infinite
> sequence of these variables, as these do not require any "trimming" in
> order to provide the martingale conditions.
>
> **Lemma 6 (Structure of the induced distribution without boundary
> conditions).** *Let W* = *W*~1~*,W*~2~*,\... be an infinite sequence
> of random variables, each taking values in {⊥,*0*,*1*}, which satisfy
> the* (*f*;*γ*)*-characteristic conditions and let*
>
> *X* = *ρ~∆~*(*W*)
>
> *be the random variables obtained by applying the reduction mapping
> (for delay ∆) to W. Then X* = *X*~1~*,\..., satisfy the γ*(1 *−
> f*)^(*∆−*1)^*-martingale conditions.*
>
> *Proof.* For each *k ≥* 1 we wish to establish that the random
> variables *X*~1~*,\...,X~k\ ~*satisfy the *γ*(1 *−
> f*)^(*∆−*1)^super-binomial martingale conditions. We prove these
> conditions under further conditioning. Specifically, we say that a
> finite sequence *w*~1~*,\...,w~\`~*, where each *w~i~ ∈ {*0*,*1*,⊥}*,
> is a *t-sequence* if exactly *t* of the *w~i\ ~*are elements of
> *{*0*,*1*}*. For a (*k −* 1)-sequence *w*, let *E~w\ ~*denote the
> event that *W~i\ ~*= *w~i\ ~*(for each 1 *≤ i ≤ \`*) and that
> *W~\`~*~+1~ *6*= *⊥*. Observe that these events *E~w~*, taken over all
> (*k −* 1)-sequences *w* of all possible lengths *\`*, partition the
> probability space over which *W*~1~*,W*~2~*,\...* is defined.
> Furthermore, for any (*k −* 1)-sequence *w*, conditioning on
> *E~w\ ~*determines the random variables *X*~1~*,\...,X~k−~*~1~; we
> write *ρ~∆~*(*w*) to denote the unique assignment to
> *X*~1~*,\...,X~k−~*~1~ resulting from this (*k−*1)-sequence *w*. It
> follows that, for any fixed *x*~1~*,\...,x~k−~*~1~, the events
> *E~w\ ~*for which *ρ~∆~*(*w*) = *x*~1~*,\...,x~k−~*~1~ partition the
> event that the random variables *X*~1~*,\...,X~k−~*~1~ take the values
> *x*~1~*,\...,x~k−~*~1~. Finally, observe that---conditioned on any
> specific *E~w~*---the (*f,γ*)-characteristic conditions guarantee that
> (*W~\`~,W~\`~*~+1~*,\...,W~\`~*~+(*∆−*1)~) = (0*,⊥,\...,⊥*) with
> probability at least *γ*(1 *− f*)^*∆−*1^.
>
> In this case, *X~k\ ~*= 0, and we conclude that
>
> Pr\[*X~k\ ~*= 0*\|E~w~*\] *≥ γ*(1 *− f*)^*∆−*1^ *.*
>
> It follows that for any fixed values *x*~1~*,\...,x~k−~*~1~,
>
> Pr\[*X~k\ ~*= 0*\|X~i\ ~*= *x~i~*\] *≥ γ*(1 *− f*)^*∆−*1^ *,*

as desired. *tu*

> We record two immediate applications of Azuma's inequality for random
> variables satisfying the *γ*-superbinomial martingale conditions.
>
> **Lemma 7.** *Let X*~1~*,\...,X~n~ satisfy the γ-super-binomial
> martingale conditions with γ ≥* 1*/*2*. Then, for any δ \>* 0*,*

Pr\[#~0~(*X*) *≤* (1 *− δ*)*γn*\] *≤* exp *−δ*^2^*n/*2 (10)

> *and*

+--------------------------------------------------------------------+---+
| > *δ*^2^(2*γ −* 1)^2^*n*                                           | \ |
|                                                                    | ( |
| Pr\[#~0~(*X*) *−* \#~1~(*X*) *≤* (1 *− δ*)(2*γ −* 1)*n*\] *≤* exp  | 1 |
| *−* ~2~                                                            | 1 |
|                                                                    | \ |
| > 8*γ ≤* exp *−δ*^2^(2*γ −* 1)^2^*n/*8 *,*                         | ) |
|                                                                    |   |
| *where* \#~0~(*X*) = *\|{i\|X~i\ ~*= 0*}\| and* \#~1~(*X*) =       |   |
| *\|{i\|X~i\ ~*= 1*}\|.*                                            |   |
+====================================================================+===+
+--------------------------------------------------------------------+---+

> *Proof.* For (10), consider the random variables *H~k\ ~*=
> ^P*k*^~*i*=1~((1 *− X~i~*) *− γ*) = \#~0~(*X*~1~*,\...,X~k~*) *− kγ*.
> Observe that E\[*H~k~ \|H*~1~*,\...H~k−~*~1~\] *≥ H~k−~*~1~ and that
> *\|H~k~ −H~k−~*~1~*\| ≤* max(*γ,*1*−γ*) = *γ*, as *γ ≥* 1*/*2.
> Applying Azuma's inequality (Theorem 9 in Appendix F) to the variables
> *H~k\ ~*yields
>
> Pr\[*H~n~ ≤ −δγn*\] *≤* exp(*−δ*^2^*n/*2)*,*
>
> equivalent to (10). As for (11), consider the random variables
>
> *k*
>
> *B~k\ ~*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image22.png){width="4.1033333333333335in"
> height="0.20333333333333334in"}*.*
>
> *i*=1
>
> Then E\[*B~k~ \|B*~1~*,\...,B~k−~*~1~\] *≥ B~k−~*~1~ and *\|B~t~ −
> B~t−~*~1~*\| ≤* 2*γ* as *γ ≥* 1*/*2; applying Azuma's inequality to
> the random variables *B~k\ ~*yields (11). *tu*

## Lemma 8 (Structure of the induced distribution). *Let W* = *W*~1~ *···W~n~ be a sequence of random*

> *variables, each taking values in {⊥,*0*,*1*}, which satisfy the*
> (*f*;*γ*)*-characteristic conditions and let*

### *X* = *X*~1~ *···X~\`\ ~*= *ρ~∆~*(*W*~1~ *···W~n~*)

> *be the random variables obtained by applying the reduction mapping
> (for delay ∆) to W. Then there is a sequence of random variables
> Z*~1~*,Z*~2~*,\..., each taking values in {*0*,*1*}, so that*

*(i) the random variables Z*~1~*,\..., satisfy the γ*(1 *−
f*)^*∆−*1^*-martingale conditions; (ii) X*~1~*,\...,X~\`−∆\ ~*=
*ρ~∆~*(*W*)*^d∆^ is a prefix of Z*~1~*Z*~2~ *···.*

> *Under the further condition that* Pr\[*W~i\ ~*=
> *⊥\|W*~1~*,\...,W~i−~*~1~\] *≤* (1 *− a*)*, we also have:*

(iii) *the random variable \` satisfies, for any δ \>* 0*,*

> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image23.png){width="1.7833333333333334in"
> height="0.3433333333333333in"}2 2

Pr\[*\` \< ≤* exp *−δ*^2^*a*^2^*n/*2 ; (12)

(iv) *finally, if*
     ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image24.png){width="1.47in"
     height="0.16in"} *for some ≥* 0 *then*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image25.png){width="0.38in"
height="0.14333333333333334in"}*an* *a*2*n* *an* *a*2*n*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image26.png){width="1.11in"
height="0.18666666666666668in"} Pr \#~0~(*X*) *\< − ∆ ≤* exp *− ≤* 2exp
*−* (13)

> 464
>
> *and*

h *an* i *a*2*n* 2*an* 2*a*2*n*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image27.png){width="3.4266666666666667in"
height="0.21in"} Pr \#~0~(*X*) *−* \#~1~(*X*) *\< −* 2*∆ ≤* exp *−*

> 4
>
> *Proof.* Treat the random variables *W* = *W*~1~ *···W~n\ ~*as the
> first *n* symbols of an infinite sequence *W*~1~*W*~2~ *···* of random
> variables satisfying the (*f,*)-characteristic conditions. It is clear
> that such an infinite sequence of variables exists, as the random
> variables appearing in the extension *W~n~*~+1~*,\...* can be taken to
> be i.i.d. with a coordinatewise distribution that satisfies the
> (*f*;*γ*)-characteristic conditions with equality. Then define

### *Z*~1~*Z*~2~ *···* , *ρ~∆~*(*W*~1~*W*~2~ *···*)*,*

> we wish to show that these variables satisfy the statement of the
> theorem.
>
> In light of Lemma 6, the random variables *Z*~1~*,Z*~2~*,\...* satisfy
> the *γ*(1 *− f*)^*∆−*1^-martingale conditions as needed for (i). By
> Lemma 5,
>
> *ρ~∆~*(*W*~1~ *\...W~n~*)*^d∆^ ≺ ρ~∆~*(*W*~1~*W*~2~ *\...*) =
> *Z*~1~*Z*~2~ *\... ,*
>
> proving (ii).
>
> The bound (12) on *\`* follows by considering the random variables
>
> (

1.  if *W~i\ ~*= *⊥*,

> *A~i\ ~*,

2.  if *W~i~ 6*= *⊥*,

> so that *\`* = ^P*n*^~*i*=1~ *A~i~*. Then Pr\[*A~i\ ~*=
> 1*\|A*~1~*,\...,A~i−~*~1~\] *≥ a* and applying Azuma's inequality
> (Theorem 9) to the random variables *B~t\ ~*,^P*t*^~*i*=1~(*A~i~ − a*)
> yields the result.
>
> With this length bound established, we note that *\` ≤* (3*/*4)*an*
> with probability no more than exp(*−a*^2^*n/*32) and, in light of
> (ii), when *\` ≥* (3*/*4)*an* we must have \#~0~(*X*) *≥*
> \#~0~(*Z*~1~*,\...,Z*~3*an/*4~) *− ∆*. Applying the bound of (10) to
> the *Z~i\ ~*with *δ* = 1*/*4, we conclude that the probability that
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image28.png){width="0.6466666666666666in"
> height="0.2866666666666667in"}![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image29.png){width="2.1866666666666665in"
> height="0.3in"}3
>
> \#~0~(*Z*~1~*,\...,Z·*
>
> is no more than exp(*−*(3*/*4)*an/*32) *≤* exp(*−an/*64); taking the
> union bound over these two bad events yields (13).
>
> Finally, consider (14). As above, we note that *\` ≤ an/*2 with
> probability no more than exp(*−a*^2^*n/*8).
>
> Note that
>
> \#~0~(*X*) *−* \#~1~(*X*) *≥* \#~0~(*Z*~b~) *−* \#~1~(*Z*~b~) *−*
> 2*∆,*
>
> where *Z*~b~, *Z*~1~ *\...Z~\`~*. Observe, however, that the
> probability that *any* prefix *Z*^(*t*)^ = *Z*~1~ *\...Z~t~*, where
> *an/*2 *≤ t ≤ n*, has
> \#![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image30.png){width="2.7533333333333334in"
> height="0.16333333333333333in"} *an/*4 is no more than
>
> *n ·* exp(*−*^2^*an/*64)
>
> by (11). (This follows by taking the union bound over each of the
> individual *n − an/*2 *≤ n* bad events.)

Finally, taking the union bound over these two bad events yields (14).
*tu*

> **Divergence and forkability of** *ρ~∆~*(*w*)**.** We record a theorem
> of Russell et al. \[29\] which bounds the probability that random
> variables satisfying the (1 + )*/*2-martingale conditions are
> forkable.
>
> **Theorem 4 (implicit in \[29\]).** *Let X*~1~*,\...,X~n~ be random
> variables taking values in {*0*,*1*} that satisfy the* (1 +
> )*/*2*-martingale conditions. Then*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image31.png){width="0.7466666666666667in"
height="0.34in"} 4*n* 4*n*

Pr\[*X*~1~ *···X~n~ is forkable*\] *≤* exp *− .*

1 + 35 18

> *Note that the constant* 1*/*18 *is quite loose when is small; in
> particular, the bound is* exp(*−*2^4^(1 *− O*())*n*)*.*
>
> In fact, the original presentation \[29\] stated the result for
> binomially distributed variables, but the proof appearing there
> proceeds via a martingale analysis which can be immediately adapted to
> our setting where the *X~i\ ~*are themselves a super-binomial
> martingale (e.g., satisfy the (1 + )*/*2-martingale conditions).
>
> We record, also, the fundamental relationship between forkable strings
> and divergence, established by Kiayias et al. \[22\].
>
> **Theorem 5 (\[22\]).** *Let w ∈ {*0*,*1*}^∗^. Then there is forkable
> substring w*ˇ *of w with \|w*ˇ*\| ≥* div~0~(*w*)*.*
>
> Finally, we combine these results to control div*~∆~*(*W*) for a
> string *W* satisfying the (*f*;*γ*)-characteristic conditions.
>
> **Theorem 6.** *Let W* = *W*~1~*,\...,W~R~ be a family of random
> variables, taking values in {*0*,*1*,⊥} and satisfying the*
> (*f,γ*)*-characteristic conditions. If ∆ \>* 0 *and \>* 0 *satisfy*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image32.png){width="1.79in"
> height="0.16in"}
>
> 19*R*

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image33.png){width="1.7533333333333334in"
height="0.18in"} Pr\[div*~∆~*( ) + \] *k/*18)*.*

> *Proof.* Defining *X* = *ρ~∆~*(*W*), we have

div![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image34.png){width="0.53in"
height="0.24in"}
div![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image35.png){width="1.59in"
height="0.24in"} div(*Z*~1~ *\...Z~R~*) + *∆,* (15)

> where *Z*~1~*,Z*~2~*,\...* are the random variables satisfying the
> *γ*(1 *− f*)^*∆−*1^-martingale conditions promised by Lemma 8. Above,
> inequality (*a*) follows from Lemma 4, inequality (*b*) from the fact
> that divergence satisfies the growth bound

div~0~(*xy*) *≤* div~0~(*x*) + *\|y\|,* (16)

> and inequality (*c*) follows from Lemma 8(ii) and (16). By Theorem 5,
> when div~0~(*Z*) *≥ k* there is a forkable substring of *Z* of length
> at least *k*; then summing the bounds provided by Theorem 4 over all
> lengths at least *k* we find that the probability of such a substring
> beginning at a particular fixed index is no more than

![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image36.png){width="3.76in"
height="0.3566666666666667in"}![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image37.png){width="0.9966666666666667in"
height="0.3233333333333333in"} 4 4 4

18 18

*t*=*k t*=0

*≤* exp *−*

^4^ 18

> As there are no more than *R* indices where such a forkable string
> could begin, we conclude that
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image38.png){width="2.25in"
> height="0.34in"}4

Pr\[div *.*

^4^ 18

Combining this with (15), the statement of the theorem follows
immediately. *tu*

## E.4 Distribution of Characteristic Strings in a Single Epoch

> We now consider an execution of Ouroboros-Praos over a single epoch
> consisting of *R* slots in the setting with static
> *F*~N-MC~-registration (as in Theorem 1). We assume that the
> randomness used for slot leader selection throughout this epoch is
> perfect (i.e., unbiased by the adversary) and known to all
> participating stakeholders (just as in the first epoch, where it is a
> part of the genesis block **G** provided by *F*~INIT~). In what
> follows, we refer to this as the *single-epoch* setting.
>
> Recall that within a single epoch, the stake distribution used for
> electing slot leaders is fixed. Nonetheless, there are still several
> adaptive aspects of the experiment: the adversary is allowed to
> adaptively corrupt stakeholders (so the amount of corrupted stake may
> adaptively increase during an epoch); and the environment can
> adaptively make parties stalled or time-unaware by deregistering them
> either from *G*~RO~ or *G*~clock~ (and of course, register them back).
>
> As determined by the Ouroboros-Praos protocol, a party with relative
> stake *α ∈* \[0*,*1\] becomes a slot leader for a given slot with
> probability
>
> *φ~f~*(*α*) = 1 *−* (1 *− f*)*^α^ .*
>
> We recall the motivation (from \[14\]) for this non-linear stake
> scaling convention for leader selection: the function
> *φ~f\ ~*satisfies the "independent aggregation" property:

!

1 *− φ* ^X^*α~i\ ~*= ^Y^(1 *− φ*(*α~i~*)) *.* (17)

*i i*

> In particular, when leadership is determined according to *φ~f~*, the
> probability of a stakeholder becoming a slot leader in a particular
> slot is independent of whether this stakeholder acts as a single party
> in the protocol, or splits its stake among several "virtual" parties.
> In particular, consider a party *U* with relative stake *α* who
> contrives to split its stake among two virtual subordinate parties
> with stakes *α*~1~ and *α*~2~ (so that *α*~1~ + *α*~2~ = *α*). Then
> the probability that one of these virtual parties is elected for a
> particular slot is 1*−*(1*−φ*(*α*~1~))(1*−φ*(*α*~2~)), as these events
> are independent. Property (17) guarantees that this is identical to
> *φ*(*α*). *Thus this selection rule is invariant under arbitrary
> reapportionment of a party's stake among virtual parties.* We record
> some further elementary properties of this convention.
>
> **Proposition 1.** *The function φ~f~*(*α*) *satisfies the following
> properties.*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image39.png){width="1.7233333333333334in"
> height="0.4266666666666667in"}

*φ~f\ ~*^XX^*φ~f~*(*α~i~*)*, for any α~i~ ≥* 0*,* (18)

*i i i*

*f*2 *f*3

*αf ≤ φ~f~*(*α*) *≤ α*(*−*ln(1 *− f*)) = *α f*
![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image40.png){width="0.98in"
height="0.18666666666666668in"} *, for any α ∈* \[0*,*1\]*.* (19)

> *Proof.* These inequalities are discussed and proven in \[14\] with
> the exception of the bound
>
> *φ~f~*(*α*) *≤ α*(*−*ln(1 *− f*))*.*
>
> This follows because
>
> *dφf* (0) = *−*ln(1 *− f*) and *d*2*φf* (*α*) = *−*(1 *− f*)*α* ln(1
> *− f*)2 *. dα dα*^2^
>
> As the second derivative is everywhere negative, the linear
> approximation via the first derivative at zero is an upper bound. *tu*
>
> Our adversarial stake assumptions yield a characteristic string
> distribution *W*~1~*,\...,W~R\ ~*governed by the (evolving) stake of
> the alert and active participants during each slot. In preparation for
> a detailed description, recall the definitions of quantities
> *S*^+^(*·*) and *S^−^*(*·*) given in Definition 1 (which we apply
> below to individual parties as well as party classes) and the notions
> of alert and participating stake ratios as per Definition 2.
>
> **Lemma 9.** *The protocol Ouroboros-Praos, when executed in the
> single-epoch setting, induces characteristic strings W*~1~*,\...,W~R~
> (with each W~t~ ∈ {*0*,*1*,⊥}) satisfying*
>
> (1 *− f*) *≤* Pr\[*W~t\ ~*= *⊥\|W*~1~*,\...,W~t−~*~1~\] *≤* ^Y^ (1 *−
> f*)*^S−^*(*U*) = 1 *− φ~f~*(*S^−^*(*P~active~*\[*t*\]))*,*
>
> *U∈P~active~*\[*t*\]
>
> *where P~active~*\[*t*\] *denotes the set of active participants at
> time t. Furthermore,*
>
> Pr\[*Wt* = 0*\|W*1*,\...,Wt−*1\] *≥ φf*(*S−*(*Palert*\[*t*\]))(1 *−
> f*)*S−*(*Pactive*\[*t*\]) *≥ S−*(*Palert*\[*t*\])*f*(1 *− f*)*,*

Pr\[*W~t~ 6*= *⊥\|W*~1~*,\...,W~t−~*~1~\] *≤
φ~f~*(*S*^+^(*P~active~*\[*t*\])) *≤ S*^+^(*P~active~*\[*t*\])(*−*ln(1
*− f*))*, where P~alert~*\[*t*\] *denotes the set of alert participants
at time t.*

> *Proof.* This follows from the definition of characteristic string,
> *φ~f~*(*·*) and the properties (18) and (19). *tu* Then it follows
> immediately that these random variables satisfy the characteristic
> conditions.
>
> **Corollary 2.** *The protocol Ouroboros-Praos, when executed in the
> single-epoch setting, induces characteristic strings W*~1~*,\...,W~R~
> (with each W~t~ ∈ {*0*,*1*,⊥}) satisfying the* (*f*;*c~f~
> ·*(1*−f*)*α*)*-characteristic conditions, where α is a lower-bound on
> the alert stake ratio over the execution and*
>
> *f c~f\ ~*= *.*
>
> *−*ln(1 *− f*)
>
> *Furthermore, as noted above,* Pr\[*W~t\ ~*=
> *⊥\|W*~1~*,\...,W~t−~*~1~\] *≤* 1 *−
> φ~f~*(*S^−^*(*P~active~*\[*t*\]))*.*

*For convenience, we note a weaker, but simpler, conclusion: the
W*~1~*,\...,W~R~ satisfy the* (*f*;(1 *− f*)^2^*α*)*characteristic
conditions and, additionally,*

Pr\[*W~t\ ~*= *⊥\|W*~1~*,\...,W~t−~*~1~\] *≤* 1 *− f ·
S^−^*(*P~active~*\[*t*\])*.* (20)

> *Proof.* The first statement follows directly from Lemma 9 and
> Definition 14. The weaker conclusion follows from the first one, as we
> have

*f f* 1

> *c^f\ ^*^=^ *−* ^=\ 2^*/*2 + *f*^3^*/*3 + *··· ≥* 1 + *f* + *f*^2^ +
> *···* ^=\ 1^ *− f ,* ln(1 *− f*) *f* + *f*
>
> and *φ~f~*(*a*) *≥ fa*. (We remark that the inequality *c~f~ ≥* (1 *−
> f*)(2 + *f*)*/*2 is an alternative polynomial approximation, somewhat
> more cumbersome than the bound above, which is tight to first order at
> *f ≈* 0.) *tu*

## E.5 Common Prefix, Chain Growth, and Chain Quality for a Single Epoch

> **Corollary 3 (Common prefix).** *Let W* = *W*~1~*,\...,W~r~ denote
> the characteristic string induced by the Ouroboros-Praos protocol in
> the single-epoch setting over a sequence of r slots. Assume that \>* 0
> *satisfies*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image41.png){width="1.4733333333333334in"
> height="0.16666666666666666in"}*,*
>
> *where α is a lower-bound on the alert stake ratio over the execution.
> Then*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image42.png){width="1.4633333333333334in"
> height="0.18333333333333332in"}19*r*
>
> Pr\[div*~∆~*(*W*)*k/*18)*,*
>
> *and hence a k-common-prefix violation occurs with probability at
> most*

, 19*r −* ~4~*k/*18)*.*

¯~CP~(*k*;*r,∆,*) ~4~ exp(*∆*

*Proof.* The statement is a direct consequence of combining Theorem 6
with Corollary 2. *tu*

> Following \[17, 14\], for a fixed characteristic string *w* =
> *w*~1~*,\...,w~r\ ~*we say that an index (or slot) *i ∈*
>
> \[1*,r − ∆* + 1\] is *∆-right-isolated* if *w~i\ ~*= 0 and *w~i~*~+1~
> = *w~i~*~+2~ = *···* = *w~i~*~+*∆−*1~ = *⊥*.
>
> In preparation for establishing chain growth and chain quality, we
> describe two further chain properties that will be instrumental in the
> arguments.
>
> **Honest-Bounded Chain Growth (**HCG**); with parameters** *τ ∈*
> (0*,*1\]*,s ∈* N**.** Consider a chain *C* possessed by an alert party
> at the onset of a slot sl. Let sl~1~ and sl~2~ be two previous slots
> for which sl~1~ + *s ≤* sl~2~ *≤* sl and both *C*\[sl~1~\] and
> *C*\[sl~2~\] are honest blocks. Then *\|C*\[sl~1~ + 1 : sl~2~\]*\| ≥ τ
> · s*.
>
> **Honest-Bounded Chain Quality (**HCQ**); with parameters** *τ ∈*
> (0*,*1\]*,s ∈* N**.** Consider a chain *C* possessed by an alert party
> at the onset of a slot sl. Let sl~1~ and sl~2~ be two previous slots
> for which sl~1~ +*s ≤* sl~2~ *≤* sl and both *C*\[sl~1~\] and
> *C*\[sl~2~\] are honest blocks. Then *C*\[sl~1~ +1 : sl~2~\] must
> contain at least *τ · s* honestly generated blocks.
>
> Note that HCQ clearly implies HCG with the same parameters; however,
> looking ahead, we will establish stronger bounds for HCG. These
> properties can be combined with existential chain quality (*∃*CQ,
> defined in Section 4.1) to establish chain growth (CG) and chain
> quality (CQ), as described in the lemma below.
>
> **Lemma 10.** *Consider an execution of Ouroboros-Praos that satisfies
> ∃*CQ *with parameter s~∃~*~CQ~*. Then the following hold:*

1.  *If the execution satisfies* HCG *with parameters τ*~HCG~ *and
    s*~HCG~*, then it satisfies* CG *with parameters*

> *s*HCG

*s* = 2*s∃*CQ + *s*HCG *and τ* = *τ*HCG *· .*

> *s*HCG + 2*s∃*CQ
>
> *In particular, assuming s*~HCG~ *≥* 2*s~∃~*~CQ~*, the execution
> satisfies* CG *with parameter τ ≥ τ*~HCG~*/*2*.*

2.  *If the execution satisfies* HCQ *with parameters τ*~HCQ~ *and
    s*~HCQ~*, then it satisfies* CQ *with parameters*

> *s*HCQ

*k* = 2*s∃*CQ + *s*HCQ *and µ* = *τ*HCQ *· .*

> *s*HCQ + 2*s∃*CQ
>
> *In particular, assuming s*~HCQ~ *≥* 2*s~∃~*~CQ~*, the execution
> satisfies* CQ *with parameter µ* = *τ*~HCQ~*/*2*.*
>
> *Proof.* Regarding the first statement of the lemma, consider a
> portion of a chain *C* held by an alert party spanning *s*b *≥ s* =
> 2*s~∃~*~CQ~ + *s*~HCG~ slots. By *∃*CQ, there must be an honest block
> associated with the first *s~∃~*~CQ~ and last *s~∃~*~CQ~ slots.
> Between these two honest blocks, which are separated by at least
> *s*~HCG~ slots, HCG guarantees that at least
>
> *s*b*−* 2*s∃*CQ *s ≥ τ*HCG *·* *s*HCG *s*b

*τ*HCG *·* (*s*b*−* 2*s∃*CQ) = *τ*HCG *·* b *s*HCG + 2*s∃*CQ

> \| {z }
>
> (*†*)
>
> blocks appear. (The last inequality follows because the function
> *f~λ~*(*x*) = (*x−λ*)*/x*, for any *λ \>* 0, is strictly increasing
> for *x \>* 0---thus (*†*) is minimized when *s*b= *s*~HCG~ +
> 2*s~∃~*~CQ~.) The statement of the lemma follows.
>
> Likewise, for the second statement of the lemma, consider a portion of
> a chain *C* containing ~b~*k ≥ k* = 2*s~∃~*~CQ~ + *s*~HCQ~ blocks; of
> course, this portion must span at least ~b~*k* slots. Applying *∃*CQ
> to the *s~∃~*~CQ~ slots on either side of the interval (as above) and
> HCQ to the remaining ~b~*k −*2*s~∃~*~CQ~ slots, the chain *C* must
> contain at least *k −* 2*s* ! *s*HCQ b *∃*CQ *τ*HCQ *·* (b*k −*
> 2*s∃*CQ) = *τ*HCQ *·* b*k ≥ τ*HCQ *·* b*k*

~b~*k s*HCG + 2*s∃*CQ

honestly-generated blocks. *tu*

> We now establish concrete bounds on HCG, HCQ, and *∃*CQ for
> Ouroboros-Praos in the single-epoch setting.
>
> **Lemma 11.** *Let W* = *W*~1~*,\...,W~r~ denote the characteristic
> string induced by the protocol Ouroboros-Praos in the single-epoch
> setting over a sequence of r slots. Let α,β ∈* \[0*,*1\] *denote lower
> bounds on the alert stake ratio and the participating stake ratio over
> the execution as per Definition 2, and assume that for some ε ∈*
> (0*,*1) *the parameter α satisfies*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image43.png){width="1.4766666666666666in"
> height="0.16666666666666666in"} *.*
>
> *Then* HCG*,* HCQ*, and ∃*CQ *are guaranteed with the following
> parameters:*
>
> HCG**:** *For s ≥* 8*∆/*(*βf*) *and τ* = *βf/*8*,*
>
> Pr\[*W admits a* (*τ,s*)*-*HCG
> *violation*\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image44.png){width="0.39666666666666667in"
> height="0.11666666666666667in"}(*τ,s*;*r*) , 2*r*^2^ exp
> *−*(*fβ*)^2^*s/*64 *.*
>
> HCQ**:** *For
> s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image45.png){width="0.7833333333333333in"
> height="0.14666666666666667in"} *and τ* = *βf/*8*,*
>
> Pr\[*W admits a* (*τ,s*)*-*HCQ
> *violation*\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image46.png){width="0.4066666666666667in"
> height="0.12666666666666668in"}(*τ,s*;*r,*) , *r*^2^(*s* + 1)exp
> *−*(*fβ*)^2^*s/*64 *.*
>
> *∃*CQ**:** *For
> s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image47.png){width="0.7833333333333333in"
> height="0.14333333333333334in"}*,*
>
> Pr\[*W admits a s-∃*CQ
> *violation*\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image48.png){width="0.39666666666666667in"
> height="0.12666666666666668in"}(*s*;*r,*) = *r*^2^(*s* + 1)exp
> *−*(*βf*)^2^*s/*64 *.*
>
> *Proof.* For convenience, let us call a slot *good* if it is
> *∆*-right-isolated uniquely alert, and *bad* if it is neither empty
> nor good. We extend this terminology to blocks by calling a block good
> (resp. bad) if it is associated with a good (resp. bad) slot. For the
> discussion of honest-bounded properties below, consider a chain *C*
> held by an alert party at slot sl and two prior slots sl~1~ and sl~2~
> for which (i.) sl, sl~1~ and sl~2~ belong to the sequence of *r* slots
> inducing *W*; (ii.) both *C*\[sl~1~\] and *C*\[sl~2~\] are honestly
> generated blocks, and (iii.) sl~1~ + *s ≤* sl~2~ *≤* sl. Let *T*
> denote the interval
>
> *T* , *{*sl~1~ + 1*,\...,*sl~2~*}*
>
> and let sl~c~1*,\...,*sl~c~*g* be the increasing sequence of all good
> slots in *T* (here the notion of isolation refers to this block of
> slots: in particular, a good slot must be at least *∆* slots from the
> right end of *T*). Let *V* denote the portion of *W* associated with
> the slots in *T* and let *X* = *ρ~∆~*(*V* ). Note that the good
> (resp., bad) slots appear as 0 (resp., 1) symbols in *X*, and hence
> *g* = \#~0~(*X*). Let also *b* , \#~1~(*X*) denote the number of bad
> slots of *T*.
>
> **HCG**: Recall that honest-bounded chain growth demands that
> *\|C*\[sl~1~ + 1 : sl~2~\]*\| ≥ τs*. To argue this, first observe that
> the uniquely alert slot leader associated with sl~c~2 will consider
> the chain *C*\[0 : sl~1~\] in the chain selection rule, as *C*\[0 :
> sl~1~\] was diffused by a slot leader in sl~1~ and sl~c~2 *≥* sl~c~1 +
> *∆ ≥* sl~1~ + *∆*. In particular, the chain diffused by the unique
> slot leader in sl~c~2 (after block addition) must have length at least
> *\|C*\[0 : sl~1~\]*\|*+1. By the same argument, the chains diffused by
> the uniquely alert players associated with sl~c~2*,\...,*sl~c~*g* must
> grow monotonically: specifically, the chain diffused by the leader at
> slot sl~c~*g* must have length at least *\|C*\[0 : sl~1~\]*\|* + (*g
> −* 1). Finally, note that the player generating the (honest) block
> *C*\[sl~2~\] will have received the chain diffused by the leader of
> sl~c~*g*. We conclude that
>
> *\|C*\[0 : sl~2~\]*\| ≥ \|C*\[0 : sl~1~\]*\|* + *g* = *\|C*\[0 :
> sl~1~\]*\|* + \#~0~(*X*) *.*
>
> Observe now that for
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image49.png){width="0.65in"
> height="0.14333333333333334in"}*βf/*4 *− ∆/s*,
>
> Pr\[*W* admits (*τ,s*)-HCG violation for (sl~1~*,*sl~2~)\] *≤*
> Pr\[#~0~(*X*) *≤ τs*\]
>
> =
> Pr\[#![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image50.png){width="1.56in"
> height="0.14333333333333334in"}
>
> *≤* 2exp *−*(*fβ*)^2^*s/*64 *,*
>
> where the last inequality follows from (13) by using *n* := *s* and
> *a* := *βf*, the latter being justified by (20). By the union bound,
> applied over all pairs of slots, we conclude that
>
> Pr\[*W* admits a (*τ,s*)-HCG violation\] *≤* 2*r*^2^
> exp(*−*(*fβ*)^2^*s/*64)*.*
>
> The simpler bound appearing in the theorem statement can be obtained
> by assuming that *s ≥* 8*∆/*(*βf*) and taking *τ^0\ ^*= *βf/*8. Then
> any (*s,τ^0^*)-HCG violation is a (*s,τ*)-HCG violation, as *τ^0^ \<
> τ* for such *s*.
>
> **HCQ.** Recall that honest-bounded chain quality demands that
> *C*\[sl~1~ +1 : sl~2~\] contains at least *τs* honestly generated
> blocks. Note that, as argued above, *\|C*\[sl~1~ +1 : sl~2~\]*\| ≥ g*.
> On the other hand, the total number of adversarially-generated blocks
> in *C*\[sl~1~ +1 : sl~2~\] can be no more than *b*. It follows that at
> least *g −b* blocks in *C*\[sl~1~ + 1 : sl~2~\] are honest. Observe
> then that for *τ* = *βf/*4 *−* 2*∆/s*,
>
> Pr\[*W* admits a (*τ,s*)-HCQ violation for (sl~1~*,*sl~2~)\] *≤*
> Pr\[#~0~(*X*) *−* \#~1~(*X*) *≤ τs*\]
>
> = Pr\[#~0~(*X*) *−* \#~1~(*X*) *≤ βfs/*4 *−* 2*∆*\]
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image51.png){width="1.6433333333333333in"
> height="0.17666666666666667in"} *,*
>
> where the last inequality follows from (14). Applying the union bound
> over all pairs of slots yields
>
> Pr\[*W* admits a (*τ,s*)-HCQ
> violation\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image52.png){width="1.8166666666666667in"
> height="0.17666666666666667in"} *.*
>
> The simpler bound appearing in the theorem statement can be obtained
> by assuming
> *s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image53.png){width="0.746667760279965in"
> height="0.14333333333333334in"}) and taking *τ^0\ ^*= *βf/*8. Then any
> (*s,τ^0^*)-HCQ violation is a (*s,τ*)-violation, as *τ \< τ^0\ ^*for
> such *s*.
>
> *∃***CQ.** We now consider the probability of an *s*-*∃*CQ-violation.
> Recall that an *s*-*∃*CQ violation is described by a chain *C*,
> eventually held by an alert party, and a pair of slots sl~1~ *\<*
> sl~2~ for which sl~1~ + *s ≤* sl~2~ and *C*\[sl~1~ : sl~2~\] contains
> no honestly generated blocks. Note that in this setting we no longer
> assume that *C*\[sl~1~\] and *C*\[sl~2~\] are honest.
>
> First, observe that all blocks in *C*\[sl~1~ : sl~2~\] are bad (as
> they are not even honestly generated). Let *G*~1~ denote the latest
> honestly-generated block in *C*\[0 : sl~1~ *−* 1\] (note that at least
> *C*\[0\] is considered honest)
>
> and let sl~1~ denote the slot associated with *G*~1~; likewise, let
> *G*~2~ denote the earliest honestly-generated block
>
> appearing in *C*\[sl~2~ + 1 : sl\] (or the last block of *C*, if there
> is no honest one) and let sl~2~ denote the slot associated with
> *G*~2~. Note that all blocks between *G*~1~ and *G*~2~ are bad.
>
> Denote by *S* the continuous sequence of slots
>
> *S* = *{*sl~1~ + 1*,\...,*sl~2~*}.*
>
> If *G*~2~ = *C*\[sl~2~\] is honest, note that by the same argument as
> above *\|C*\[0 : sl~2~\]*\| ≥ \|C*\[0 : sl~1~\]*\|* + *g^0^*, where
> *g^0\ ^*is the number of good slots in *S*. However, in chain *C* we
> have *\|C*\[0 : sl~2~\]*\| ≤ \|C*\[0 : sl~1~\]*\|* + *b^0\ ^*+ 1,
> where *b^0\ ^*is the number of bad slots in the same sequence *S*,
> since by assumption *C*\[sl~1~ + 1 : sl~2~ *−* 1\] contains no
> honestly generated blocks. These two conditions can only be satisfied
> at the same time if *g^0^ ≤ b^0\ ^*+1. On the other hand, if *G*~2~
> was not honestly-generated, we can only conclude that *\|C*\[0 :
> sl~2~\]*\| ≥ \|C*\[0 : sl~1~\]*\|* + *g^0^ −* 1; specifically, note
> that *C* has been adopted by an alert player at slot sl, and so must
> have length at least that of the chain diffused during the last good
> slot of *S*. However, in this case we have *\|C*\[0 : sl~2~\]*\| ≤
> \|C*\[0 : sl~1~\]*\|*+*b^0^*,
>
> where *b^0\ ^*is the number of bad slots in *S*, since *C*\[sl~1~ +1 :
> sl~2~\] contains no honestly generated blocks. Again we find that
> *g^0^ ≤ b^0\ ^*+ 1.
>
> Observe that good slots are associated with 0s in the string *X^0\ ^*=
> *ρ~∆~*(*V ^0^*), where *V ^0\ ^*is the portion of *W* associated with
> the interval *S*; likewise, bad slots are associated with 1s in this
> sequence. Specifically,
>
> Pr\[*W* admits an *s*-*∃*CQ violation for (sl~1~*,*sl~2~)\] *≤*
> Pr\[#~0~(*^X0^*) *−* \#~1~(*^X0^*) *≤* 1\]*.*

For *s*
![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image54.png){width="1.7766666666666666in"
height="0.14666666666666667in"}+ 1 and hence, by (14),

> Pr\[*W* admits an *s*-*∃*CQ violation for (sl~1~*,*sl~2~)\] *≤*
> Pr\[#~0~(*^X0^*) *−* \#~1~(*^X0^*) *≤* 1\] *≤*
> Pr\[#![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image55.png){width="2.05in"
> height="0.15333333333333332in"}
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image56.png){width="1.69in"
> height="0.17666666666666667in"} *.*
>
> The union bound, applied over all pairs of slots, then yields
>
> Pr\[*W* admits an *s*-*∃*CQ
> violation\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image57.png){width="1.8166666666666667in"
> height="0.17666666666666667in"} *.*

*tu*

> **Corollary 4 (Chain Growth).** *Let W* = *W*~1~*,\...,W~r~ denote the
> characteristic string induced by the protocol Ouroboros-Praos in the
> single-epoch setting over a sequence of r slots. Let α,β ∈* \[0*,*1\]
> *denote lower bounds on the alert stake ratio and the participating
> stake ratio over the execution as per Definition 2, and assume that
> for some some ε ∈* (0*,*1) *the parameter α satisfies*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image41.png){width="1.4733333333333334in"
> height="0.16666666666666666in"}*.*

+-----------------+----------------+----+--------------------------+---+
| *Then for*      |                |    |                          |   |
+=================+================+====+==========================+===+
| *we have*       | > *s* =        | >  | > *τ* = *βf/*16          | \ |
|                 | > 48*∆/*(*βf*) |  * |                          | ( |
|                 |                | an |                          | 2 |
|                 |                | d* |                          | 1 |
|                 |                |    |                          | \ |
|                 |                |    |                          | ) |
+-----------------+----------------+----+--------------------------+---+

> Pr\[*W admits a* (*s,τ*)*-CG
> violation*\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image58.png){width="0.3233333333333333in"
> height="0.11666666666666667in"}(*τ,s*;*r,*)
> ,![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image59.png){width="7.666666666666666e-2in"
> height="0.29in"}*sr*^2^ exp *−*(*βf*)^2^*s/*256 *.*
>
> *Proof.* The corollary follows directly by combining Lemmas 10 and 11,
> using
> *s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image60.png){width="1.0233333333333334in"
> height="0.14333333333333334in"}), *s*~HCG~ =

2*s*~ECQ~, and *τ*~HCG~ = *βf/*8. *tu*

> **Corollary 5 (Chain Quality).** *Let W* = *W*~1~*,\...,W~r~ denote
> the characteristic string induced by the protocol Ouroboros-Praos in
> the single-epoch setting over a sequence of r slots. Let α,β ∈*
> \[0*,*1\] *denote lower bounds on the alert stake ratio and the
> participating stake ratio as per Definition 2, and assume that for
> some some ε ∈* (0*,*1) *the parameter α satisfies*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image61.png){width="1.4733333333333334in"
> height="0.17in"}*.*
>
> *Then for k* = 48*∆/*(*βf*) *and µ* = *βf/*16
>
> *we have*
>
> Pr\[*W admits a* (*µ,k*)*-CQ
> violation*\]![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image62.png){width="0.3333333333333333in"
> height="0.13in"}(*µ,k*;*r,*)
> ,![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image63.png){width="7.666666666666666e-2in"
> height="0.29in"}*kr*^2^ exp *−*(*βf*)^2^*k/*256 *.*
>
> *Proof.* The corollary follows directly by combining Lemmas 10 and 11,
> using
> *s*![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image64.png){width="1.0233333333333334in"
> height="0.14666666666666667in"}), *s*~HCQ~ =

2*s~∃~*~CQ~, and *τ*~HCQ~ = *βf/*8. *tu*

## E.6 Lifting to Multiple Epochs

> The above analysis gives bounds for common prefix, chain growth, and
> variants of chain quality (denoted ¯~CP~, ¯~CG~, ¯~CQ~, and ¯~*∃*CQ~,
> respectively) for a single-epoch run of the protocol with static stake
> distribution and perfect randomness. We now conclude our proof of
> Theorem 1 by showing conditions under which these blockchain
> properties hold throughout the whole lifetime of the system consisting
> of many epochs.
>
> **Theorem 7.** *Consider the execution of Ouroboros-Praos with
> adversary A and environment Z in the setting with static
> F*~N-MC~*-registration. Let f be the active-slot coefficient, let ∆ be
> the upper bound on the network delay. Let α,β ∈* \[0*,*1\] *denote a
> lower bound on the alert and participating stake ratios throughout the
> whole execution, respectively. Let R and L denote the epoch length and
> the total lifetime of the system (in slots), and let Q be the total
> number of queries issued to G*~RO~*. If for some ε ∈* (0*,*1) *we
> have*
>
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image3.png){width="1.5766666666666667in"
> height="0.17in"}*,*
>
> *then Ouroboros-Praos achieves the same guarantees for common prefix
> (resp. chain growth, chain quality, existential chain quality) as
> given in Corollary 3 (resp. Corollary 4, Corollary 5, Lemma 11) except
> with an additional error probability of*

*QL*
![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image65.png){width="0.37in"
height="0.14333333333333334in"} (*τ,R/*3;*R,*) + 2¯~CP~ (*τR/*3;*R,∆,*
![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image66.png){width="0.7366666666666667in"
height="0.14333333333333334in"}3;*R,*)) *,* (22)

+--------------------------------------------------------------------+---+
| *where τ* = *βf/*16*. If R ≥* 144*∆/βf then this term can be       |   |
| upper-bounded by*                                                  |   |
+====================================================================+===+
| (*βf*)2*R* 38*R* 4*τR*                                             | \ |
|                                                                    | ( |
| ~lift~ , *QL · R*^3^ *·* exp *−* + *·* exp *∆ − .*                 | 2 |
|                                                                    | 3 |
|                                                                    | \ |
|                                                                    | ) |
+--------------------------------------------------------------------+---+

768 ~4~ 54

> *Proof (sketch).* This part of the analysis proceeds similarly as in
> Section 5 of \[14\] and hence we only sketch it. When moving from the
> single-epoch setting to a setting with several epochs, two new aspects
> need to be considered:

-   **Stake distribution updates.** The stake distribution used for
    sampling slot leaders changes in every epoch (this is why we
    consider epochs in the first place). In Ouroboros-Praos (and
    Ouroboros-Genesis), the distribution used for sampling in epoch ep
    is set to be the stake distribution recorded on the blockchain up to
    the last block of the epoch ep *−* 2.

-   **Randomness updates.** Every epoch needs new public randomness to
    be used for sampling slot leaders from the above distribution. For
    epoch ep, this randomness is obtained by hashing together
    VRF-outputs put into blocks in epoch ep*−*1 by their creators. More
    precisely, the protocol hashes together these values from the blocks
    in the first 2*R/*3 slots of epoch ep *−* 1 (out of its *R* slots).

> To argue that the above process of updating stake distribution and
> public randomness does not noticeably deviate the execution from the
> single-epoch analysis, we rely on the single-epoch setting bounds
> proven above. In particular, we make the following three observations:

-   Chain growth and common prefix imply that during the first *R/*3
    slots of each epoch, each alert player's chain grows by at least
    *τR/*3 blocks (for *τ* as in (21)) and therefore after these slots,
    all alert players agree on the stake distribution at the end of the
    previous epoch except with probability

> ¯~CG~(*τ,R/*3;*R,*) + ¯~CP~(*τR/*3;*R,∆,*) *.*

-   Existential chain quality implies that during the second *R/*3 slots
    of each epoch, each alert player's chain contains at least one
    honest block except with probability

> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image67.png){width="0.4866666666666667in"
> height="0.14333333333333334in"}3;*R,*) *.*
>
> That implies that the randomness that will be derived for the next
> epoch will be influenced by at least one honest VRF-output determined
> *after* the stake distribution is fixed.

-   Chain growth and common prefix imply that during the last *R/*3
    slots of each epoch, each alert player's chain grows by at least
    *τR/*3 blocks and therefore after these slots, all alert players
    agree on the randomness for the next epoch except with probability

> ¯~CG~(*τ,R/*3;*R,*) + ¯~CP~(*τR/*3;*R,∆,*) *.*
>
> Hence, if we assumed perfect randomness in each epoch, all the above
> desired properties would be satisfied throughout the lifetime of the
> system *L* except with probability

*L ·* (2¯~CG~ (*τ,R/*3;*R,*) + 2¯~CP~ (*τR/*3;*R,∆,*
![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image68.png){width="0.7333333333333333in"
height="0.14666666666666667in"}3;*R,*))

> by union bound.
>
> However, the above properties are not sufficient to infer that the
> public randomness used for leader election in the next epoch will be
> perfect. Instead, the process of deriving it described above still
> allows a limited amount of grinding by the adversary, who can decide
> whether to include blocks (with VRF outputs) in slots where he is a
> slot leader. In \[14\], it is shown that this grinding effect can be
> crudely upper-bounded by limiting the number of queries to the random
> oracle that the adversary makes (of course, more fine-grained bounds
> are possible). The same argument applies here, and hence we need to
> introduce the quantity *Q* into our bound (22). Since we model the
> random oracle as a global functionality *G*~RO~, the quantity *Q* is
> an upper bound on the *total* number of queries to *G*~RO~ that were
> asked during the execution, including queries from the environment.
>
> Finally, the bound (23 is obtained by instantiating (22) with the
> concrete bounds of Corollaries 3 and 4, and Lemma 11 (where Lemma 11
> requires the assumption *R ≥* 36*∆/βf*, while 4 requires a stricter
> bound

*R ≥* 144*∆/βf*). *tu*

# F Large Deviation Bounds

> We apply a variety of large deviation bounds in our probabilistic
> arguments, which we record here for concreteness. See, e.g., \[25\]
> for proofs and further discussion.
>
> **Theorem 8 (Chernoff bound).** *Let X*~1~*,\...,X~T~ be independent
> random variables with* E\[*X~i~*\] = *p~i~ and X~i~ ∈* \[0*,*1\]*. Let
> X* = ^P*T*^~*i*=1~ *X~i~ and µ* = ^P^*~i~^T^*~=1~ *p~i\ ~*= E\[*X*\]*.
> Then, for all Λ ≥* 0*,*
>
> Pr\[*X*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image69.png){width="1.24in"
> height="0.21333333333333335in"}*^µ^* ; Pr\[*X*
> ![](vertopal_4357fa6bb0c647358fe90eb8badf9a20/media/image70.png){width="1.32in"
> height="0.21in"} *.*
>
> **Theorem 9 (Azuma's inequality (Azuma; Hoeffding). See \[25, 4.16\]
> for discussion).** *Let X*~0~*,\...,X~n~ be a sequence of real-valued
> random variables so that, for all t, \|X~t~*~+1~ *− X~t~\| ≤ c for
> some constant c. If* E\[*X~t~*~+1~ *\|X*~0~*,\...,X~t~*\] *≤ X~t~ for
> all t then for every Λ ≥* 0
>
> *Λ*2

Pr\[*X~n~ − X*~0~ *≥ Λ*\] *≤* exp *−* ~2~ *.*

2*nc Alternatively, if* E\[*X~t~*~+1~ *\|X*~0~*,\...,X~t~*\] *≥ X~t~ for
all t then for every Λ ≥* 0

> *Λ*2

Pr\[*X~n~ − X*~0~ *≤ −Λ*\] *≤* exp *−*2*nc*~2~ *.*

# G List of Symbols

> The communication model:

*∆* maximum message delay in slots

> Functionalities:

+------------+---------------------------------------------------------+
| > *G*clock | global clock                                            |
+============+=========================================================+
| > *G*RO    | global random oracle                                    |
+------------+---------------------------------------------------------+
| > *F*      | *∆*-delayed network for diffusing blockchains           |
| N-MCbc*,∆* |                                                         |
| >          | *∆*-delayed network for diffusing transactions          |
| > *F*~N    |                                                         |
| -MC~tx*,∆* |                                                         |
+------------+---------------------------------------------------------+
| > *F*INIT  | init functionality providing the genesis block          |
+------------+---------------------------------------------------------+
| > *F*VRF   | verifiable random function                              |
+------------+---------------------------------------------------------+
| > *F*KES   | key-evolving signature scheme                           |
+------------+---------------------------------------------------------+
| *G*ledger  | the ledger functionality                                |
+------------+---------------------------------------------------------+

> Functionality *G*~ledger~:

+---------------+------------------------------------------------------+
| > *τ~L~*      | current time                                         |
+===============+======================================================+
| > *\~τ*state  | sequence of time stamps of state blocks              |
+---------------+------------------------------------------------------+
| > *I\~~H~T*   | timed honest-input sequence                          |
+---------------+------------------------------------------------------+
| *S*initStake  | initial stakeholder set                              |
+---------------+------------------------------------------------------+

> Protocol Ouroboros-Genesis:

+------------+---------------------------------------------------------+
| *f*        | active slots coefficient                                |
+============+=========================================================+
| *φ*(*·*)   | slot-leader probability function (Eq. (1))              |
+------------+---------------------------------------------------------+
| *R*        | epoch length in slots                                   |
+------------+---------------------------------------------------------+
| S~ep~      | stake distribution used to sample slot leaders in epoch |
|            | ep                                                      |
+------------+---------------------------------------------------------+
| *α~p~*ep   | relative stake of party *U~p\ ~*in S~ep~                |
+------------+---------------------------------------------------------+
| *η*ep      | randomness used to sample slot leaders in epoch ep      |
|            |                                                         |
| Analysis:  |                                                         |
+------------+---------------------------------------------------------+
| *α*        | alert stake ratio (Def. 2)                              |
+------------+---------------------------------------------------------+
| *β*        | participating stake ratio (Def. 2)                      |
+------------+---------------------------------------------------------+
| *L*        | total length of the execution (in slots)                |
+------------+---------------------------------------------------------+
| *Q*        | total number of queries to the random oracle            |
+------------+---------------------------------------------------------+

[^1]: 0

    In Feb. 2019 each single Bitcoin block requires more than 2
    operations to be performed, cf.
    [https://en.bitcoin.](https://en.bitcoin.it/wiki/Difficulty)

    > [it/wiki/Difficulty.](https://en.bitcoin.it/wiki/Difficulty)

[^2]: The concept of merged mining is an illustration of this fact from
    a positive angle; cf. [https://en.bitcoin.it/
    wiki/Merged_mining_specification.](https://en.bitcoin.it/wiki/Merged_mining_specification)

[^3]: In fact, as a response to the criticism about the bottlenecks of
    PoW, the second most adopted decentralized blockchain, Ethereum
    \[5\], has announced a plan to gradually transition from a PoW-based
    to a PoS-based protocol.

[^4]: Informally, the main difference between ideal functionalities and
    global setups is that the former are bound to a calling protocol and
    only expose their functionality to this protocol, whereas the latter
    can be accessed by any protocol.

[^5]: For readers familiar with the programmability issues of random
    oracles, e.g. \[16, 11\], the UC-functionality abstraction
    corresponds to a programmable RO that is only accessible by the
    protocol, whereas the random-oracle global setup is both
    non-programmable and publicly available.

[^6]: The latter is done by use of a technical modeling trick from
    \[12\] (cf. Section A.1.)

[^7]: It is natural to capture network functionalities as local UC
    functionalities, since networks are often ad-hoc tailored to a
    specific task.

[^8]: The timed honest-input sequence looks like *I^\~^~H~^T\ ^*=
    ((*x*~1~*,*pid~1~*,τ*~1~)*,\...,*(*x~m~,*pid*~m~,τ~m~*)) where
    ((*x*~1~*,*pid~1~)*,\...,*(*x~m~,*pid*~m~*)) are the honest inputs
    corresponding to an execution (up to a certain point), and for each
    *i ∈* \[*n*\], *τ~i\ ~*is the time of the global clock when input
    *x~i\ ~*was handed to pid*~i~*.

[^9]: Recall that the clock waits (also) for the ledger to check-in to
    advance its time/round index.

[^10]: If they do, only empty state blocks would emerge

[^11]: In reality, these are the blocks contributed by alert parties.

[^12]: Recall that in \[3\], a party is never stalled. If it is not
    offline, and hence contributes to the overall hashing power, it
    either belongs to the synchronized or to the de-synchronized set
    (and de-synchronized parties increase adversarial power).

[^13]: Unlike \[14\], where R is fixed, in this work we treat *R* as a
    protocol parameter, which will be bounded appropriately by our
    security statements.

[^14]: For brevity, wherever clear from the context we omit the party ID
    from the local chain notation, i.e., write *C*~loc~ instead of
    *C*~loc~*^U^* .

[^15]: Recall that we assume for simplicity that the protocol starts
    when *τ* = 0 and that *R* is a protocol parameter defining the
    duration of an epoch (in rounds).

[^16]: Recall that our ledger functionality ensures that a parties input
    is considered---not ignored---only if this party is registered with
    all its global inputs (see Appendix A.7 for details.)

[^17]: We give concrete bounds on the time it needs to become
    synchronized in Section 4.

[^18]: The exact encoding is not of primary relevance as long as it
    gives rise to the aforementioned mapping to stake distributions
    (which therefore also binds public keys to identities). A possible,
    straightforward instantiation of an encoding is explained in \[14\].
    19 Note that signing is a local operation and reflected in this work
    by requiring *F*~KES~ to be responsive as explained in Section A.6.

[^19]: More technically speaking, whether transactions are signed or not
    is completely orthogonal to the security proof in this paper. The
    reason is that the main honest-stake-majority condition refers to
    the stake-distribution and hence is a property of the basic content
    of the blockchain (and the corruption state of the miners) and
    therefore under the control of the environment providing the
    contents via inputs to the protocol.

[^20]: Observe that a stalled party that returns to the alert status
    will fetch all messages sent to it while it was stalled.

[^21]: Note that making the set of parties dynamic means that the
    adversary needs to be informed about which parties are currently in
    the computation so that he can chose how many (and which) parties to
    corrupt.

[^22]: The timed honest-input sequence looks like *I^\~^~H~^T\ ^*=
    ((*x*~1~*,id*~1~*,τ*~1~)*,\...,*(*x~m~,id~m~,τ~m~*)) where
    ((*x*~1~*,id*~1~)*,\...,*(*x~m~,id~m~*)) are the honest inputs
    corresponding to an execution (up to a certain point), and for each
    *i ∈* \[*n*\], *τ~i\ ~*is the time of the global clock when input
    *x~i\ ~*was handed to ITI (or party) *id~i\ ~*in the session sid
    (recall that in UC this means that *id* = (pid*,*sid) for some
    bitstring pid).

[^23]: Note that in the ideal world, it is the ledger functionality
    which is registered with *G*~clock~ and enforces the same principal
    time-evolving behavior as in the real world.
