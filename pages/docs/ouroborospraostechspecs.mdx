---
title: "[]{#Ouroboros Praos: An adaptively-secure, s .anchor}Ouroboros
  Praos: An adaptively-secure, semi-synchronous proof-of-stake
  blockchain"
---

Bernardo David*^\*^*, Peter Gaˇzi*^\*\*^*, Aggelos Kiayias*^\*^ ^\*^
^\*^*, and Alexander Russell*^†^*

> November 14, 2017
>
> **Abstract.** We present "Ouroboros Praos", a proof-of-stake
> blockchain protocol that, for the first time, provides security
> against *fully-adaptive corruption* in the *semi-synchronous setting*
> : Specifically, the adversary can corrupt any participant of a
> dynamically evolving population of stakeholders at any moment as long
> the stakeholder distribution maintains an honest majority of stake;
> furthermore, the protocol tolerates an adversarially-controlled
> message delivery delay unknown to protocol participants.
>
> To achieve these guarantees we formalize and realize in the universal
> composition setting a suitable form of forward secure digital
> signatures and a new type of verifiable random function that maintains
> unpredictability under malicious key generation. Our security proof
> develops a general combinatorial framework for the analysis of
> semi-synchronous blockchains that may be of independent interest. We
> prove our protocol secure under standard cryptographic assumptions in
> the random oracle model.

# Introduction

The design of *proof-of-stake* blockchain protocols was identified early
on as an important objective in blockchain design; a proof-of-stake
blockchain substitutes the costly proof-of-work component in Nakamoto's
blockchain protocol \[[Nak08](#_bookmark87)\] while still providing
similar guarantees in terms of transaction processing in the presence of
a dishonest minority of users, where this "minority" is to be understood
here in the context of stake rather than computational power.

The basic stability and security properties of blockchain protocols were
first rigorously formulated in \[[GKL15](#_bookmark76)\] and further
studied in \[[KP15](#_bookmark82),[PSS17](#_bookmark89)\]; these include
common prefix, chain quality and chain growth and refer to resilient
qualities of the underlying data structure of the blockchain in the
presence of an adversary that attempts to subvert them.

Proof-of-stake protocols typically possess the following basic
characteristics. Based on her local view, a party is capable of
deciding, in a publicly verifiable way, whether she is permitted to
produce the next block. Assuming the block is valid, other parties
update their local views by adopting the block, and proceed in this way
continuously. At any moment, the probability of being permitted to issue
a block is proportional to the relative stake a player has in the
system, as reported by the blockchain itself.

A particularly challenging design aspect is that the above probabilistic
mechanism should be designed so that the adversary cannot bias it to its
advantage. As the stake shifts, together with the evolving population of
stakeholders, so does the honest majority assumption, and hence the
function that appoints stakeholders should continuously take the ledger
status into account. Preventing the biasing of the election mechanism in
a context of a blockchain protocol is a delicate task that so far has
eluded a practical solution that is secure against all attacks.

**Our Results.** We present "Ouroboros Praos", a provably secure
proof-of-stake protocol that is the first to be secure against adaptive
attackers and scalable in a truly practical sense. Our protocol is based
on a previous proof-of-stake protocol, Ouroboros
\[[KRDO17](#_bookmark83)\], as its analysis builds on some of the core
combinatorial arguments that were developed to analyze that scheme.
Nevertheless,

> *^\*^* Tokyo Institute of Technology and IOHK,
> [bdavid@c.titech.ac.jp.](mailto:bdavid@c.titech.ac.jp)
>
> *^\*\*^* IOHK, [peter.gazi@iohk.io.](mailto:peter.gazi@iohk.io) Work
> partly done while the author was a postdoc at IST Austria, supported
> by the ERC consolidator grant 682815-TOCNeT.
>
> *^\*^ ^\*^ ^\*^* University of Edinburgh and IOHK.
> [akiayias@inf.ed.ac.uk.](mailto:akiayias@inf.ed.ac.uk) Work partly
> supported by H2020 Project #653497, PANORAMIX.
>
> *^†^* University of Connecticut.
> [acr@cse.uconn.edu.](mailto:acr@cse.uconn.edu)

the protocol construction has a number of novel elements that require a
significant recasting and generalization of the previous combinatorial
analysis. In more detail, our results are as follows.

In Ouroboros Praos, deciding whether a certain participant of the
protocol is eligible to issue a block is decided via a private test that
is executed locally using a special verifiable random function (VRF) on
the current time-stamp and a nonce that is determined for a period of
time known as an "epoch". A special feature of this VRF primitive, novel
to our approach, is that the VRF must have strong security
characteristics even in the setting of malicious key generation:
specifically, if provided with an input that has high entropy, the
output of the VRF is unpredictable even when an adversary has subverted
the key generation procedure. We call such VRF functions "VRF with
unpredictability under malicious key generation" and we present a strong
embodiment of this notion with a novel Universal Composable (UC)
formulation. We also present a very efficient realization of this
primitive under the Computational Diffie Hellman (CDH) assumption in the
random oracle model. Beyond this VRF notion, we also formalize in a UC
fashion key evolving signatures that provide the forward security that
is necessary for handling the adaptive corruption setting.

In more detail, we analyze our protocol in the *partial* or
*semi-synchronous* model
\[[DLS88](#_bookmark73),[PSS17](#_bookmark89)\]. In this setting, we
still divide the protocol execution in time units which, as in
\[[KRDO17](#_bookmark83)\], are called slots, but there is a maximum
delay of *∆* slots that is applied to message delivery and it is unknown
to the protocol participants.[^1^](#_bookmark0) In order to cope with
the *∆*-semisynchronous setting we introduce the concept of "empty
slots" which occur with sufficient frequency to enable short periods of
silence that facilitate synchronization. This feature of the protocol
gives also its moniker, "Praos", meaning "mellow", or "gentle". Ensuring
that the adversary cannot exploit the stakeholder keys that it possesses
to confuse or out-maneuver the honest parties, we develop a
combinatorial analysis to show that the simple rule of following the
longest chain still enables the honest parties to converge to a unique
view with high probability. To accomplish this we revisit and expand the
forkable strings and divergence analysis of \[[KRDO17](#_bookmark83)\].
We remark that significant alterations are indeed necessary: As we
demonstrate in Appendix
[D,](#insecurity-of-the-original-ouroboros-against-adversarial-message-delays)
the protocol of \[[KRDO17](#_bookmark83)\] and its analysis are
critically tailored to synchronous operation and is susceptible to a
desynchronization attack that can completely violate the common prefix
property. Our new combinatorial analysis introduces a new concept of
characteristic strings and "forks" that reflects silent periods in
protocol execution and network delays. To bound the density of forkable
strings in this *∆*-semisynchronous setting we establish a syntactic
reduction from *∆*-semisynchronous characteristic strings to synchronous
strings of \[[KRDO17](#_bookmark83)\] that preserves the structure of
the forks they support. This is followed by a probabilistic analysis
that controls the distortion caused by the reduction and concludes that

*∆*-semisynchronous forkable strings are rare. Finally, we control the
effective power of adaptive adversaries in this setting with a
stochastic dominance argument that permits us to carry out the analysis
of the underlying blockchain guarantees (e.g., common prefix) with a
single distribution that provably dominates all distributions on
characteristic strings generated by adaptive adversaries. We remark that
these arguments yield graceful degradation of the analysis as a function
of network delays (*∆*), in the sense that the effective stake of the
adversary is amplified by a function of *∆*.

The above combinatorial analysis is nevertheless only sufficient to
provide a proof of the static stake case, i.e., the setting where the
stake distribution relevant to the honest majority assumption remains
fixed at the onset of the computation and prior to the selection of the
random genesis data that are incorporated in the genesis block. For a
true proof-of-stake system, we must permit the set of stakeholders to
evolve over time and appropriately adapt our honest stakeholder majority
assumption. Achieving this requires a bootstrapping argument that allows
the protocol to continue unboundedly by revising its stakeholder
distribution as it evolves. We bootstrap our protocol in two conceptual
steps. First we show how bootstrapping is possible if a randomness
beacon is available to all participants. The beacon at regular intervals
emits a new random value and the participants can reseed the election
process so the stakeholder distribution used for sampling could be
brought closer to the one that is current. A key observation here is
that our protocol is resilient even if the randomness beacon is weakened
in the following two ways: (i) it leaks its value to the adversary ahead
of time by a bounded number of time units, (ii) it allows the adversary
to reset its value if it

> ^1^ []{#_bookmark0 .anchor}It is worth pointing out that the notion of
> slots we use in this work can be substantially shorter in terms of
> real time elapsed compared to the slots of \[[KRDO17](#_bookmark83)\],
> where each slot represented a full round of interaction between all
> participants.

wishes within a bounded time window. We call the resulting primitive a
"leaky resettable beacon" and show that our bootstrapping argument still
holds in this stronger adversarial setting.

In the final refinement of our protocol, we show how it is possible to
implement the leaky resettable beacon via a simple algorithm that
concatenates the VRF outputs that were contributed by the participants
from the blockchain and subjects them to a hash function that is modeled
as a random oracle. This implementation explains the reasons behind the
beacon relaxation we introduced: leakiness stems from the fact that the
adversary can complete the blockchain segment that determines the beacon
value before revealing it to the honest participants, while
resettability stems from the fact that the adversary can try a bounded
number of different blockchain extensions that will stabilize the final
beacon value to a different preferred value.

Putting all the above together, we show how our protocol provides a
"robust transaction ledger" in the sense that an immutable record of
transactions is built that also guarantees that new transactions will be
always included. Our security definition is in the *∆*-semisynchronous
setting with full adaptive corruptions. As mentioned above, security
degrades gracefully as *∆* increases, and this parameter is unknown to
the protocol participants.

Note that implementing the beacon via hashing VRF values will make
feasible a type of "grinding attack" where the adversary can trade
hashing power for a slight bias of the protocol execution to its
advantage. We show how this bias can be controlled by suitably
increasing the relevant parameters depending on the hashing power that
is available to the adversary.

**Comparison to related work.** The idea of proof-of-stake protocols has
been discussed exten- sively in the bitcoin forum.[^2^](#_bookmark1) The
manner that a stakeholder determines eligibility to issue a block is
always publicly verifiable and the proof of eligibility is either
computed publicly (via a calculation that is verifiable by repeating it)
or by using a cryptographic mechanism that in- volves a secret-key
computation and a public-key verification. The first example of the
former approach appeared in PPCoin \[[KN12](#_bookmark81)\], and was
followed by others including Ouroboros and Snow White
\[[BGM14](#_bookmark66),[KRDO17](#_bookmark83),[DPS16](#_bookmark75)\];
while the first example of the latter approach (that we also employ in
our work) appeared in NXT (cf. Section 2.4.1 of
\[[Com14](#_bookmark72)\]) and was then also used elsewhere, most
notably in Algorand \[[Mic16](#_bookmark85)\]. The virtue of the latter
approach is exactly in its potential to control adaptive corruptions:
due to the fact that the adversary cannot predict the eligibility of a
stakeholder to issue a block prior to corrupting it, she cannot gain an
advantage by directing its corruption quota to specific stakeholders.
Nevertheless, none of these previous works isolated explicitly the
properties of the primitives that are required to provide a full proof
of security in the setting of adaptive corruptions. Injecting high
quality randomness in the PoS blockchain was proposed by Bentov et al.
\[[BLMR14](#_bookmark68),[BGM16](#_bookmark67)\], though their proposal
does not have a full formal analysis. The Ouroboros proof-of-stake
protocol \[[KRDO17](#_bookmark83)\] is provably secure in a corruption
model that excludes fully adaptive attacks by imposing a corruption
delay on the corruption requests of the adversary. The Snow White
proof-of-stake \[[DPS16](#_bookmark75)\] is the first to prove security
in the

*∆*-semi-synchronous model but---as in the case of Ouroboros---adopts a
weak adaptive corruption model.

A recent work close to ours is Algorand \[[Mic16](#_bookmark85)\] that
also provides a proof-of-stake ledger that is adaptively secure. It
follows an entirely different construction approach that runs a
Byzantine agreement protocol for every block and achieves
adaptive-corruption security via a novel, appealing concept of
player-replaceability. However, Algorand is only secure against a 1*/*3
adversary bound; and while the protocol itself is very efficient, it
yields an inherently slower block production rate compared to an
"eventual consensus" protocol (like Bitcoin, Snow White, and Ouroboros).
In principle, proof-of-stake blockchain protocols can advance at the
theoretical maximum speed (of one block per communication round), while
protocols relying on Byzantine agreement, like Algorand, would require a
larger number of rounds to settle each block.

Sleepy consensus \[[PS16](#_bookmark88)\] puts forth a technique for
handling adaptive corruptions in a model that also encompasses fail-stop
and recover corruptions; however, the protocol can be applied directly
only in a static stake (i.e., permissioned) setting. We note that in
fact our protocol can be also proven secure in such mixed corruption
setting, where both fail-stop and recover as well as Byzantine
corruptions are allowed (with the former occurring at an arbitrarily
high rate); nevertheless this is out of scope for the present exposition
and we omit further details.

> ^2^ []{#_bookmark1 .anchor}Refer e.g., to the posts by QuantumMechanic
> and others from 2011
> [https://bitcointalk.org/index.](https://bitcointalk.org/index.php?topic=27787.0)
> [php?topic=27787.0](https://bitcointalk.org/index.php?topic=27787.0)
> (Last Accessed 19/09/2017).

Note that the possibility of adversarial grinding in Ouroboros Praos is
also present in previous work that derives randomness by hashing
\[[Mic16](#_bookmark85),[DPS16](#_bookmark75)\], as opposed to a
dedicated coin-tossing protocol as in \[[KRDO17](#_bookmark83)\].
Following the examples of
\[[Mic16](#_bookmark85),[DPS16](#_bookmark75)\], we show that security
can be guaranteed despite any adversarial bias resulting from grinding.
In fact, we show how to use the *q*-bounded model of
\[[GKL15](#_bookmark76)\] to derive a bound that shows how to increase
the relevant security parameters given the hashing power that is
available to the adversary.

Finally, in the present exposition we also put aside incentives;
nevertheless, it is straightforward to adapt the mechanism of input
endorsers from the protocol of \[[KRDO17](#_bookmark83)\] to our setting
and its approximate Nash equilibrium analysis can be ported directly.

# Preliminaries

We say a function *negl*(*x*) is negligible if for every *c \>* 0, there
exists an *n \>* 0 such that *negl*(*x*) *\<* 1*/x^c^* for all *x ≥ n*.
The length of a string *w* is denoted by *\|w\|*; *ε* denotes the empty
string. We let *v Iw* denote concatenation of strings.

## Transaction Ledger Properties

We adopt the same definitions for transaction ledger properties as
\[[KRDO17](#_bookmark83)\]. A protocol *Π* implements a robust
transaction ledger provided that the ledger that *Π* maintains is
divided into "blocks" (assigned to time slots) that determine the order
with which transactions are incorporated in the ledger. It should also
satisfy the following two properties.

> **Persistence.** Once a node of the system proclaims a certain
> transaction *tx* as *stable*, the remaining nodes, if queried, will
> either report *tx* in the same position in the ledger or will not
> report as stable any transaction in conflict to *tx*. Here the notion
> of stability is a predicate that is parameterized by a security
> parameter *k*; specifically, a transaction is declared *stable* if and
> only if it is in a block that is more than *k* blocks deep in the
> ledger.
>
> **Liveness.** If all honest nodes in the system attempt to include a
> certain transaction then, after the passing of time corresponding to
> *u* slots (called the transaction confirmation time), all nodes, if
> queried and responding honestly, will report the transaction as
> stable.

In \[[KP15](#_bookmark82),[PSS17](#_bookmark89)\] it was shown that
persistence and liveness can be derived from the following three
elementary properties provided that protocol *Π* derives the ledger from
a data structure in the form of a blockchain.

> **Common Prefix (CP); with parameters** *k ∈* N**.** The chains
> *C*~1~*, C*~2~ possessed by two honest parties at the onset of the
> slots *sl*~1~ *\< sl*~2~ are such that *C^rk^ ::: C*~2~, where *C^rk^*
> denotes the chain
>
> obtained by removing the last *k* blocks from *C*~1~, and *:::*
> denotes the prefix relation.
>
> **Chain Quality (CQ); with parameters** *µ* (0*,* 1\] **and** *k*
> N**.** Consider any portion of length at least *k* of the chain
> possessed by an honest party at the onset of a round; the ratio of
> blocks
>
> originating from the adversary is at most 1 *− µ*. We call *µ* the
> chain quality coefficient.
>
> **Chain Growth (CG); with parameters** *τ ∈* (0*,* 1\]*, s ∈* N**.**
> Consider the chains *C*~1~*, C*~2~ possessed by two honest parties at
> the onset of two slots *sl*~1~*, sl*~2~ with *sl*~2~ at least *s*
> slots ahead of *sl*~1~. Then it holds that len(*C*~2~) *−* len(*C*~1~)
> *≥ τ · s*. We call *τ* the speed coefficient.

## The Semi-Synchronous Model

On a high level, we consider the security model of
\[[KRDO17](#_bookmark83)\] with simple modifications to account for
adversarially-controlled message delays and immediate adaptive
corruption. Namely, we allow the adversary to selectively delay any
messages sent by honest parties for up to *∆* N slots; and corrupt
parties without delay.

*Time and slots.* We consider a setting where time is divided into
discrete units called *slots*. A ledger, described in more detail above,
associates with each time slot (at most) one ledger *block*. Players are
equipped with (roughly synchronized) clocks that indicate the current
slot. This will permit them to carry out a distributed protocol
intending to collectively assign a block to this current slot. In
general, each slot *sl~r~* is indexed by an integer *r* 1*,* 2*, . . .*
, and we assume that the real time window that corresponds to each slot
has the following two properties: (1) The current slot is determined by
a publicly-known and monotonically increasing function of current time.
(2) Each player has access to the current time. Any discrepancies
between parties' local time are insignificant in comparison with the
length of time represented by a slot.

*Security Model.* We adopt the model introduced by
\[[GKL15](#_bookmark76)\] for analysing security of blockchain protocols
enhanced with an ideal functionality . We note that multiple different
"functionalities" can be encompassed by . In our model we employ the
"Delayed Diffuse" functionality, which allows for
adversarially-controlled delayed delivery of messages diffused among
stakeholders.

*The Diffuse Functionality.* This functionality is parameterized by *∆
∈* N and denoted as DDiffuse*~∆~*. It keeps rounds, executing one round
per slot. DDiffuse*~∆~* interacts with the environment *Z*, stake-
holders *U*~1~*, . . . , U~n~* and an adversary *A*, working as follows
for each round:

1.  DDiffuse*~∆~* maintains an incoming string for each party *U~i~*
    > that participates. A party, if activated, is allowed at any moment
    > to fetch the contents of its incoming string, hence one may think
    > of this as a mailbox. Furthermore, parties can give an instruction
    > to the functionality to diffuse a message. Activated parties are
    > allowed to diffuse once in a round.

2.  When the adversary is activated, it is allowed to: (a) Read all
    > inboxes and all diffuse requests

> and deliver messages to the inboxes in any order it prefers; (b) For
> any message *m* obtained via a diffuse request and any party *U~i~*,
> *A* may move *m* into a special string delayed*i* instead of the inbox
> of *U~i~*. *A* can decide this individually for each message and each
> party; (c) For any party *U~i~*, can move any message from the string
> delayed*i* to the inbox of *U~i~*.

3.  At the end of each round, the functionality also ensures that every
    > message that was either (a)

> diffused in this round and not put to the string delayed*i* or (b)
> removed from the string delayed*i* in this round is delivered to the
> inbox of party *U~i~*. If any message currently present in delayed*i*
> was originally diffused at least *∆* slots ago, then the functionality
> removes it from delayed*i* and appends it to the inbox of party
> *U~i~*.

4.  Upon receiving (Create*, U, C*) from the environment, the
    > functionality spawns a new stakeholder with chain *C* as its
    > initial local chain (as it was the case in
    > [\[KRDO17\]).](#_bookmark83)

*Modelling Protocol Execution and Adaptive Corruptions.* Given the above
we will assume that the execution of the protocol is with respect to a
functionality that incorporates DDiffuse as well as possibly additional
functionalities to be explained in the following sections. The
environment issues transactions on behalf of any stakeholder *U~i~* by
requesting a signature on the transaction as described in Protocol
*π*~SPoS~ of Figure [4](#_bookmark16) and handing the transaction to
stakeholders to put them

into blocks. Beyond any restrictions imposed by *F*, the adversary can
only corrupt a stakeholder *U~i~* if it is given permission by the
environment *Z* running the protocol execution. The permission is in the
form of a message (Corrupt*, U~i~*) which is provided to the adversary
by the environment.

Upon receiving permission from the environment, the adversary
immediately corrupts *U~i~* without

any delay, differently from
\[[KRDO17](#_bookmark83),[DPS16](#_bookmark75)\], where corruptions only
take place after a given delay. Note that a corrupted stakeholder *U~i~*
will relinquish its entire state to *A*; from this point on, the
adversary will be activated in place of the stakeholder *U~i~*. The
adversary is able to control transactions and blocks generated by
corrupted parties by interacting with *F*~DSIG~,*F*~KES~ and *F*~VRF~,
as described in Protocol *π*~SPoS~ of Section
[3.](#the-static-stake-protocol) In summary, regarding activations we
have the following:

\(a\) At each slot *sl~j~*, the environment *Z* activates all honest
stakeholders.[^3^](#_bookmark3) (b) The adversary is

activated at least as the last entity in each *sl~j~* (as well as during
all adversarial party activations

and invocations from the ideal functionalities as prescribed); (c) If a
stakeholder does not fetch in a certain slot the messages written to its
incoming string from the diffuse functionality they are flushed.

> ^3^ []{#_bookmark3 .anchor}We assume this to simplify our formal
> treatment, a variant of our protocol can actually accomodate "lazy
> honesty" as introduced in \[[Mic16](#_bookmark85)\]. In this variant,
> honest stakeholders only come online at the beginning of each epoch
> and at a few infrequent, predictable moments, see Appendix
> [H.](#a-lazy-variant-of-πdpos)

*Restrictions imposed on the environment.* It is easy to see that the
model above confers such sweeping power on the adversary that one cannot
establish any significant guarantees on protocols of interest. It is
thus important to restrict the environment suitably (taking into account
the details of the protocol) so that we may be able to argue security.
We require that in every slot, the adversary does not control more than
50% of the stake in the view of any honest stakeholder. If this

> 1

is violated, an event Bad 2 becomes true for the given execution. When
the environment spawns a

new stakeholder by sending message (Create*, U,* ) to the Key and
Transaction functionality, the initial local chain can be the chain of
any honest stakeholder even in the case of "lazy honest" stakeholders as
described in Appendix [H,](#a-lazy-variant-of-πdpos) without requiring
this stakeholder to have been online in the past slot as in
\[[KRDO17](#_bookmark83)\]. Finally, we note that in all our proofs,
whenever we say that a

1

property *Q* holds with high probability over all executions, we will in
fact argue that *Q* Bad 2

holds with high probability over all executions. This captures the fact
that we exclude environments

1

and adversaries that trigger Bad 2 with non-negligible probability.

*Random Oracle.* We also assume the availability of a random oracle. As
usually, this is a function H: *{*0*,* 1*}∗ → {*0*,* 1*}w* available to
all parties that answers every fresh query with an independent,
uniformly random string from *{*0*,* 1*}w* , while any repeated queries
are answered consistently.

*Erasures.* We assume that honest users can do secure erasures, which is
argued to be a reasonable assumption in protocols with security against
adaptive adversaries, see e.g., [\[Lin09\].](#_bookmark84)

# The Static Stake Protocol

We first consider the static stake case, where the stake distribution is
fixed throughout protocol execution. The general structure of the
protocol in the semi-synchronous model is similar to that of
(synchronous) Ouroboros \[[KRDO17](#_bookmark83)\] but introduces
several fundamental modifications to the leader selection process: not
all slots will be attributed a slot leader, some slots might have
multiple slot leaders, and slot leaders' identities remain unknown until
they act. The first modification is used to deal with delays in the
semi-synchronous network as the *empty slots*---where no block is
generated---assist the honest parties to synchronize. The last
modification is used to deal with adaptive corruptions, as it prevents
the adversary from learning the slot leaders' identity ahead of time and
using this knowledge to strategically corrupt coalitions of parties with
large (future) influence. Moreover, instead of using concrete
instantiations of the necessary building blocks, we describe the
protocol with respect to *ideal functionalities*, which we later realize
with concrete constructions. This difference allows us to reason about
security in the ideal model through a combinatorial argument without
having to deal with the probability that the cryptographic building
blocks fail. Before describing the specifics of the new leader selection
process and the new protocol, we first formally define the static stake
scenario and introduce basic definitions as stated in
\[[KRDO17](#_bookmark83)\] following the notation of
[\[GKL15\].](#_bookmark76)

In the static stake case, we assume that a fixed collection of *n*
stakeholders *U*~1~*, . . . , U~n~* interact throughout the protocol.
Stakeholder *U~i~* is attributed stake *s~i~* at the beginning of the
protocol.

> **Definition 1 (Genesis Block).** *The* genesis block *B*~0~ *contains
> the list of stakeholders identified by a label U~i~, their respective
> public keys and respective stakes*
>
> S~0~ = ((*U*~1~*, v*^vrf^ *, v*^kes^*, v*^dsig^*, s*~1~)*, . . . ,*
> (*U~n~, v*^vrf^ *, v*^kes^*, v*^dsig^*, s~n~*)) *,*
>
> *and a nonce η.*
>
> We note that the nonce *η* will be used to seed the slot leader
> election process and that

*v*^vrf^ *, v*^kes^*, v*^dsig^ will be determined by []{#_bookmark5
.anchor}*F*~VRF~, *F*~KES~ and *F*~DSIG~, respectively.

> **Definition 2 (State, Block Proof, Block, Blockchain, Epoch).** *A*
> state *is a string st ∈*
>
> *{*0*,* 1*}λ. A* block proof *is a value (or set of values) B~π~
> containing information that allows stakeholders to verify if a block
> is valid. A* block *B* = (*sl~j~, st, d, B~πj~, σ~j~*) *generated at a
> slot sl~j~ ∈ {sl*~1~*, . . . , sl~R~} contains the current state st ∈
> {*0*,* 1*}λ, data d ∈ {*0*,* 1*}∗, the slot number sl~j~, a block
> proof B~πj~*
>
> *and σ~j~, a signature on* (*st, d, sl~j~, B~πj~*) *under the signing
> key for the time period of slot sl~j~ of the stakeholder U~i~
> generating the block.*
>
> *A* blockchain *(or simply* chain*) relative to the genesis block
> B*~0~ *is a sequence of blocks B*~1~*, . . . , B~n~ associated with a
> strictly increasing sequence of slots for which the state st~i~ of
> B~i~ is equal to H*(*B~i−~*~1~)*, where H is a prescribed
> collision-resistant hash function. The* length *of a chain* len(*C*) =
> *n is its number of blocks. The block B~n~ is the* head *of the chain,
> denoted* head(*C*)*. We treat the empty string ε as a legal chain and
> by convention set* head(*ε*) = *ε. Let C be a chain of length n and k
> be any non-negative integer. We denote by Crk the chain resulting from
> removal of the k rightmost blocks of C. If k ≥* len(*C*) *we define
> Crk* = *ε. We let C*~1~ *::: C*~2~ *indicate that the chain C*~1~ *is
> a prefix of the chain C*~2~*.*
>
> *An* epoch *is a set of R adjacent slots S* = *sl*~1~*, . . . , sl~R~
> . (The value R is a parameter of the protocol we analyze in this
> section.)*

We consider as valid blocks that are generated by a stakeholder in the
slot leader set of the slot to which the block is attributed. Later in
Section [3.3](#oblivious-leader-selection-and-finit) we discuss slot
leader sets and how they are selected.

> **Definition 3 (Absolute and Relative Stake).** *Let U~P~ , U~A~ and
> U~H~ denote the sets of all stakeholders, the set of stakeholders
> controlled by an adversary A, and the remaining (honest)*
>
> *stakeholders, respectively. For any party (resp. set of parties) X we
> denote by s*^+^ *(resp. s^−^ ) the*

*X*

> *maximum (resp. minimum)* absolute stake *controlled by X in the view
> of all honest stakeholders at a given slot, and by α*^+^ .6. *s*^+^
> */s~P~ and α^−^* .6. *s^−^ /s~P~ its* relative stake *taken as maximum
> and*
>
> *minimum respectively across of the view of all honest stakeholders.
> For simplicity, we use s*^s^ *, α*^s^

*X X*

\+ *−*

> *instead of s~U~ , α~U~ for all X ∈ {P, A, H},* s *∈ {*+*, −}. We also
> call α~A~* .6. *α and α~H~* .6. *α the*
>
> adversarial stake ratio *and* honest stake ratio*, respectively.*

## Forward Secure Signatures and *F*~KES~

In regular digital signature schemes, an adversary who compromises the
signing key of a user can generate signatures for any messages it
wishes, including messages that were (or should have been) generated in
the past. Forward secure signature schemes \[[BM99](#_bookmark69)\]
prevent such an adversary from generating signatures for messages that
were issued in the past, or rather allows honest users to verify that a
given signature was generated at a certain point in time. Basically,
such security guarantees are achieved by "evolving" the signing key
after each signature is generated and erasing the previous key in such a
way that the actual signing key used for signing a message in the past
cannot be recovered but a fresh signing key can still be linked to the
previous one. This notion is formalized through *key evolving signature
schemes*, which allow signing keys to be evolved into fresh keys for a
number of time periods. We remark that efficient constructions of key
evolving signature schemes with forward security exist
\[[IR01](#_bookmark78)\] but no previous work has fully specified them
in the UC setting. Previous (game-based) definitions are presented in
Appendix [A.3.](#forward-secure-signatures-schemes)

We present a UC definition of the type of key-evolving signatures that
we will take advantage of in our constructions. ~KES~ allows us to
achieve forward security with erasures (*i.e.*, assuming that parties
securely delete old signing keys as the protocol proceeds). This
functionality embodies ideal key evolving signature schemes allowing an
adversary that corrupts the signer to forge signatures only under the
current and future signing keys, but not under a previous signing key
that has been updated. Our starting point for ~KES~ is the standard
digital signature functionality defined in \[[Can04](#_bookmark70)\]
with the difference that packs together with the signing operation a
key-evolving operation. During verification, ~KES~ lets the adversary
set the response to a verification query (taking as input a given time
period) only if no key update has been performed since that time period
and no entry exists in its internal table for the specific message,
signature and time period specified in the query. We present ~KES~ in
Figure [1.](#_bookmark7) In Appendix [B,](#realizing-fkes) we will show
that ~KES~ can be realized by a []{#_bookmark6 .anchor}construction
based on key evolving signature schemes as defined in Appendix
[A.3.](#forward-secure-signatures-schemes)

> **Theorem 1.** *The π~KES~ construction presented in Appendix
> [B,](#realizing-fkes) realizes* ~KES~ *with erasures assuming* KES =
> (Gen*,* Sign*,* Verify*,* Update) *is a key evolving signature scheme
> with forward security as per Definition [15](#_bookmark97) and
> Definition [17.](#_bookmark99)*

Fig. 1: Functionality *F*~KES~.

## UC-VRFs with Unpredictability Under Malicious Key Generation

The usual pseudorandomness definition for VRFs (as stated in Appendix
[A.1,](#verifiable-random-functions) Definition [14)](#_bookmark94)
captures the fact that an attacker, seeing a number of VRF outputs and
proofs for adversarially chosen inputs under a key pair that is
correctly generated by a challenger, cannot distinguish the output of
the VRF on a new (also adversarially chosen) input from a truly random
string. This definition is too weak for our purposes for two reasons:
first, we need a simulation-based definition so that the VRF can be
composed directly within our protocol; second, we need the primitive to
provide some level of unpredictability even under malicious key
generation, *i.e.,* against adversaries who are allowed to generate the
secret and pubic key pair.

Our UC formulation of VRFs cannot be implied by the standard VRF
security definition or even the simulatable VRF notion of
\[[CL07](#_bookmark71)\]. For instance, the VRF proofs in our setting
have to be simulatable without knowlege of the VRF output (which is
critical as we would like to ensure that the VRF output is not leaked to
the adversary prematurely); it is easy to construct a VRF that is secure
in the standard definition, but it is impossible to simulate its proofs
without knowledge of the VRF output. Furthermore, if the adversary is
allowed to generate its own key pair it is easy to see that the
distribution of the VRF outputs cannot be guaranteed. Indeed, even for
known

constructions (*e.g.* \[[DY05](#_bookmark77)\]), an adversary that
maliciously generates keys can easily and significantly

skew the output distribution.

We call the latter property *unpredictability under malicious key
generation* and we present, in Figure [2,](#_bookmark9) a UC definition
for VRF's that captures this stronger security
requirement.[^4^](#_bookmark8) The functionality operates as follows.
Given a key generation request from one of the stakeholders,

> ^4^ []{#_bookmark8 .anchor}In fact our UC formulation captures a
> stronger notion: even for adversarial keys the VRF function will act
> as a random oracle. We note that while we can achieve this notion in
> the random oracle model, a weaker condition of mere unpredictability
> can be sufficient for the security of our protocol. A UC version

it returns a new verification key *v* that is used to label a table. Two
methods are provided for computing VRF values. The first provides just
the VRF output and does not interact with the adversary. In the second,
whenever invoked on an input *m* that is not asked before by a
stakeholder that is associated to a certain table labeled by *v*, the
functionality will query the adversary for the value of the proof *π*,
and subsequently sample a random element *ρ* to associate with *m*.
Verification is always consistent and will validate outputs that have
already being inserted in a table. Unpredictability against malicious
key generation is captured by imposing the same random selection of
outputs even for the function tables that correspond to keys of
corrupted stakeholders. Finally, the adversary is allowed to query all
function tables maintained by the functionality for which either a proof
has been computed, or they correspond to adversarial keys. In Appendix
[C,](#realizing-fvrf) we show how to realize ~VRF~ in the random oracle
model under the CDH assumption based on the 2-Hash-DH verifiable
oblivious PRF construction of [\[JKK14\].](#_bookmark79)

Fig. 2: Functionality *F*~VRF~.

> []{#_bookmark10 .anchor}**Theorem 2.** *The 2Hash-DH construction
> presented in Appendix [C,](#realizing-fvrf) realizes* ~VRF~ *in the
> random oracle model assuming the CDH.*

## Oblivious Leader Selection and *F*~INIT~

As in (synchronous) Ouroboros, for each 0 *\< j ≤ R*, a *slot leader
E~j~* is a stakeholder who is elected to generate a block at *sl~j~*.
However, our leader selection process differs from Ouroboros
\[[KRDO17](#_bookmark83)\]

> of the notion of verifiable pseudorandom permutations, cf.
> \[[DP07](#_bookmark74)\], could potentially be used towards a standard
> model instantiation of the primitive.

in three points: (1) potentially, multiple slot leaders may be elected
for a particular slot (forming a *slot leader set* ); (2) frequently,
slots will have *no leaders* assigned to them; and (3) a priori, only a
slot leader is aware that it is indeed a leader for a given slot; this
assignment is unknown to all the other stakeholders---including other
slot leaders of the same slot---until the other stakeholders receive a
valid block from this slot leader. The combinatorial analysis presented
in Section [4](#combinatorial-analysis-of-the-static-stake-protocol)
shows (with an honest stake majority) that (i.) blockchains generated
according to these dynamics are well-behaved even if multiple slot
leaders are selected for a slot and that (ii.) sequences of slots with
no leader provide sufficient stability for honest stakeholders to
effectively synchronize. As a matter of terminology, we call slots with
an associated nonempty slot leader set *active slots* and slots that are
not assigned a slot leader *empty slots*.

Fig. 3: Functionality *F*~INIT~.

> *The idealized slot leader assignment and the active slots
> coefficient.* The fundamental leader assignment process calls for a
> stakeholder *U~i~* to be independently selected as a leader for a
> particular slot *sl~j~* with probability *p~i~* depending only on its
> relative stake. (In this static-stake analysis, relative stake is
> simply determined by the genesis block *B*~0~.) The exact relationship
> between *p~i~* and the relative stake *α~i~* is determined by a
> parameter *f* of the protocol which we refer to as the *active slots
> coefficient*. Specifically,
>
> []{#_bookmark13 .anchor}*p~i~* = *φ~f~* (*α~i~*) .6. 1 *−* (1 *− f*
> )*^α^i ,* (1)

where *α~i~* is the relative stake held by stakeholder *U~i~*. We
occasionally drop the subscript *f* and write *φ*(*α~i~*) when *f* can
be inferred from context. As the events "*U~i~* is a leader for *sl~j~*"
are independent, this process may indeed generate multiple (or zero)
leaders for a given slot.

*Remarks about φ~f~* ( )*.* Observe that *φ~f~* (1) = *f* ; in
particular, the parameter *f* is the probability that a party holding
all the stake will be selected to be a leader for given slot. On the
other hand, *φ~f~* () is not linear, but slightly concave; see Figure
[7.](#_bookmark38) To motivate the choice of the function *φ~f~* , we
note that it satisfies the "independent aggregation" property:

> []{#_bookmark14 .anchor}1 *− φ* *α~i~* = (1 *− φ*(*α~i~*)) *.* (2)

In particular, when leadership is determined according to *φ~f~* , the
probability of a stakeholder becoming a slot leader in a particular slot
is independent of whether this stakeholder acts as a single party in the
protocol, or splits its stake among several "virtual" parties. In
particular, consider a party *U* with relative stake *α* who contrives
to split its stake among two virtual subordinate parties with stakes
*α*~1~ and *α*~2~ (so that *α*~1~ + *α*~2~ = *α*). Then the probability
that one of these virtual parties is elected for a particular slot is 1
(1 *φ*(*α*~1~))(1 *φ*(*α*~2~)), as these events are independent.
Property [(2)](#_bookmark14) guarantees that this is identical to
*φ*(*α*). *Thus this selection rule is invariant under arbitrary
reapportionment of a party's stake among virtual parties.*

## The Protocol in the *F*~INIT~-hybrid Model

We will construct our protocol for the static stake case in the
*F*~INIT~-hybrid model, where the genesis stake distribution S~0~ and
the nonce *η* (to be written in the genesis block *B*~0~) are determined
by

the ideal functionality ~INIT~ defined in Figure [3.](#_bookmark12)
Moreover, ~INIT~ also incorporates the diffuse functionality from
Section [2.2,](#the-semi-synchronous-model) which is implicitly used by
all parties to send messages and keep synchronized with a global clock.
~INIT~ also takes stakeholders' public keys from them and packages them
into the genesis block at the outset of the protocol. Blocks are signed
with a forward secure

signature scheme modelled by *F*~KES~, while transactions are signed
with a regular EUF-CMA secure digital signature modelled by *F*~DSIG~
(described in Appendix [A).](#definitions) For simplicity, transactions
are

assumed to be simple assertions of the form "Stakeholder *U~i~*
transfers stake *s* to Stakeholder

(*U~j~, v*^vrf^ *, v*^kes^*, v*^dsig^)" (In an implementation the
different public-keys can be hashed into a single

> *j j j*

value). Protocol *π*~SPoS~ ensures that the environment learns every
stakeholder's public keys and

provides an interface for the environment to request signatures on
arbitrary transactions.

Notice that the implicit leader assignment process described in
*π*~SPoS~ calls for a party *U~i~* to act as a leader for a slot *sl~j~*
when *y \< T~i~*; this is an event that occurs with probability
(exponentially

close to) *φ~f~* (*α~i~*) as *y* is uniform according to the
functionality *F*~VRF~. The stakeholders *U*~1~*, . . . , U~n~* interact
among themselves and with *F*~INIT~ through Protocol *π*~SPoS~ described
in Figure [4.](#_bookmark16) The protocol relies on a maxvalid*~S~*( *,*
C) function that chooses a chain given the current chain and

a set of valid chains C that are available in the network. In the static
stake case we analyze the simple "longest chain" rule.

> Function maxvalid(*C,* C): Returns the longest chain from C *∪ {C}*.
> Ties are broken in favor of *C*, if it has maximum length, or
> arbitrarily otherwise.

# Combinatorial Analysis of the Static Stake Protocol

Throughout this section, we focus solely on analysis of the protocol
*π*~SPoS~ using the idealized functionalities ~VRF~ and ~KES~ for VRFs
and digital signatures, respectively---we refer to it as the *hybrid
experiment*. As argued in Theorems [1](#_bookmark6) and
[2,](#_bookmark10) any property of the protocol that we prove true in
the hybrid experiment (such as achieving common prefix, chain growth and
chain quality) will remain true (with overwhelming probability) in the
setting where ~VRF~ and ~KES~ are replaced by their real-world
implementations---in the so-called *real experiment*.

The hybrid experiment yields a stochastic process for assigning slots to
parties which we now abstract and study in detail. Our analysis of the
resulting blockchain dynamics proceeds roughly as follows: We begin by
generalizing the framework of "forks" \[[KRDO17](#_bookmark83)\] to our
semi-synchronous setting---forks are a natural bookkeeping tool that
reflect the chains possessed by honest players during an execution of
the protocol. We then establish a simulation rule that associates with
each execution of the semi-synchronous protocol an execution of a
related "virtual" synchronous protocol. Motivated by the special case of
a *static* adversary---which simply corrupts a family of parties at the
outset of the protocol---we identify a natural "generic" probability
distribution for this simulation theorem which we prove controls the
behavior of adaptive adversaries by stochastic domination. Finally, we
prove that this simulation amplifies the effective power of the
adversary in a controlled

fashion and, furthermore, permits forks of the semi-synchronous protocol
to be projected to forks of the virtual protocol in a way that preserves
their relevant combinatorial properties. This allows us to apply the
density theorems and divergence result of
\[[KRDO17](#_bookmark83),[RMKQ17](#_bookmark90)\] to provide strong
common prefix, chain growth, and chain quality
[(4.4)](#common-prefix-chain-growth-and-chain-quality) guarantees for
the semi-synchronous protocol with respect to an adaptive adversary.

We begin in Section [4.1](#chains-forks-and-divergence) with a
discussion of characteristic strings, semi-synchronous forks, and their
relationship to executions of *π*~SPoS~ in the hybrid experiment.
Section [4.2](#the-semisynchronous-to-synchronous-reduction) then
develops the combinatorial reduction from the semi-synchronous to the
synchronous setting. The "generic, dominant" distribution on
characteristic strings is then motivated and defined in Section
[4.3,](#the-dominant-characteristic-distribution) where the effect of
the reduction on this distribution is also described. Section
[4.4,](#common-prefix-chain-growth-and-chain-quality) as described
above, establishes various guarantees on the resulting blockchain under
the dominant distribution. The full power of adaptive adversaries is
considered in Section [4.5.](#adaptive-adversaries) Finally, in
preparation for applying the protocol in the dynamic stake setting, we
formulate a "resettable setting" which further enlarges the power of the
adversary by providing some control over the random nonce that seeds the
protocol.

> []{#_bookmark16 .anchor}**Protocol** *π*SPoS
>
> The protocol *π*SPoS is run by stakeholders *U*1*, . . . , Un*
> interacting among themselves and with ideal functionalities
> *F*~INIT~*, F*~VRF~*, F*~KES~*, F*~DSIG~*,* H over a sequence of slots
> *S* = *{sl*~1~*, . . . , sl~R~}*. Define *T~i~* .6. 2*^£^*VRF *φ~f~*
> (*α~i~*) as the threshold for a stakeholder *U~i~*, where *α~i~* is
> the relative stake of *U~i~*, *R*~VRF~ denotes the output length of
> *F*~VRF~, *f* is the active slots coefficient and *φ~f~* is the
> mapping from Definition [1](#_bookmark13). Then []{#_bookmark17
> .anchor}*π*SPoS proceeds as follows:

1.  **Initialization.** The stakeholder *U~i~* sends (KeyGen*, sid,
    > U~i~*) to *F*~VRF~, *F*~KES~ and *F*~DSIG~; receiving

> (VerificationKey*, sid, v*^vrf^ ), (VerificationKey*, sid, v*^kes^)
> and (VerificationKey*, sid, v*^dsig^), respectively.
>
> *i i* *i*
>
> Then, in case it is the first round, it sends (ver keys*, sid, U~i~,
> v*^vrf^ *, v*^kes^*, v*^dsig^) to *F*~INIT~ (to claim stake
>
> *i i* *i*
>
> from the genesis block). In any case, it terminates the round by
> returning (*Ui, v*^vrf^ *, v*^kes^*, v*dsig) to

*i i* *i*

> *Z*. In the next round, it sends (genblock req*, sid, U~i~*) to
> *F*~INIT~, receiving (genblock*, sid,* S~0~*, η*) as the
>
> answer. If *Ui* is initialized in the first round, it sets the local
> blockchain *C* = *B*0 = (S0*, η*) and its
>
> initial internal state *st* = *H*(*B*0). In case *Ui* is initialized
> after the first round, it sets its initial state to *st* =
> *H*(head(*C*)) where *C* is the initial local chain provided by the
> environment.

2.  **Chain Extension.** After initialization, for every slot *slj ∈ S*,
    > every online stakeholder *Ui* performs

> []{#_bookmark18 .anchor}the following steps:

a.  *Ui* receives from the environment the transaction data *d ∈ {*0*,*
    > 1*}^∗^* to be inserted into the []{#_bookmark19
    > .anchor}blockchain.

b.  *Ui* collects all valid chains received via diffusion into a set C,
    > pruning blocks belong- ing to future slots and verifying that for
    > every chain *C^t^ ∈* C and every block *B^t^* =

> *t t t t t*
>
> (*st , d , sl , B~π~ , σ~j~I* ) *∈ C* it holds that the stakeholder
> who created it is in the slot leader
>
> set of slot *sl^t^* (by parsing *B~π~^t^* as (*U~s~, y^t^, π^t^*) for
> some *s*, verifying that *F*~VRF~ responds to (Verify*, sid, η I
> sl^t^, y^t^, π^t^, v*^vrf^ ) by (Verified*, sid, η I sl^t^, y^t^,
> π^t^,* 1), and that *y^t^ \< T~s~*), and that *F*~KES~

*t t t t t*

kes

> *t t t t t*

responds to (Verify*, sid,* (*st , d , sl , B~π~* )*, sl , σ~j~I , v~s~*
) by (Verified*, sid,* (*st , d , sl , B~π~* )*, sl ,* 1).

*U*[]{#_bookmark20 .anchor}*i* computes *C^t^* = maxvalid(*C,* C), sets
*C^t^* as the new local chain and sets state *st* = *H*(head(*C^t^*)).

c.  *U~i~* sends (EvalProve*, sid, η I sl~j~*) to *F*~VRF~, receiving
    (Evaluated*, sid, y, π*). *U~i~* checks whether

> it is in the slot leader set of slot *slj* by checking that *y \< Ti*.
> If yes, it generates a new block *B* = (*st, d, slj, Bπ, σ*) where
> *st* is its current state, *d ∈ {*0*,* 1*}^∗^* is the transaction
> data, *Bπ* = (*Ui, y, π*) and *σ* is a signature obtained by sending
> (USign*, sid, Ui,* (*st, d, slj, Bπ* )*, slj* ) to *F*~KES~ and
> receiving (Signature*, sid,* (*st, d, sl~j~, B~π~*)*, sl~j~, σ*).
> *U~i~* computes *C^t^* = *C\|B*, sets *C^t^* as the
>
> new local chain and sets state *st* = *H*(head(*C^t^*)). Finally, if
> *Ui* has generated a block in this []{#_bookmark21 .anchor}step, it
> diffuses *C^t^*.

3.  **Signing Transactions.** Upon receiving (sign tx*, sid^t^, tx*)
    > from the environment, *Ui* sends (Sign*, sid, U~i~, tx*) to
    > *F*~DSIG~, receiving (Signature*, sid, tx, σ*). Then, *U~i~* sends
    > (signed tx*, sid^t^, tx, σ*)

> back to the environment.

Fig. 4: Protocol *π*~SPoS~.

## Chains, Forks and Divergence

We begin by suitably generalizing the framework of characteristic
strings, forks, and divergence developed in [\[KRDO17\]](#_bookmark83)
to our semi-synchronous setting.

The leader assignment process given by protocol *π*~SPoS~ in the hybrid
experiment assigns leaders to slots with the following guarantees:
*(i.)* a party with relative stake *α* becomes a slot leader for a given
slot with probability *φ~f~* (*α*) .6. 1 *−* (1 *− f* )*^α^*; *(ii.)*
the event of becoming a slot leader is independent for each party and
for each slot (both points follow from the construction of *π*~SPoS~ and

the independent random sampling of every new output in ~VRF~). Clearly,
these dynamics may lead to slots with multiple slot leaders and,
likewise, slots with no slot leader. For a given (adaptive) adversary
and environment , we reflect the outcome of this process with a
*characteristic string*, as described below.

> **Definition 4 (Execution).** *For an (adaptive) adversary A and an
> environment Z, an* execution *of π*~SPoS~ *is a transcript including
> the inputs provided by , the random coins of the parties, the random
> coins of the adversary, the responses of the ideal functionalities and
> the random oracle.*
>
> *This data determines the entire dynamics of the protocol: messages
> sent and delivered, the internal states of the parties at each step,
> the set of corrupt parties at each step, etc.*
>
> []{#_bookmark23 .anchor}**Definition 5 (Characteristic string).** *Let
> S* = *{sl*~1~*, . . . , sl~R~} be a sequence of slots of length R*
>
> *and E be an execution (with adversary A and environment Z). For a
> slot sl~j~, let P*(*j*) *denote the*
>
> *set of parties assigned to be slot leaders for slot j by the protocol
> π*~SPoS~ *(specifically, those parties U~i~ for which y \<* 2*^.t^*VRF
> *φ~f~* (*α~i~*)*, where* (*y, π*) *←* Prove~VRF*.sk*~ (*η I sl~j~*)*).
> We define the* characteristic string *w ∈ {*0*,* 1*, ⊥}R of S to be
> the random variable so that*

*w~j~* =

> 0 *if \|P*(*j*)*\|* = 1 *and the assigned party is honest,*
>
> 1 *if \|P*(*j*)*\| \>* 1 *or a party in P*(*i*) *is adversarial.*

\(3\)

> *For such a characteristic string w ∈ {*0*,* 1*, ⊥}∗ we say that the
> index j is* uniquely honest *if w~j~* = 0*,* tainted *if w~j~* = 1*,
> and* empty *if w~j~* = *. We say that an index is* active *if w~j~*
> 0*,* 1 *. Note that an index is "tainted" according to this
> terminology in cases where multiple honest parties (and no adversarial
> party) have been assigned to it.*
>
> *We denote by ^f^*

*Z,A*

> *the distribution of the random variable w* = *w*~1~ *. . . w~R~ in
> the hybrid*
>
> *experiment with the active slots coefficient f, adversary A, and
> environment Z. For a fixed execution*
>
> *E, we denote by w~E~ the (fixed) characteristic string resulting from
> that execution.*

We emphasize that in an execution of *π*~SPoS~, the resulting
characteristic string is determined by both the nonce (and the effective
leader selection process), the adaptive adversary *A*, and the
environment *Z* (which, in particular, determines the stake
distribution).

**From executions to forks.** The notion of a "fork", defined in
\[[KRDO17](#_bookmark83)\], is a bookkeeping tool that indicates the
chains broadcast by honest players during an idealized execution of a
blockchain protocol. We now adapt the synchronous notion of
\[[KRDO17](#_bookmark83)\] to reflect the effect of message delays.

An execution of Protocol *π*~SPoS~ induces a collection of blocks
broadcast by the participants. As we now focus merely on the structural
properties of the resulting blockchain, for each broadcast block we now
retain only two features: the *slot* associated with the block and the
*previous block* to which it is "attached" by the idealized digital
signature *σ~j~*. (Of course, we only consider blocks with legal
structure that meet the verification criteria of *π*~SPoS~.) Note that
multiple blocks may be associated with a particular slot, either because
multiple parties are assigned to the slot or an adversarial party is
assigned to a slot (who may choose to deviate from the protocol by
issuing multiple blocks). In any case, these blocks induce a natural
directed tree by treating the blocks as

vertices and introducing a directed edge between each pair of blocks
(*b, b^t^*) for which *b^t^* identifies *b*

as the previous block. In the *∆*-semisynchronous setting, the maxvalid
rule enforces a further critical

property on this tree: the depth of any block broadcast by an honest
player during the protocol must exceed the depths of any
honestly-generated blocks from slots at least *∆* in the past. (This
follows because such previously broadcast blocks would have been
available to the honest player, who always builds on a chain of maximal
length.) We call a directed tree with these structural properties a
*∆*-*fork*, and define them precisely below.

We may thus associate with any execution of *π*~SPoS~ a fork. While this
fork disregards many of the details of the execution, any violations of
common prefix are immediately manifested by certain diverging paths in
the fork. A fundamental element of our analysis relies on controlling
the structure of the forks that can be induced in this way for a given
characteristic string (which determines which slots have been assigned
to uniquely honest parties). In particular, we prove that

common prefix violations are impossible for "typical" characteristic
strings generated by *π*~SPoS~ with []{#_bookmark24 .anchor}an adversary
*A* by establishing that such diverging paths cannot exist in their
associated forks.

> **Definition 6 (***∆***-fork).** *Let w ∈ {*0*,* 1*, ⊥}k and ∆ be a
> non-negative integer. Let A* = *{i \| w~i~ /*= *⊥}*
>
> *denote the set of active indices, and let H* = *i w~i~* = 0 *denote
> the set of uniquely honest indices. A*
>
> []{#_bookmark25 .anchor}*∆*-fork *for the string w is a directed,
> rooted tr*[]{#_bookmark26 .anchor}*ee F* = (*V, E*) *with a labeling
> £* : *V* 0 *A so that*
>
> *(i) the root r V is given the label £*(*r*) = 0*; (ii) each edge*
> []{#_bookmark27 .anchor}*of F is directed away from the root;*
>
> *(iii) the labels along any directed path* []{#_bookmark29
> .anchor}*are strictly increasing; (iv) each uniquely honest index i H
> is the label of exactly one vertex of F; (v) the function* **d** : *H*
> 1*, . . . , k , defined so that* **d**(*i*) []{#_bookmark28
> .anchor}*is the depth in F of the unique vertex v for which £*(*v*) =
> *i, satisfies the following ∆*-monotonicity *property: if i, j ∈ H and
> i* + *∆ \< j, then* **d**(*i*) *\<* **d**(*j*)*.*
>
> *As a matter of notation, we write F ~∆~ w to indicate that F is a
> ∆-fork for the string w. We typically refer to a ∆-fork as simply a
> "fork".*

![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image2.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image4.png){width="0.15433508311461067in"
height="8.530839895013123e-2in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}[]{#_bookmark30 .anchor}*t*

*t*ˆ

*w* = 0

> 1 0 1
>
> 0 0 1 1 0

Fig. 5: A (synchronous) fork *F* for the string *w* = 010100110.
Vertices appear with their labels and vertices belonging to (uniquely)
honest slots are highlighted with double borders. Note that the depths
of the (honest) vertices associated with the honest indices of *w* are
strictly increasing. Two tines are distinguished in the figure: one,
labeled *t*ˆ, terminates at the vertex labeled 9 and is the longest tine
in the fork; a second tine *t* terminates at the vertex labeled 3. The
divergence of *t* and *t*ˆ is div(*t, t*ˆ) = 2.

![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image5.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image5.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image6.png){width="0.2690004374453193in"
height="0.2690004374453193in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image1.png){width="0.25236329833770776in"
height="0.25236329833770776in"}![](vertopal_d3fefedd74c54e3b8168957674ff4976/media/image3.png){width="0.23299103237095364in"
height="0.23299103237095364in"}

> *w* = 0 *⊥* 1 *⊥* 0
>
> 1 0 0
>
> *⊥ ⊥ ⊥* 1 1 0

Fig. 6: A 3-fork *F^t^* for the characteristic string *w* =
0*⊥*1*⊥*01001*⊥⊥*10. Note that *F^t^* is not a 2-fork since **d**(8) = 2
*/\>* 2 = **d**(5). Indices *{*1*,* 5*,* 7*,* 8*,* 14*}* are uniquely
honest, *{*3*,* 6*,* 12*,* 13*}* are tainted, and

*{*2*,* 4*,* 9*,* 10*,* 11*}* are empty. The index 8 is
4-right-isolated, but not 5-right-isolated.

See Figures [5](#_bookmark30) and [6](#_bookmark31) for examples of
forks. Also note that our notion of a fork deliberately models honest
parties that do not exploit all the information available to them thanks
to the delivery guarantees provided by the DDiffuse functionality. In
particular, an honest party that is permanently online could (in our
communication model) safely discard any (adversarial) blocks that were
not received in the correct time window.

Nonetheless, it remains true that any execution of the hybrid experiment
leads to a fork as we defined it, a relationship that we make fully
formal in Appendix [F.](#from-executions-to-forks) Given this
relationship, we can

later focus on investigating the properties of the distribution *^f^*

*Z,A*

. Roughly speaking, if we prove

that a characteristic string sampled from *^f^*

*Z,A*

, with overwhelming probability, does not allow for

*any* "harmful" forks, then this also implies that a random execution
with overwhelming probability

results in a "harmless" outcome.

Now we continue with the adaptation of the framework from
\[[KRDO17](#_bookmark83)\] to the semi-synchronous setting.

> **Definition 7 (Tines, length, and viability).** *A path in a fork F
> originating at the root is called a* tine*. For a tine t we let*
> length(*t*) *denote its* length*, equal to the number of edges on the
> path. For a vertex v, we call the length of the tine terminating at v
> the* depth of *v. For convenience, we overload the notation £*(*·*)
> *so that it applies to tines by defining £*(*t*) .6. *£*(*v*)*, where
> v is the*
>
> *terminal vertex on the tine t. We say that a tine t is ∆*-viable *if*
> length(*t*) max~*h*+*∆≤.t*(*t*)~ **d**(*h*)*, this*
>
> *maximum extended over all uniquely honest indices h (appearing ∆ or
> more slots before £*(*t*)*). Note that any tine terminating in a
> uniquely honest vertex is necessarily viable by the ∆-monotonicity
> property.*

*Remarks on viability and divergence.* The notion of viability, defined
above, demands that the length of a tine *t* be no less than that of all
tines broadcast by uniquely honest slot leaders prior to slot *£*(*t*)
*∆*. Observe that such a tine could, in principle, be selected according
to the maxvalid() rule by an honest player online at time *£*(*t*): in
particular, if all blocks broadcast by honest parties

in slots *£*(*t*) *∆,. . . , £*(*t*) are maximally delayed, the tine can
favorably compete with all other tines that the adversary is obligated
to deliver by slot *£*(*t*). The major analytic challenge, both in the
synchronous case and in our semisynchronous setting, is to control the
possibility of a *common prefix* violation, which occurs when the
adversary can manipulate the protocol to produce a fork with two viable
tines with a relatively short common prefix. We define this precisely by
introducing the notion of divergence.

> **Definition 8 (Divergence).** *Let F be a ∆-fork for a string w ∈
> {*0*,* 1*, ⊥}∗. For two ∆-viable tines t*~1~ *and t*~2~ *of F, define
> their* divergence *to be the quantity*
>
> div(*t*~1~*, t*~2~) .6. min*{*length(*t*~1~)*,* length(*t*~2~)*} −*
> length(*t*~1~ *∩ t*~2~) *,*
>
> *where t*~1~ *t*~2~ *denotes the common prefix of t*~1~ *and t*~2~*.
> We extend this notation to the fork F by maximizing over viable
> tines:* div*~∆~*(*F* ) .6. max*~t~*1*,t*2 div(*t*~1~*, t*~2~)*, taken
> over all pairs of ∆-viable tines of F. Finally, we define the
> ∆-divergence of a characteristic string w to be the maximum over all*
>
> *∆-forks:* div*~∆~*(*w*) .6. max*~F~ ~f\--~∆w* div*~∆~*(*F* )*.*

Our primary goal in this section is to prove that, with high
probability, the characteristic strings induced by protocol *π*~SPoS~
have small divergence and hence provide strong guarantees on common
prefix.

**The Synchronous Case.** The original development of
\[[KRDO17](#_bookmark83)\] assumed a strictly synchronous environment.
Their definitions of characteristic string, fork, and divergence
correspond to the case

*∆* = 0, where characteristic strings are elements of 0*,* 1 *^∗^*. As
this setting will play an important

role in our analysis---fulfilling the role of the "virtual protocol"
described at the beginning of this

section---we set down some further terminology for this synchronous case
and establish a relevant combinatorial statement based on a result in
[\[KRDO17\]](#_bookmark83) that we will need for our analysis.

> **Definition 9 (Synchronous characteristic strings and forks).** *A*
> synchronous characteristic string *is an element of {*0*,* 1*}∗. A*
> synchronous fork *F for a (synchronous) characteristic string w is a*
> 0*-fork F f-*~0~ *w.*

An immediate conclusion of the results obtained in
\[[KRDO17](#_bookmark83),[RMKQ17](#_bookmark90)\] is the following bound
on the probability that a synchronous characteristic string drawn from
the binomial distribution []{#_bookmark32 .anchor}has large divergence.

> **Theorem 3.** *Let £, k ∈* N *and E ∈* (0*,* 1)*. Let w ∈ {*0*,*
> 1*}.t be drawn according to the binomial distribution, so that*
> Pr\[*w~i~* = 1\] = (1 *− E*)*/*2*. Then* Pr\[div~0~(*w*) *≥ k*\] *≤*
> exp(ln *£ − Ω*(*k*))*.*

## The Semisynchronous to Synchronous Reduction

We will make use of the following mapping, that maps characteristic
strings to synchronous []{#_bookmark34 .anchor}characteristic strings.

> **Definition 10 (Reduction mapping).** *For ∆ ∈* N*, we define the
> function ρ~∆~* : *{*0*,* 1*, ⊥}∗ →*
>
> *{*0*,* 1*}∗ inductively as follows: ρ~∆~*(*ε*) = *ε, ρ~∆~*(*⊥ Iw^t^*)
> = *ρ~∆~*(*w^t^*)*,*
>
> *ρ~∆~*(1 []{#_bookmark35 .anchor}*Iw^t^*) = 1 *Iρ~∆~*(*w^t^*)*,*
>
> *~t~* 0 *Iρ~∆~*(*w^t^*) *if w^t^ ∈ ⊥∆−*1 *I{*0*,* 1*, ⊥}∗,*

\(4\)

> *We call ρ~∆~ the* reduction mapping for delay *∆.*

A critical feature of the map *ρ~∆~* is that it monotonically transforms
*∆*-divergence to synchronous []{#_bookmark36 .anchor}divergence. We
state this in the following lemma.

> **Lemma 1.** *Let w ∈ {*0*,* 1*, ⊥}∗. Then* div*~∆~*(*w*) *≤*
> div~0~(*ρ~∆~*(*w*))*.*
>
> *Proof.* Let *w ∈ {*0*,* 1*, ⊥}∗* be a characteristic string with
> div*~∆~*(*w*) = *k* and let *F f-~∆~ w* be a *∆*-fork with
> div*~∆~*(*F* ) = *k*. Let *w^t^* = *ρ~∆~*(*w*); to prove that
> div~0~(*w^t^*) *≥ k*, we construct a fork *F^t^ f-*~0~ *w^t^* for
> which div(*F^t^*) *≥ k*. Let *A* = *{i \| w~i~ /*= *⊥}* denote the set
> of active indices (as in Definition [6)](#_bookmark24) and

note that *ρ~∆~*(*w*) = *A* ; as noted above, each non- symbol of *w*
corresponds to a unique symbol in *w^t^*. We let *π* : *A* 1*, . . . ,
A* be the (bijective, increasing) function which records the position in
*w^t^* corresponding to a particular active index *i* in *w*. Finally,
we define the fork *F^t^* as follows: as a graph, *F^t^* has the same
structure as *F* ; the labeling *£^t^* (for *F^t^*) is given by the rule
*£^t^*(*v*) = *π*(*£*(*v*)); of course, *£^t^*(*r*) = 0 for the root
vertex *r*.

> To verify that *F^t^* ~0~ *w^t^* = *ρ~∆~*(*w*), we recall the
> necessary properties from the definition. Properties

[(i)](#_bookmark25) and [(ii)](#_bookmark26) of the Definition
[6](#_bookmark24) are immediate; property [(iii)](#_bookmark28) follows
because *π* is strictly increasing. For the remaining properties, we
recall the definition of *ρ~∆~*: According the rule, *w~i~* = 1 *⇒ wπt*
(*i*) = 1 from which property [(iv)](#_bookmark27) follows immediately.
It remains to check property [(v).](#_bookmark29) The value *wπt* (*i*)
when *w~i~* = 0 is determined by the *∆* 1 following symbols of *w*: if
*w~i~*~+1~ = *w~i~*~+2~ = = *w~i~*~+*∆−*1~ = , we say that *i* is
*∆-right-isolated* (cf. \[[GKL15](#_bookmark76)\], where a similar
feature arises in a proof-of-work setting) and in this case *wπt* (*i*)
= 0; otherwise *wπt* (*i*) = 1. In particular, if *wπt* (*i*) = 0 we
must have *w~i~* = 0 and *w~i~*~+*s*~ = for 0 *s \< ∆*. As we wish to
conclude that *F^t^* is a synchronous fork, it must

satisfy the *∆*-monotonicity property with *∆* = 0, which is to say that
**d**( ) is strictly increasing

on the set of uniquely honest indices (of *w^t^*). However, in light of
the discussion above, any two uniquely honest indices of *w^t^* must
correspond to uniquely honest indices of *w* separated by at least

*∆* 1 intervening symbols; thus the *∆*-monotonicity property of *F*
ensures the 0-monotonicity property of *F^t^*, as desired.

In preparation for establishing that div~0~(*F^t^*) div(*F* ) = *k*, we
note that a *∆*-viable tine *t* of *F ~∆~ w* is 0-viable when viewed as
a tine of *F^t^ w^t^*. In particular, let *h^t^* be a uniquely honest
index of *w^t^* for which *h^t^ £^t^*(*t*) and let *h* be the uniquely
honest index of *w* for which *π*(*h*) = *h^t^*. As *π*(*h*) is uniquely
honest in *w^t^*, *h* is *∆*-right isolated in *w*, and we conclude that
length(*t*) **d**(*h*), because *t* is *∆*-viable. This *t* is 0-viable
in *F^t^*.

Finally, let *t*~1~ and *t*~2~ be two *∆*-viable tines of *F* for which
div*~∆~*(*t*~1~*, t*~2~) = div*~∆~*(*w*). In light of the discussion
above, these tines are 0-viable in *F^t^*; as the two forks have the
structure as graphs,

we conclude that div~0~(*w^t^*) *≥* div*~∆~*(*t*~1~*, t*~2~) =
div*~∆~*(*w*), as desired. *un*

## The Dominant Characteristic Distribution

The high-probability results for our desired chain properties depend on
detailed information about

the distribution on characteristic strings *^f^*

*Z,A*

determined by the adversary *A*, the environment *Z*,

and the parameters *f* and *R*. In this section we define a
distinguished distribution on characteristic

strings which we will see "dominates" the distributions produced by any
static adversary. Later in Section [4.5](#adaptive-adversaries) we show
that the same is true also for adaptive adversaries. We then study the
effect of *ρ~∆~* on this distribution in preparation for studying common
prefix, chain growth, and chain quality.

> **Motivating the Dominant Distribution: Static Adversaries.** To
> motivate the dominant distribution, consider the distribution induced
> by a *static* adversary who corrupts---at the outset of the
> protocol---a set *U~A~* of parties with total relative stake *α~A~*.
> (Formally, one can model this by

restricting to environments that only allow static corruption.)
Recalling Definition [1,](#_bookmark13) a party with

relative stake *α~i~* is independently assigned to be a leader for a
slot with probability

> *φ~f~* (*α~i~*) .6. *φ*(*α~i~*) .6. 1 *−* (1 *− f* )*^α^i .*

The function *φ~f~* is concave since

> *∂*^2^*φ~f~* 2 *α*
>
> *∂α*2 (*α*) = *−*(ln(1 *− f* )) (1 *− f* )
>
> *\<* 0 *,*

Figure [7](#_bookmark38) shows a plot of *φ*~1*/*2~ for illustration.
Considering that *φ~f~* (0) = 0 and *φ~f~* (1) = *f* , concavity implies
that *φ~f~* (*α*) *fα* for *α* \[0*,* 1\]. As *φ~f~* (0) 0 and *φ~f~* is
concave, the function *φ~f~* is subadditive. This immediately implies
the following proposition that will be useful during the analysis.

> []{#_bookmark38 .anchor}0*.*6
>
> 0*.*4
>
> 0*.*2
>
> 0
>
> 0 0*.*2 0*.*4 0*.*6 0*.*8 1

Fig. 7: The function *φ*~1*/*2~(*α*) = 1 (1*/*2)*^α^* and the linear
function *α α/*2, for comparison. The point (1*,* 1*/*2) is marked in
solid black.

> **Proposition 1.** *The function φ~f~* (*α*) *satisfies the following
> properties.*
>
> *φ~f~* *α~i~* = 1 *−* (1 *− φ~f~* (*α~i~*)) *≤* *φ~f~* (*α~i~*) *,
> α~i~ ≥* 0 *,* (5)
>
> [*φf* (*α*)]{.underline} = [*φf* (*α*)]{.underline} *≥ α , α ∈* \[0*,*
> 1\] *.* []{#_bookmark39 .anchor}(6)
>
> *φ~f~* (1) *f*
>
> Recalling Definition [5,](#_bookmark23) this (static) adversary
> determines a distribution *^f^*

*Z,A*

on strings

> *w ∈ {*0*,* 1*, ⊥}R* by independently assigning each *w~i~* so that
>
> *p^A^* .6. Pr\[*w~i~* = *⊥*\] = (1 *− φ*(*α~i~*)) = (1 *− f* )*^α^i* =
> (1 *− f* ) *,*

*i∈P i∈P*

> *p*0*A* .6. Pr\[*w~i~* = 0\] = (1 *−* (1 *− f* )*^α^h* ) *·* (1 *− f*
> )^1*−α*^*i ,*
>
> *h∈H*
>
> *p*1*A* .6. Pr\[*w~i~* = 1\] = 1 *− p^A^ − p*0*A .*

\(7\)

Here *H* denotes the set of all honest parties in the stake distribution
*S* determined by *Z*. As before,

*P* denotes the set of all parties.

It is convenient to work with some bounds on the above quantities that
depend only on "macroscopic" features of and : namely, the relative
stake of the honest and adversarial parties, and the parameter *f* . For
this purpose we note that

> *p*0*A ≥* *φ*(*α~h~*) *·* (1 *− φ*(*α~i~*)) *≥ φ*(*α~H~*) *· p^A^* =
> *φ*(*α~H~*) *·* (1 *− f* ) *,* (8)
>
> *h∈H i∈P*

where *α~H~* denotes the total relative stake of the honest parties.
Note that this bound applies to all static adversaries that corrupt no
more []{#_bookmark40 .anchor}than a 1 *α~H~* fraction of all stake. With
this in mind, we define the dominant distribution as follows.

> **Definition 11 (The dominant distribution** *Df* **).** *For two
> parameters f and α, define Df to be*
>
> *the distribution on strings w ∈ {*0*,* 1*, ⊥}R that independently
> assigns each w~i~ so that p~⊥~* .6. Pr\[*w~i~* =
>
> *⊥*\] = 1 *− f, p*~0~ .6. Pr\[*w~i~* = 0\] = *φ*(*α*) *·* (1 *− f* )*,
> and p*~1~ .6. Pr\[*w~i~* = 1\] = 1 *− p~⊥~ − p*~0~*.*

The distribution *Df* "dominates" *Df* for any static adversary *A* that
corrupts no more than a

relative 1 *− α* share of the total stake, in the sense that nonempty
slots are more likely to be tainted

under *Df* than they are under *Df* .

To make this relationship precise, we introduce the partial order *:::*
on the set *{⊥,* 0*,* 1*}* so

that *x ::: y* if and only if *x* = *y* or *y* = 1. We extend this
partial order to *{⊥,* 0*,* 1*}R* by declaring

> *x*~1~ *. . . x~R~ y*~1~ *. . . y~R~* if and only if *x~i~ y~i~* for
> each *i*. Intuitively, the relationship *x y* asserts that

*y* is "more adversarial than" *x*; concretely, any legal fork for *x*
is also a legal fork for *y*. []{#_bookmark41 .anchor}We record this in
the lemma below, which follows directly from the definition of *∆*-fork
and div*~∆~*.

> **Lemma 2.** *Let x and y be characteristic strings in {*0*,* 1*, ⊥}R
> for which x ::: y. Then 1.) for every fork F, F f-~∆~ x* =*⇒ F f-~∆~
> y; 2.) for every ∆,* div*~∆~*(*x*) *≤* div*~∆~*(*y*)*.*

Finally, we define a notion of stochastic dominance for distributions on
characteristic strings, and *α*-dominated adversaries.

> **Definition 12 (Stochastic dominance).** *We say that a subset E ⊆
> {⊥,* 0*,* 1*}R is* monotone *if x ∈ E and x ::: y implies that y ∈ E.
> Let D and Dt be two distributions on the set of characteristic strings
> {⊥,* 0*,* 1*}R. Then we say that Dt* dominates *D, written D ::: Dt,
> if* Pr*~D~*\[*E*\] *≤* Pr*~D~I* \[*E*\] *for*
>
> *every monotone set E. An adversary is called α-dominated if the
> distribution ^f^*

*Z,A*

> *that it induces*
>
> *on the set of characteristic strings satisfies ^f^*

*Z,A*

> *::: Df .*

In our application, the events of interest are *D~∆~* = *{x \|*
div*~∆~*(*x*) *≥ k}* which are monotone by Lemma [2.](#_bookmark41) We
note that any static adversary that corrupts no more than a 1 *− α*
fraction of stake

is *α*-dominated, and it follows that Pr *f* \[div*~∆~*(*w*) *≥ k*\] *≤*
Pr *f* \[div*~∆~*(*w*) *≥ k*\]. This motivates a

> *DZ,A Dα*

particular study of the "dominant" distribution *Df* .

> **The Induced Distribution *ρ~∆~*(*D^f^* ).** The dominant
> distribution *Df* on *{*0*,* 1*, ⊥}R* in conjunction

with the definition of *ρ~∆~* of [(4)](#_bookmark35) above implicitly
defines a family of random variables *ρ~∆~*(*w*) = *x*~1~ *. . . x~.t~*
0*,* 1 *^∗^*, where *w* 0*,* 1*, ^R^* is distributed according to *^f^*
. Observe that *£* = *R* \#*~⊥~*(*w*) is precisely the number of active
indices of *w*. We now note a few properties of this resulting

distribution that will be useful to us later. In particular, we will see
that the *x~i~* random variables are roughly binomially distributed, but
subject to an exotic stochastic "stopping time" condition in tandem with
some distortion of the last *∆* variables.

> **Lemma 3 (Structure of the induced distribution).** *Let x*~1~ *. . .
> x~.t~* = *ρ~∆~*(*w*) *where w ∈ {*0*,* 1*, ⊥}R*
>
> *is distributed according to Df . There is a sequence of independent
> random variables z*~1~*, z*~2~*, . . . with*
>
> *each z~i~ ∈ {*0*,* 1*} so that*
>
> Pr\[*z*
>
> = 0\] = ( [*p*0]{.underline} ) *p^∆−^*^1^ *≥ α ·* (1 *− f* )*^∆^ ,*
> (9)
>
> *and x*~1~ *. . . x~.t−∆~* = *ρ~∆~*(*w*~1~ *. . . , w~R~*)*^r∆^ is a
> prefix of z*~1~*z*~2~ *. . . .* []{#_bookmark42 .anchor}(10)
>
> *(Note that while the z~i~ are independent with each other, they are
> not independent with w.)*

*Proof.* It simplifies our analysis to treat *w* as the first *R*
symbols of an infinite string *w*~1~*w*~2~ *. . .* of independent random
variables with distribution given by Definition [11](#_bookmark40)
above. (We use the same name for this infinite sequence as it will cause
no confusion.) The distribution of the infinite sequence *w* can be
given an alternative description as *b*~0~*e*~1~*b*~1~*e*~2~*b*~2~ *. .
.*, where the (independent)

> random variables *e~i~ ∈ {*0*,* 1*}* and *b~i~ ∈ {⊥}∗* have the
> probability laws

*e* = 0 with probability *p*~0~*/*(*p*~0~ + *p*~1~),

> 1 with probability *p*~1~*/*(*p*~0~ + *p*~1~),

and *b* = *^t^* with probability *p^t^* (1 *p* ). In this description,
the random variables *b* generate

> *⊥*
>
> symbols that appear between appearances of 0 and 1. Now we

observe that *z*~1~*z*~2~ *. . .* = *ρ~∆~*(*b*~0~*e*~1~*b*~1~ *. .
.*)---which we temporarily treat as operating on an infinite
sequence---has an immediate description in terms of the *x~i~, b~i~*
random variables:

> *z* = 1 if *e~i~* = 1 or *\|b~i~\| \< ∆ −* 1*,*
>
> 0 if *e~i~* = 0 and *\|b~i~\| ≥ ∆ −* 1.

It follows that the variables *z~i~* 0*,* 1 are independent and
binomially distributed, with the property that

[]{#_bookmark43 .anchor}Pr\[*z*

> = 0\] = ( [*p*0]{.underline} ) *p^∆−^*^1^ = [*φ*(*α*)]{.underline} *·*
> (1 *− f* )*^∆^* [(6)](#_bookmark39) *α ·* (1 *− f* )*^∆^ ,* (11)
>
> \(i\)

where *≥* follows from equation (i) and we use the equality *p*~0~ +
*p*~1~ = 1 *− p~⊥~*.

> In our setting, the reduction function *ρ~∆~*(*·*) is applied to a
> prefix of the string *w* of finite length

*R*. In fact, the resulting "stopping criteria" on the random variables
*z*~1~*, z*~2~*, . . .* can both introduce

correlations and distort the coordinatewise distribution. However, we
note that *ρ~∆~*(*w*~1~ *. . . w~R~*) produces a prefix of the sequence
*z*~1~*, z*~2~*, . . .* with the irritating possibility that the last
*∆* of the *z~i~* in this prefix may be altered by the fact that there
are not sufficient symbols in the string *w* to satisfy the criteria for
*z~i~* = 0. Thus we observe [(10):](#_bookmark42)

*x*~1~ *. . . x~.t−∆~* = *ρ~∆~*(*w*~1~ *. . . , w~R~*)*^r∆^* is a prefix
of *z*~1~*z*~2~ *. . . .*

where *·r∆* denotes the truncation operator that removes the last *∆*
symbols, and the sequence

*z*~1~*z*~2~ is determined by the infinite string *w*~1~*w*~2~ Recall
that the *z~i~* are binomially distributed

> with parameter *≈* 1 *− α*(1 *− f* )*^∆^*. *un*
>
> **Divergence for the Dominant Distribution.** Our goal is to apply the
> reduction *ρ~∆~*, Lemma [1,](#_bookmark36)

and Theorem [3](#_bookmark32) to establish an upper bound on the
probability that a string drawn from the dominant distribution *Df* has
large *∆*-divergence. The difficulty is that the distribution resulting

from applying *ρ~∆~* to a string drawn from *Df* is no longer a simple
binomial distribution, so we

[]{#_bookmark44 .anchor}cannot apply Theorem [3](#_bookmark32) directly.
We resolve this obstacle in the proof of the following theorem.

> **Theorem 4.** *Let f ∈* (0*,* 1\]*, ∆ ≥* 1*, and α be such that
> α*(1*−f* )*^∆^* = (1+*E*)*/*2 *for some E \>* 0*. Let w be a string
> drawn from {*0*,* 1*, ⊥}R according to Df . Then we have*
> Pr\[div*~∆~*(*w*) *≥ k* + *∆*\] = 2^*−Ω*(*k*)+log^ *^R^.*

*Proof.* Observe that div~0~( ) is monotone in the sense that if *y*ˇ is
a prefix of *y* then div~0~(*y*ˇ) div~0~(*y*); this follows because any
fork *F*ˇ 0 *y*ˇ can be "extended" to a fork *F y* which includes all
tines of *F*ˇ. Additionally, we note that div~0~( ) has a
straightforward "Lipshitz property": if *y y*ˇ + *s* then div~0~(*y*)
div~0~(*y*ˇ) + *s*; this follows because any fork *F* ~0~ *y* can be
restricted to a fork *F*ˇ 0 *y*ˇ by retaining only vertices labeled by
*y*ˇ---this can trim no more than *s* vertices from any tine.

> In light of Lemma [1](#_bookmark36) we conclude that
>
> div*~∆~*(*w*) *≤* div~0~(*ρ~∆~*(*w*)) *≤* div~0~(*ρ~∆~*(*w*)*^r∆^*) +
> *∆ ≤* div~0~(*z*~1~ *. . . z~R~*) + *∆,*

where the last inequality follows because the random variable
*ρ~∆~*(*w*~1~ *. . . w~R~*) can certainly have length no more than *R*.
As the random variables *z~i~* are binomial with Pr\[*z~i~* = 0\] *≥
α*(1 *− f* )*^∆^*, the conclusion of Theorem [4](#_bookmark44) now
follows directly from the assumption that *α*(1 *− f* )*^∆^ ≥* (1 +
*E*)*/*2 and

Theorem [3.](#_bookmark32) *un*

*Remark.* Intuitively, the theorem asserts that sampling the
characteristic string in the *∆*-semi- synchronous setting with protocol
parameter *f* according to *^f^* is, for the purpose of analyzing
divergence, comparable to the *synchronous* setting in which the honest
stake has been reduced

> from *α* to *α*(1 *− f* )*^∆^*.

## Common Prefix, Chain Growth, and Chain Quality

Our results on *∆*-divergence from the previous section allow us to
easily establish the following []{#_bookmark46 .anchor}three statements.

> **Theorem 5 (Common prefix).** *Let k, R, ∆ ∈* N *and ε ∈* (0*,* 1)*.
> Let A be an α-dominated adversary against the protocol π*~SPoS~ *for
> some α satisfying α*(1*−f* )*^∆^ ≥* (1+*E*)*/*2*. Then the probability
> that A, when executed in a ∆-semisynchronous environment, makes
> π*~SPoS~ *violate the common prefix property with parameter k
> throughout a period of R slots is no more than* exp(ln *R* + *∆ −
> Ω*(*k*))*. The constant hidden by the Ω*(*·*)*-notation depends on E.*

*Proof.* Observe that an execution of protocol *π*~SPoS~ violates the
common prefix property with parameter *k* precisely when the *∆*-fork
*F* induced by this execution has div*~∆~*(*F* ) *≥ k*. We have

> Pr\[div*~∆~*(*F* ) *≥ k*\] *≤* Pr \[div*~∆~*(*w*) *≥ k*\] *≤*
> Pr\[div*~∆~*(*w*) *≥ k*\] *≤* exp(ln *R − Ω*(*k − ∆*))
>
> *DZ,A Dα*

where the first inequality follows from the definition of div ( ); the
second one holds since *^f^*

*Z,A*

> *::: Df*

and the set

> *D~∆~* = *{x \|* div*~∆~*(*x*) *≥ k}*

is monotone; and the last one follows from Theorem [4.](#_bookmark44)
(For convenience, we have moved the *∆*

outside the asymptotic notation, which only makes the bound weaker as
the hidden constant is less

than 1.) *un*

To obtain a bound on the probability of a violation of the chain growth
property, we again consider the *∆*-right-isolated uniquely honest slots
introduced in Section
[4.2.](#the-semisynchronous-to-synchronous-reduction) Intuitively, we
argue that the leader of such a slot has already received all blocks
that were created in all previous such slots and therefore the block it
creates will be having depth larger than all these blocks. It then
[]{#_bookmark47 .anchor}follows that the length of the chain grows by at
least the number of such slots.

> **Theorem 6 (Chain growth).** *Let k, R, ∆ ∈* N *and ε ∈* (0*,* 1)*.
> Let A be an α-dominated adversary against the protocol π*~SPoS~ *for
> some α \>* 0*. Then the probability that A, when executed in a ∆-semi-
> synchronous environment, makes π*~SPoS~ *violate the chain growth
> property with parameters s ≥* 4*∆ and τ* = *cα/*4 *throughout a period
> of R slots, is no more than* exp (*−cαs/*(20*∆*) + ln *R∆* + *O*(1))*,
> where c denotes the constant c* := *c*(*f, ∆*) = *f* (1 *− f* )*^∆^.*

*Proof.* Recall that the definition of chain growth requires that if the
longest chain possessed by an honest party at the onset of some slot
*sl*~1~ is *C*~1~, and the longest chain possessed by a (potentially
different) honest party at the onset of slot *sl*~2~ *≥ sl*~1~ + *s* is
*C*~2~, then length(*C*~2~) *−* length(*C*~1~) *≥ τs*.

Let *s*ˆ*l*~1~*, . . . , s*ˆ*l~h~* be the increasing sequence of all
*∆*-right-isolated uniquely honest slots among the slots in *T* :=
*{sl*~1~ + *∆, sl*~1~ + *∆* + 1*, . . . , sl*~2~ *− ∆}*. Observe that
since *s*ˆ*l*~1~ *≥ sl*~1~ + *∆*, the leader of *s*ˆ*l*~1~ will append a
block to a chain that is at least as long as ~1~, since ~1~ will be
known to him and will be considered in the maxvalid function. Therefore,
the chain that the leader of *s*ˆ*l*~1~ diffuses will be at least 1
block longer than *C*~1~. Analogously, the leader of every *s*ˆ*l~i~*
will diffuse a chain that is at least 1 block longer than the chain
diffused by the leader of *s*ˆ*l~i−~*~1~ since *s*ˆ*l~i−~*~1~ is
*∆*-right-isolated. Finally, the chain diffused by the leader of
*s*ˆ*l~h~* will be known to all parties at slot *sl*~2~ and hence
length(*C*~2~) will be at least as long as this chain. It follows that
length(*C*~2~) *−* length(*C*~1~) *≥ h*.

It remains to bound the number *h* of *∆*-right-isolated uniquely honest
slots among the slots with

indices in *T* . To make our notation more flexible, let *H~T~* (*x*)
denote the number of *∆*-right-isolated

> uniquely honest slots among the slots from *T* in *x ∈ {*0*,* 1*,
> ⊥}R*, we hence have *h* = *H~T~* (*x*) for
>
> *x f*

*Z,A*

. Furthermore, let *E* .6. {*x ∈ {*0*,* 1*, ⊥}R \| H~T~* (*x*) *\<
cαs/*4} where *c* = *c*(*f, ∆*) = *f* (1 *−f* )*^∆^*.

Observe that *E* is monotone, and hence *^f^*

*Z,A*

> *::: Df* implies
>
> Pr\[*h \< cαs/*4\] = Pr
>
> *f*
>
> *Z,A*

\[*H~T~* (*x*) *\< cαs/*4\] Pr

> *x←D~α~*

\[*H~T~* (*x*) *\< cαs/*4\]

and it is sufficient to bound upper-bound the last probability.

Consider now a characteristic string *x* sampled according to *Df* and
for each *t ∈ T* , let *X~t~* be the indicator random variable for the
event that *s*ˆ*l~t~* is *∆*-right-isolated uniquely honest. Observe

> that *µ* .6. E\[*X* \] = *p p^∆−^*^1^ *αf* (1 *f* )*^∆^* according to
> Definition [11](#_bookmark40) and [(6)](#_bookmark39), and that the
> random variables *X~t~* and *X~t~I ⊥*are independent if *\|t − t^t^\|
> ≥ ∆* (as they depend on the leader sets of non- overlapping sets of
> slots). If we let *T~z~* = *{t ∈ T \| t ≡ z* mod *∆}*, then the family
> of variables *X~t~*
>
> indexed by *T~z~* are independent. Note also that *\|T~z~\| \> l*(*s
> −* 2*∆*)*/∆J ≥* (*s −* 3*∆*)*/∆* and that we may

write *T* as the disjoint union *T*~0~ *∪ · · · ∪ T~∆−~*~1~. By the
Chernoff bound of Appendix [E](#useful-probability-theoretic-tools) with
*δ* = 1*/*2,

for each *T~z~*

> Pr I *X \< µ\|T \|/*21 *≤ e^−µ\|T^z\|/*20 *≤ e^−^ µ*(*s−*3*∆*) *.*
>
> Observe that if *t∈Tz X~t~ ≥ µ\|T~z~\|/*2 for each *z* then also
> *H~T~* (*x*) = *t∈T X~t~ ≥ µ\|T \|/*2 *≥ µs*ˆ*/*2, where we let *s*ˆ
> .6. *s −* 2*∆*. It follows from the union bound that
>
> *µ*(*s−*3*∆*)
>
> Pr
>
> *x←Df*
>
> \[*H~T~* (*x*) *\< µs*ˆ*/*2\] *≤ ∆ · e^−^*
>
> 20*∆ .*
>
> As *µ ≥ αf* (1 *− f* )*^∆^*, we obtain
>
> Pr
>
> *x←Df*
>
> \[*H~T~* (*x*) *\< cαs*ˆ*/*2\] Pr
>
> *x←D~α~*
>
> \[*H~T~* (*x*) *\< µs*ˆ*/*2\] *≤ ∆ · e^−^*

*c·α*(*s−*3*∆*)

> 20*∆ .*

Since *s ≥* 4*∆*, we have *s*ˆ *≥ s/*2 and we can conclude that

> Pr
>
> *x←Df*

\[*H~T~* (*x*) *\< cαs/*4\] = *∆ · e^−^*

*c·α*(*s−*3*∆*)

> 20*∆ .*

Applying the union bound over the *R* slots, we conclude that the
probability that there is a chain growth violation with parameters *s*
and *τ* = *cα/*4 is no more than

> *R∆* exp(*−cα*(*s −* 3*∆*)*/*(20*∆*)) = exp(*−cα*(*s −*
> 3*∆*)*/*(20*∆*) + ln *R∆*) *.*

*un*

Our chain quality statement of Theorem [7](#_bookmark49) is a direct
consequence of Lemma [4,](#_bookmark48) which observes that a
sufficiently long sequence of consecutive blocks in an honest party's
chain will most likely []{#_bookmark48 .anchor}contain a block created
in a *∆*-right-isolated uniquely honest slot.

> **Lemma 4.** *Let k, ∆ ∈* N *and E ∈* (0*,* 1)*. Let A be an
> α-dominated adversary against the pro- tocol π*~SPoS~ *for some α \>*
> 0 *satisfying α*(1 *− f* )*^∆^* = (1 + *E*)*/*2*. Let B*~1~*, . . . ,
> B~k~ be a sequence of consecutive blocks in a chain C possessed by an
> honest party. Then at least one block B~i~ was created in a
> ∆-right-isolated uniquely honest slot, except with probability*
> exp(*−Ω*(*k*))*.*

*Proof (sketch).* For convenience, let us call a slot *good* if it is
*∆*-right-isolated uniquely honest, and *bad* if it is neither empty nor
good. Moreover, we call a block good (resp. bad) if it comes from a good
(resp. bad) slot.

Towards contradiction, assume that all blocks *B*~1~*, . . . , B~k~* are
bad. Let *G*~1~ denote the latest good block preceding *B*~1~ in *C*,
and *G*~2~ the earliest good block appearing after *B~k~* in *C* (or the
last block of *C*, if there is no good one). Note that all blocks
between *G*~1~ and *G*~2~ are bad.

Let *s*ˆ*l*~1~ (resp. *s*ˆ*l*~2~) denote the good slot in which *G*~1~
(resp. *G*~2~) was created (if *G*~2~ is not good, let *s*ˆ*l*~2~ be the
current slot). Denote by *T* the continuous sequence of slots between
*s*ˆ*l*~1~ and *s*ˆ*l*~2~, excluding *s*ˆ*l*~1~ and including
*s*ˆ*l*~2~. As we argued in the proof of Theorem [6,](#_bookmark47) in
each good slot in *T*

the (unique) leader creates a block that has depth increased by at least
1 compared to the block from the previous good slot. Therefore, we have
**d**(*G*~2~) *≥* **d**(*G*~1~) + *g*, where *g* is the number of good
slots in *T* . However, in chain *C* we have **d**(*G*~2~)
**d**(*G*~1~) + *b*, where *b* is the number of bad slots in

the same sequence *T* . These two conditions can only be satisfied at
the same time if *g b*, we will now show that this is very unlikely.

Consider *E* = *x* 0*,* 1*, ^R^ g*(*x*) *b*(*x*) , where *g*(*x*) and
*b*(*x*), as intuition suggests, denote the numbers of good and bad
slots on the positions indexed by *T* in the string *x*, respectively.
We

again observe that *E* is monotone and therefore *^f^*

*Z,A*

> *::: Df* implies

Pr

> *f*
>
> *Z,A*

\[*g*(*x*) *b*(*x*)\] Pr

> *x←D~α~*

\[*g*(*x*) *≤ b*(*x*)\]

and it is sufficient to bound upper-bound the last probability. However,
we know that *α*(1 *f* )*^∆^* = (1 + *E*)*/*2 and as we observed in
[(11)](#_bookmark43), this implies that good slots are sampled with
higher probability

than bad slots. Therefore, the probability that *g*(*x*) *≤ b*(*x*) for
*x ← Df* falls exponentially with *k*. *un*

> []{#_bookmark49 .anchor}Lemma [4](#_bookmark48) directly implies the
> following theorem.
>
> **Theorem 7 (Chain quality).** *Let k, R, ∆ ∈* N *and E ∈* (0*,* 1)*.
> Let A be an α-dominated adversary against the protocol π*~SPoS~ *for
> some α \>* 0 *satisfying α*(1*−f* )*^∆^ ≥* (1+*E*)*/*2*. Then the
> probability that A, when executed in a ∆-semisynchronous environment,
> makes π*~SPoS~ *violate the chain quality property with parameters k
> and µ* = 1*/k throughout a period of R slots, is no more than* exp(ln
> *R − Ω*(*k*))*.*

## Adaptive Adversaries

The statements in the previous sections give us guarantees on the common
prefix, chain growth, and chain quality properties as long as the
adversary is *α*-dominated for some suitable value of *α*. In Section
[4.3](#the-dominant-characteristic-distribution) we argued that any
*static* adversary that corrupts at most (1 *α*)-fraction of stake is
*α*-dominated. In this section we extend this claim also to *adaptive*
adversaries, showing that as long as they corrupt no more than (1
*α*)-fraction of stake adaptively throughout the whole execution,
[]{#_bookmark51 .anchor}they are still *α*-dominated.

> **Theorem 8.** *Every adaptive adversary that corrupts at most* (1
> *α*)*-fraction of stake throughout the whole execution is
> α-dominated.*

*Proof (sketch).* Let us start by taking a different (but equivalent)
view on the choice of slot leaders in the execution of *π*~SPoS~.
Assuming that we have a fixed number *C* of coins (corresponding to
equally-sized units of stake), consider a family of independent,
identically distributed Boolean

> random variables *{c~t,i~ \|* 1 *≤ t ≤ R,* 1 *≤ i ≤ C}* such that for
> every *c~t,i~* we have
>
> 1 with probability *φ~f~* (1*/C*) = 1 *−* (1 *− f* )^1*/C*^,

We can view each of the random variables *c~t,i~* as being associated
with a particular coin owned by one of the parties. These random
variables provide an alternative view of the slot leader election
process: the owner of coin *i* becomes a slot leader for slot *t* if
*c~t,i~* = 1. Thanks to the "independent aggregation property"
[(2),](#_bookmark14) sampling the random variables *c~t,i~* yields a
distribution on slot leaders equivalent to the method used by *π*~SPoS~,
i.e., switching to this method of assigning slot leaders does

not affect *^f^*

*Z,A*

for any adversary *A*.

> We now make the adversary stronger by allowing it to corrupt not only
> stakeholders, but indi-

vidual coins. (Formally, we can see each stakeholder with stake *s~i~*
as *s~i~* separate stakeholders where each controls a single coin;
corrupting a coin then means corrupting such single-coin stakeholder. In
particular, this means that after corrupting coin *i* in some slot *t*,
the adversary also learns the values

of the random variables *c~t~I,i* for all *t^t^ ≥ t*.) To see that this
only extends the class of considered adversaries, observe that any
adversary *A* corrupting stakeholders can be trivially modified into a
coin-corrupting adversary *A*~1~ that simply corrupts all the coins
belonging to the stake of a player

corrupted by , maintaining *^f^*

*Z,A*

> *Z,A*1 .

It is now important to observe that at any point during the execution,
all the uncorrupted

coins are identical from the perspective of the adversary due to
symmetry. Therefore, for any coin-corrupting adversary *A*~1~ one can
construct another coin-corrupting adversary *A*~2~ that achieves the
same outcomes, but corrupts the coins according to some fixed ordering:
whenever *A*~1~ corrupts

a new coin, ~2~ instead corrupts the next coin in this ordering. The
only difference this makes

from the perspective of the adversary is that with any corruption of a
coin in slot *t*, the index *i* of random variables *c~t~I,i* for *t^t^
≥ t*, that are disclosed to it, changes. However, all these variables
are

independent and identically distributed, hence we again have *Df* = *Df*
.

> Finally, consider a static adversary *A*
>
> *Z,A*1 (1 *− ^Z,A^*2 *J* coins with respect

to the ordering used by *A*~2~. Then, during the execution, it acts
exactly like *A*~2~ would, except for

corruptions; this is possible, since any coins corrupted by *A*~2~ must
be already corrupted by *A*~3~ from

the beginning. Note that if we consider the natural coupling of the two
executions with ~2~ and ~3~,

where the same randomness is used, then the sets of coins chosen for
slot leaders will be the same in both executions; and moreover, in each
slot the set of coins corrupted by *A*~3~ is a superset of those
corrupted by *A*~2~. This implies that Pr\[*w*^(2)^ *::: w*^(3)^\] = 1,
where *w*^(*i*)^ is the random variable corresponding to the
characteristic string resulting from the execution with *A~i~*. Using
Theorem [11](#_bookmark108)

from Appendix [E,](#useful-probability-theoretic-tools) this in turn
implies *^f^*

*Z,A*2

> *::: DZ,A*3

. The proof is now concluded by observing

that *^f^*

3

the stake.

*::: Df* follows from Section
[4.3,](#the-dominant-characteristic-distribution) since *A*~3~ is static
and corrupts at most (1 *− α*)-share of

*un*

> Theorems [5,](#_bookmark46) [6,](#_bookmark47) [7](#_bookmark49) and
> [8](#_bookmark51) together give us the following corollary.
>
> **Corollary 1.** *Let A be an adaptive adversary against the protocol
> Π*~SPoS~ *that corrupts at most* (1 *− α*)*-fraction of stake. Then
> the bounds on common prefix, chain growth and chain quality given in
> Theorems [5,](#_bookmark46) [6,](#_bookmark47) [7](#_bookmark49) are
> satisfied for A.*

## The Resettable Protocol

With the analysis of these basic structural events behind us, we remark
that the same arguments apply to a modest generalization of the protocol
which permits the adversary some control over

the nonce. Specifically, we introduce a "resettable" initialization
functionality *Fr* , which permits

the adversary to select the random nonce from a family of *r*
independent and uniformly random

nonces. Specifically, *Fr* is identical to *F*~INIT~, with the following
exception:

> **--** Upon receiving the first request of the form (genblock req*,
> U~i~*) from some stakeholder *U~i~*, *Fr*
>
> samples a nonce *η ← {*0*,* 1*}λ*, defines a "nonce candidate" set *H*
> = *{η}*, and permits the
>
> adversary to carry out up to *r −* 1 *reset events*: each reset event
> draws an independent element
>
> from *{*0*,* 1*}λ*, adds the element to the set *H*, and permits the
> adversary to replace the current nonce *η* with any element of *H*.
> Finally, (genblock*,* S~0~*, η*) is sent to *U~i~*. Later requests
> from any
>
> stakeholder are answered using the same value *η*.
>
> Looking ahead, our reason to introduce the resettable functionality
> *Fr* is to capture the

limited grinding capabilities of the adversary. A simple application of
the union bound shows that

this selection of *η* from among a set of size *r* uniformly random
candidate nonces can inflate the probability of events during the run of
*π*~SPoS~ by a factor no more than *r*. We record this as a
[]{#_bookmark52 .anchor}corollary below.

> **Corollary 2 (Corollary to Theorems [5,](#_bookmark46)
> [6,](#_bookmark47) [7).](#_bookmark49)** *The protocol Π*~SPoS~*, with
> initialization func-*
>
> *tionality Fr*
>
> *, satisfies the bounds of Theorems [5,](#_bookmark46)
> [6,](#_bookmark47) [7](#_bookmark49) with all probabilities scaled by
> r.*

# The Full Protocol

In this section, we construct a protocol that handles the dynamic case,
where the stake distribution changes as the protocol is executed. As in
Ouroboros \[[KRDO17](#_bookmark83)\], we divide protocol execution in a
number of independent *epochs* during which the stake distribution used
for sampling slot leaders remains unchanged. The strategy we use to
bootstrap the static protocol is, at a high level, similar: we first
show how the protocol can accommodate dynamic stake utilizing an ideal
"leaky beacon" functionality and then we show this beacon functionality
can be simulated via an algorithm that collects randomness from the
blockchain.

In order to facilitate the implementation of our beacon, we need to
allow the leaky beacon functionality to be adversarially manipulated by
allowing a number of "resets" to be performed by the adversary.
Specifically, the functionality is parameterized by values *τ* and *r*.
First, it leaks to the adversary, up to *τ* slots prior to the end of an
epoch, the beacon value for the next epoch. (Looking ahead, we remark
that it is essential that the stake distribution used for sampling slot
leaders in the next epoch is determined prior to this leakage.) Second,
the adversary can *reset* the value returned by the functionality as
many as *r* times. As expected for a beacon, it reports to honest
parties the beacon value only once the next epoch starts. After the
epoch is started no

more resets are allowed for the beacon value. This mimics the
functionality *F*~INIT~ and its resettable

version *Fr* . Note that the ability of the adversary to reset the
beacon can be quite influential

in the protocol execution: for instance, any event that depends
deterministically on the nonce of

an epoch and happens with probability 1*/*2 can be easily forced to
happen almost always by the adversary using a small number of resets.

Naturally, we do not want to assume the availability of a randomness
beacon in the final protocol, even if it is leaky and resettable. In our
final iteration of the protocol we show how it is possible to simulate
such beacon using a hash function that is modeled as a random oracle.
This hash function is applied to the concatenation of VRF values that
are inserted into each block, using values from all blocks up to and
including the middle 8*k* slots of an epoch that lasts approximately
24*k* slots in entirety. (The "quiet" periods before and after this
central block of slots that sets the nonce will ensure that the stake
distribution, determined at the beginning of the epoch, is stable, and
likewise that the nonce is stable before the next epoch begins.) The
verifiability of those values is a key property that we exploit in the
proof.

Our proof strategy is to reduce any adversary against the basic
properties of the blockchain to a resettable-beacon adversary that will
simulate the random oracle. The key point of this reduction

is that whenever the random oracle adversary makes a query with a
sequence of values that is a candidate sequence for determining the
nonce for the next epoch, the resettable attacker detects this as a
possible reset opportunity and resets the beacon; it obtains the
response from the beacon and sets this as the answer to the random
oracle query.

The final issue is to bound the number of resets: towards this, note
that the adversary potentially controls a constant fraction of the 8*k*
slots associated with nonce selection, and this allows him to explore an
a priori large space of independent random potential nonces (and,
ultimately, select one as the next epoch nonce). The size of this space
is however upper-bounded by the number of random oracle queries that the
adversary can afford during the sequence of 8*k* slots. To formalize
this bound we utilize the *q*-bounded model of \[[GKL15](#_bookmark76)\]
that bounds the number of queries the adversary can pose per round: in
that model, the adversary is allowed *q* queries per adversarial

party per round ("slot" in our setting).[^5^](#_bookmark54) Assuming
that the adversary controls *t* parties, we obtain a bound equal to *≈*
8*qtk*.

## The Dynamic Stake Case with a Resettable Leaky Beacon

First we construct a protocol for the dynamic stake case assuming access
to a resettable leaky beacon that provides a fresh nonce for each epoch.
This beacon is leaky in the sense that it allows the adversary to obtain
the nonce for the next epoch before the epoch starts, and resettable in
the sense that it allows the adversary to reset the nonce a number of
times. We model the resettable

leaky randomness beacon in functionality *Fτ,r*

presented in Figure [8.](#_bookmark53)

> Fig. 8: Functionality *Fτ,r* .

We now describe protocol *π*~DPoS~, which is a modified version of
*π*~SPoS~ that updates its genesis block *B*~0~ (and thus the assignment
of slot leader sets) for every new epoch. The protocol also adopts an
adaptation of the static maxvalid*~S~* function, defined so that it
narrows selection to those chains which share common prefix.
Specifically, it adopts the following rule, parametrized by a prefix
length *k*:

> Function maxvalid( *,* C). Returns the longest chain from C that does
> not fork from more than *k* blocks. If multiple exist it returns , if
> this is one of them, or it returns the one that is listed first in C.

The protocol *π*~DPoS~ is described in Figure [9](#_bookmark55) and
functions in the []{#_bookmark54 .anchor}*Fτ,r*

-hybrid model.

> ^5^ Note that we utilize the *q*-bounded model only to provide a more
> refined analysis; given that the total length of the execution is
> polynomial in *λ* one may also use the total execution length as a
> bound.
>
> []{#_bookmark55 .anchor}**Protocol** *π*DPoS

The protocol *π*DPoS is run by stakeholders, initially equal to *U*1*, .
. . , Un* interacting among themselves

> and with ideal functionalities *F^τ,r^*
>
> (or *F*~INIT~), *F*~VRF~*, F*~KES~*, F*~DSIG~*,* H over a sequence of
> *L* = *ER* slots
>
> *S* = *{sl*~1~*, . . . , sl~L~}* consisting of *E* epochs with *R*
> slots each. Define *T^j^* .6. 2*^£^*VRF *φ~f~* (*α^j^*) as the
> threshold for
>
> *i* *i*
>
> a stakeholder *U~i~* for epoch *e~j~*, where *α^j^* is the relative
> stake of stakeholder *U~i~* at epoch *e~j~*, *R*~VRF~ denotes the
> output length of *F*~VRF~, *f* is the active slots coefficient and
> *φ~f~* is the mapping from Definition [1.](#_bookmark13) Then *π*DPoS
> proceeds as follows:

1.  **Initialization.** This step is the same as Step [1](#_bookmark17)
    > in *π*~SPoS~ except that any messages for *F*~INIT~ are

> sent to *F^τ,r^*
>
> if it is available instead.

2.  **Chain Extension.** After initialization, for every slot *sl ∈ S*,
    > every online stakeholder *Ui* performs

> the following steps:

a.  This step is the same as Step [2a](#_bookmark18) in *π*SPoS.

b.  If a new epoch *ej* , with *j ≥* 2, has started, *Ui* defines S*j*
    > to be the stakeholder distribution drawn from the most recent
    > block with time stamp up to (*j −* 2)*R* as reflected in *C*
    > (where *τ*

> parameterizes *F^τ,r^*
>
> ) and sends (epochrnd req*, sid, Ui, ej* ) to *Fτ,r*
>
> , receiving (epochrnd*, sid, ηj* )
>
> as answer.

c.  *Ui* collects all valid chains received via diffusion into a set C,
    > pruning blocks be- longing to future slots and verifying that for
    > every chain *C^t^ ∈* C and every block

> *t t t t t t t*
>
> *B* = (*st , d , sl , B~π~ , ρ , σ~j~I* ) *∈ C* it holds that the
> stakeholder who created it is in
>
> the slot leader set of slot *sl^t^* (by parsing *Bπt* as (*Us, y^t^,
> π^t^*) for some *s*, verifying that
>
> *F*~VRF~ responds to (Verify*, sid, η~j~ I sl^t^ I* TEST*, y^t^, π^t^,
> v*^vrf^ ) by (Verified*, sid, η~j~ I sl^t^ I* TEST*, y^t^, π^t^,* 1),
>
> and that *y^t^ \< T ^j^*
>
> where *T^j^*
>
> is the threshold of stakeholder *Us* for the epoch *ej* to
>
> which *sl^t^* belongs), that *F*~VRF~ responds to (Verify*, sid, η~j~
> I sl^t^ I* NONCE*, ρ^t^ , ρ^t^ , v*^vrf^ ) (where

*y π s*

> *ρ^t^* = (*ρ^t^ , ρ^t^* )) by (Verified*, sid, η~j~ I sl^t^ I* NONCE*,
> ρ^t^ , ρ^t^ ,* 1), and that *F*~KES~ responds to

*y π*

*t t t*

> *t t t*

kes

> *y π*

*t t t*

> *t t t*
>
> (Verify*, sid,* (*st , d , sl , B~π~ , ρ* )*, sl , σ~j~I , v~s~* ) by
> (Verified*, sid,* (*st , d , sl , B~π~ , ρ* )*, sl ,* 1). *U~i~* com-
> putes *C^t^* = maxvalid(*C,* C), sets *C^t^* as the new local chain
> and sets state *st* = *H*(head(*C^t^*)).

d.  *U~i~* sends (EvalProve*, sid, η~j~ I sl I* NONCE) to *F*~VRF~,
    > obtaining (Evaluated*, sid, ρ~y~, ρ~π~*), Afterwards,

> *U~i~* sends (EvalProve*, sid, η~j~ I sl I* TEST) to *F*~VRF~,
> receiving (Evaluated*, sid, y, π*). *U~i~* checks
>
> whether it is in the slot leader set of slot *sl* with respect to the
> current epoch *ej* by check- ing that *y \< Tj* . If yes, it generates
> a new block *B* = (*st, d, sl, Bπ, ρ, σ*) where *st* is its
>
> current state, *d ∈ {*0*,* 1*}^∗^* is the transaction data, *Bπ* =
> (*Ui, y, π*), *ρ* = (*ρy, ρπ* ) and *σ* is a signature obtained by
> sending (USign*, sid, U~i~,* (*st, d, sl, B~π~, ρ*)*, sl*) to *F*~KES~
> and receiving (Signature*, sid,* (*st, d, sl, Bπ, ρ*)*, sl, σ*). *Ui*
> computes *C^t^* = *C\|B*, sets *C^t^* as the new local chain and sets
> state *st* = *H*(head(*C^t^*)). Finally, if *Ui* has generated a block
> in this step, it diffuses *C^t^*.

3.  **Signing Transactions.** This step is the same as Step
    > [3](#_bookmark21) in *π*SPoS.

Fig. 9: Protocol *π*~DPoS~

*Lazy players.* Note that while the protocol *π*~DPoS~ in Figure
[9](#_bookmark55) is stated for a stakeholder that is permanently
online, this requirement can be easily relaxed. Namely, it is sufficient
for an honest stakeholder to join at the beginning of each epoch,
determine whether she belongs to the slot leader set for any slots
within this epoch (using the Eval interface of ~VRF~), and then come
online and act on those slots while maintaining online presence at least
every *k* slots. For now we only sketch this variant in Appendix
[H](#a-lazy-variant-of-πdpos) and defer a formal treatment of this
property of our protocol to a later version.

We proceed to the security analysis of this protocol in the hybrid world
where the functionality *RLB* is available to the protocol participants.
A key challenge is that in the dynamic stake setting, the honest
majority assumption that we have in place for the stakeholders refers to
the stakeholder view of the honest stakeholders in each slot. Already in
the first few slots this assumption may

diverge rapidly from the stakeholder distribution that is built-in the
genesis block.

To accommodate the issues that will arise from the movement of stake
throughout protocol execution, we recall the notion of stake shift
defined in [\[KRDO17\].](#_bookmark83)

> **Definition 13.** *Consider two slots sl*~1~*, sl*~2~ *and an
> execution . The* stake shift between *sl*~1~*, sl*~2~ *is the maximum
> possible statistical distance of the two weighted-by-stake
> distributions that are defined using the stake reflected in the chain
> C*~1~ *of some honest stakeholder active at sl*~1~ *and the chain
> C*~2~ *of some honest stakeholder active at sl*~2~*.*

Finally, the security of *π*~DPoS~ is stated below. We slightly abuse
the notation from previous []{#_bookmark62 .anchor}sections and denote
by *α~H~* a *lower bound* on the honest stake ratio throughout the whole
execution.

> **Theorem 9 (Security of** *π*~DPoS~ **with access to** *Fτ,r* **).**
> *Fix parameters k, R, ∆, L ∈* N*, E, σ ∈*
>
> (0*,* 1) *and r. Let R ≥* 16*k/*(1 + *E*) *be the epoch length, L the
> total lifetime of the system, and*
>
> []{#_bookmark63 .anchor}*α~H~*(1 *− f* )*^∆^ ≥* (1 + *E*)*/*2 + *σ .*
> (12)
>
> *The protocol π*~DPoS~*, with access to Fτ,r , with τ ≤* 8*k/*(1 +
> *E*) *satisfies persistence with parameters*
>
> *k and liveness with parameters u* = 8*k/*(1 + *E*) *throughout a
> period of L slots of ∆-semisynchronous*
>
> *execution with probability* 1 exp(ln *L* + *∆* + log(*r*) *Ω*(*k*))
> *assuming that σ is the maximum stake shift over R slots.*

*Proof (sketch).* We first observe that due to the conditions imposed on
the leakiness of the *^τ,r^* oracle, its level of resettability, and the
domination of honest stake even after the stake shift is taken into
account, Corollary [2](#_bookmark52) still applies for the whole
execution over *L* slots. The critical observation is the fact that the
stakeholder distribution is determined in each epoch *j* 2 by the block
that has time stamp up to (*j* 2)*R*. Since *R* 16*k/*(1 + *E*) and *τ*
8*k/*(1 + *E*) it holds that at least *R τ* 8*k/*(1 + *E*) slots will
pass before the leaky beacon releases the random value of the next
epoch. By applying the chain growth theorem with *s* = 8*k/*(1 + *E*) we
obtain that, except with

> error exp *−f* (1 *− f* )*^∆^αs/*(20*∆*) + ln *L∆* + *O*(1) = exp
> (*−Ω*(*k*) + ln *L* + ln *∆*) the chain will grow by *f* (1 *f*
> )*^∆^α~H~/*4 *u* (1 + *E*)*/*8 *u* = *k* blocks in that period of
> slots and thus the stakeholder

distribution is completely determined prior to the leaky beacon
releasing the random value of the next epoch. Based on the above, we
observe that any violation of persistence in the execution with
parameter *k* results in the violation of common prefix with parameter
*k*. Applying a union bound, we obtain an error of exp(ln *L* + *∆* +
log(*r*) *Ω*(*k*)).

We then examine liveness. Consider any transaction that is provided to
the honest parties for a sequence of *u* = 8*k/*(1 + *E*) slots it will
follow, as before that by chain growth the chain will grow by *k*
blocks. Then, by the chain quality property this means that at least one
honest block will be

added and hence this block will contain the transaction posted. *un*

Note that while Theorem [9](#_bookmark62) (and also Corollary
[3](#_bookmark65) below) formulates the bound [(12)](#_bookmark63) in
terms of the *overall* upper bound on honest stake ratio *α~H~* and
*maximum* stake shift *σ* over any *R*-slots interval, one could easily
prove more fine-grained statements that would only require inequality
[(12)](#_bookmark63) to hold for each epoch, with respect to the honest
stake ratio and stake shift *in this epoch*.

2.  **Instantiating *F^τ,r^***

In this section, we show how to substitute the oracle *Fτ,r*

of protocol *π*~DPoS~ with a subprotocol

> *π* that simulates *Fτ,r*
>
> *RLB*
>
> *F* -hybrid

model as in Section [3](#the-static-stake-protocol) (without resets)
while utilizing a random oracle H( ). The sub-protocol *π~RLB~*

is described in Figure [10.](#_bookmark64)

Fig. 10: Protocol *π~RLB~*.

> We will show next that the sub-protocol *π~RLB~* can safely substitute
> *Fτ,r* when called from

protocol *π*~DPoS~. We will perform our analysis in the *q*-bounded
model of \[[GKL15](#_bookmark76)\] assuming that

the adversary is capable of issuing *q* queries per each round of
protocol execution per corrupted party and there are *t* corrupted
parties.

> **Lemma 5.** *Consider the event of violating one of common prefix,
> chain quality, chain growth in an execution of π*~DPoS~ *using
> sub-protocol π~RLB~ in the F*~INIT~*-hybrid model with adversary A and
> environment Z with the same parameter choices as Theorem
> [9.](#_bookmark62) We construct an adversary At so that the
> corresponding event happens with the same probability in an execution
> of π*~DPoS~ *in the*
>
> *τ,r*
>
> *RLB*

*-hybrid world with adversary At and environment Z assuming that r* =
8*tqk/*(1 + *E*)*.*

*Proof (sketch).* The adversary *At* simulates *A* by maintaining
locally the table for the random oracle H(*·*). The key point in the
simulation of *A* is to detect when is appropriate for *At* to issue

a reset query to its *Fτ,r* oracle. Specifically, a reset query will be
triggered whenever *A* queries

> H(*·*) with concatenated valid VRF values *η~j−~*~1~ *Ij Iρ~i~ I · · ·
> Iρ~i~I* that are drawn from a valid chain

and, specifically, from the first block of epoch *e~j~* to a block of
that epoch with time stamp between

8*k/*(1 + *E*) and 16*k/*(1 + *E*). We observe that by chain growth and
chain quality at least one honest block in the middle 8*k/*(1 + *E*)
slots of an epoch will be included in the chain of all honest parties

and contribute to the calculation of the hash. Finally, when the epoch
*e~j~* reaches an end, *At* will

issue (epochrnd set*, w*) query to *Fτ,r* to set the value of the beacon
to the correct value *w* of the

H( ) table as it has been determined by the chain that is on the common
prefix that consists of all

the blocks of the epoch that contains blocks produced in the first
16*k/*(1 + *E*) slots of the epoch. Note that the event that the
*η~j−~*~1~ *Ij Iρ~i~ I · · · Iρ~i~I* sequence corresponding to that
chain in the

common prefix was never queried to H(*·*) happens with negligible
probability. *un*

Based on the above lemma, it is now easy to revisit Theorem
[9,](#_bookmark62) and show that the same result holds for *r* in the
*q*-bounded model assuming *r* = 8*tkq/*(1 + *E*) and *τ* 8*k/*(1 + *E*)
which permits to []{#_bookmark65 .anchor}set our epoch length *R* to
24*k/*(1 + *E*).

> **Corollary 3 (Security of** *π*~DPoS~ **with subprotocol**
> *π~RLB~***).** *Fix parameters k, R, ∆, L ∈* N*, E, σ ∈* (0*,* 1)*.
> Let R* = 24*k/*(1 + *E*) *be the epoch length, L the total lifetime of
> the system, and α~H~*(1 *− f* )*^∆^ ≥* (1 + *E*)*/*2 + *σ. The
> protocol π*~DPoS~ *using subprotocol π~RLB~ in the* ~INIT~*-hybrid
> model satisfies persistence with parameters k and liveness with
> parameters u* = 8*k/*(1 + *E*) *throughout a period of L*
>
> *slots of ∆-semisynchronous execution with probability* 1 exp(ln *L* +
> *∆ Ω*(*k* log *tkq*)) *assuming that σ is the maximum stake shift over
> R slots.*

# References

> []{#_bookmark66 .anchor}BGM14. Iddo Bentov, Ariel Gabizon, and Alex
> Mizrahi. Cryptocurrencies without proof of work. *CoRR*,
> []{#_bookmark67 .anchor}abs/1406.5694, 2014.
>
> BGM16. Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies
> without proof of work. In Jeremy Clark, Sarah Meiklejohn, Peter Y. A.
> Ryan, Dan S. Wallach, Michael Brenner, and Kurt Rohloff, editors, *FC
> 2016 Workshops*, volume 9604 of *LNCS*, pages 142--157. Springer,
> []{#_bookmark68 .anchor}Heidelberg, February 2016.
>
> BLMR14. Iddo Bentov, Charles Lee, Alex Mizrahi, and Meni Rosenfeld.
> Proof of activity: Extending bitcoin's proof of work via proof of
> stake. *SIGMETRICS Performance Evaluation Review*, []{#_bookmark69
> .anchor}42(3):34--37, 2014.
>
> BM99. Mihir Bellare and Sara K. Miner. A forward-secure digital
> signature scheme. In Michael J. Wiener, editor, *CRYPTO'99*, volume
> 1666 of *LNCS*, pages 431--448. Springer, Heidelberg, August
> []{#_bookmark70 .anchor}1999.
>
> Can04. Ran Canetti. Universally composable signature, certification,
> and authentication. In *17th IEEE Computer Security Foundations
> Workshop, (CSFW-17 2004)*, page 219. IEEE Computer Society,
> []{#_bookmark71 .anchor}2004.
>
> CL07. Melissa Chase and Anna Lysyanskaya. Simulatable VRFs with
> applications to multi-theorem NIZK. In Alfred Menezes, editor, *CRYPTO
> 2007*, volume 4622 of *LNCS*, pages 303--322. []{#_bookmark72
> .anchor}Springer, Heidelberg, August 2007.
>
> Com14. The NXT Community. Nxt whitepaper.
> [https://bravenewcoin.com/assets/Whitepapers/](https://bravenewcoin.com/assets/Whitepapers/NxtWhitepaper-v122-rev4.pdf)
> []{#_bookmark73
> .anchor}[NxtWhitepaper-v122-rev4.pdf](https://bravenewcoin.com/assets/Whitepapers/NxtWhitepaper-v122-rev4.pdf),
> July 2014.
>
> DLS88. Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer.
> Consensus in the presence of partial []{#_bookmark74
> .anchor}synchrony. *J. ACM*, 35(2):288--323, 1988.
>
> DP07. Yevgeniy Dodis and Prashant Puniya. Feistel networks made
> public, and applications. In Moni Naor, editor, *EUROCRYPT 2007*,
> volume 4515 of *LNCS*, pages 534--554. Springer, Heidelberg,
> []{#_bookmark75 .anchor}May 2007.
>
> DPS16. Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Provably
> secure proofs of stake. Cryptology ePrint Archive, Report 2016/919,
> 2016. <http://eprint.iacr.org/2016/919>.
>
> []{#_bookmark77 .anchor}DY05. Yevgeniy Dodis and Aleksandr Yampolskiy.
> A verifiable random function with short proofs and keys. In Serge
> Vaudenay, editor, *PKC 2005*, volume 3386 of *LNCS*, pages 416--431.
> Springer, []{#_bookmark76 .anchor}Heidelberg, January 2005.
>
> GKL15. Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The
> bitcoin backbone protocol: Analysis
>
> and applications. In Elisabeth Oswald and Marc Fischlin, editors,
> *EUROCRYPT 2015, Part II*, volume 9057 of *LNCS*, pages 281--310.
> Springer, Heidelberg, April 2015. Updated version at []{#_bookmark78
> .anchor}<http://eprint.iacr.org/2014/765>.
>
> IR01. Gene Itkis and Leonid Reyzin. Forward-secure signatures with
> optimal signing and verifying. In
>
> Joe Kilian, editor, *CRYPTO 2001*, volume 2139 of *LNCS*, pages
> 332--354. Springer, Heidelberg, []{#_bookmark79 .anchor}August 2001.
>
> JKK14. Stanislaw Jarecki, Aggelos Kiayias, and Hugo Krawczyk.
> Round-optimal password-protected
>
> secret sharing and T-PAKE in the password-only model. In Palash Sarkar
> and Tetsu Iwata, editors, *ASIACRYPT 2014, Part II*, volume 8874 of
> *LNCS*, pages 233--253. Springer, Heidelberg, []{#_bookmark80
> .anchor}December 2014.
>
> KKO77. T. Kamae, U. Krengel, and G. L. O'Brien. Stochastic
> inequalities on partially ordered spaces.
>
> []{#_bookmark81 .anchor}*Ann. Probab.*, 5(6):899--912, 12 1977.
>
> KN12. Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency
> with proof-of-stake.
> [https:](https://peercoin.net/assets/paper/peercoin-paper.pdf)
>
> []{#_bookmark82
> .anchor}[//peercoin.net/assets/paper/peercoin-paper.pdf](https://peercoin.net/assets/paper/peercoin-paper.pdf),
> August 2012.
>
> KP15. Aggelos Kiayias and Giorgos Panagiotakos. Speed-security
> tradeoffs in blockchain protocols.
>
> []{#_bookmark83 .anchor}Cryptology ePrint Archive, Report 2015/1019,
> 2015. <http://eprint.iacr.org/2015/1019>.
>
> KRDO17. Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman
> Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain
> protocol. In Jonathan Katz and Hovav Shacham, editors, *CRYPTO 2017,
> Part I*, volume 10401 of *LNCS*, pages 357--388. Springer, Heidelberg,
> []{#_bookmark84 .anchor}August 2017.
>
> Lin09. Andrew Y. Lindell. Adaptively secure two-party computation with
> erasures. In Marc Fischlin,
>
> []{#_bookmark85 .anchor}editor, *CT-RSA 2009*, volume 5473 of *LNCS*,
> pages 117--132. Springer, Heidelberg, April 2009. []{#_bookmark86
> .anchor}Mic16. Silvio Micali. ALGORAND: the efficient and democratic
> ledger. *CoRR*, abs/1607.01341, 2016. MR95. Rajeev Motwani and
> Prabhakar Raghavan. *Randomized Algorithms*. Cambridge University
>
> []{#_bookmark87 .anchor}Press, New York, NY, USA, 1995.
>
> Nak08. Satoshi Nakamoto. "the proof-of-work chain is a solution to the
> byzan- tine generals' problem". The Cryptography Mailing List,
> https://www.mail- []{#_bookmark88
> .anchor}archive.com/cryptography@metzdowd.com/msg09997.html, November
> 2008.
>
> PS16. Rafael Pass and Elaine Shi. The sleepy model of consensus.
> Cryptology ePrint Archive, Report
>
> []{#_bookmark89 .anchor}2016/918, 2016.
> <http://eprint.iacr.org/2016/918>.
>
> PSS17. Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the
> blockchain protocol in asynchronous networks. In Jean-S´ebastien Coron
> and Jesper Buus Nielsen, editors, *EUROCRYPT 2017,* []{#_bookmark90
> .anchor}*Part II*, volume 10211 of *LNCS*, pages 643--673. Springer,
> Heidelberg, May 2017.
>
> RMKQ17. Alexander Russell, Cristopher Moore, Aggelos Kiayias, and Saad
> Quader. Forkable strings are
>
> []{#_bookmark91 .anchor}rare. Cryptology ePrint Archive, Report
> 2017/241, 2017. <http://eprint.iacr.org/2017/241>. Str65. V. Strassen.
> The existence of probability measures with given marginals. *Ann.
> Math. Statist.*,
>
> 36(2):423--439, 04 1965.

# Definitions

In this appendix, we present formal definitions of Verifiable Random
Functions and Key Evolving Signature Schemes with Forward Security.

## Verifiable Random Functions

[]{#_bookmark94 .anchor}We present formal definitions of Verifiable
Random Functions from [\[DY05\].](#_bookmark77)

> **Definition 14 (Verifiable Random Function).** *A function family*
> F*~·~*( ) : 0*,* 1 *^.t^* 0*,* 1 *^.t^*VRF *is a family of VRFs if
> there exist algorithms* (Gen*,* Prove*,* Ver) *such that (i.)*
> Gen(1*^k^*) *outputs a pair of keys* (VRF*.pk,* VRF*.sk*)*, (ii.)*
> Prove~VRF*.sk*~(*x*) *outputs a pair* (F~VRF*.sk*~(*x*)*,
> π*~VRF*.sk*~(*x*))*, where* F~VRF*.sk*~(*x*) *∈ {*0*,* 1*}.t*VRF *is
> the function value and π*~VRF*.sk*~(*x*) *is the proof of correctness,
> and (iii.)* Ver~VRF*.pk*~(*x, y, π*~VRF*.sk*~(*x*)) *verifies that y*
> = F~VRF*.sk*~(*x*) *using proof π*~VRF*.sk*~(*x*)*, outputting* 1 *if
> y is valid and* 0 *otherwise. Additionally, we require the following
> properties:*

1.  ***Uniqueness:** no values* (VRF*.pk, x, y, y^t^,
    > π*~VRF*.sk*~(*x*)*, π*~VRF*.sk*~(*x*)*^t^*) *can satisfy both*

> Prove~VRF*.pk*~(*x, y, π*~VRF*.sk*~(*x*)) = 1 *and*
> Prove~VRF*.pk*~(*x, y^t^, π*~VRF*.sk*~(*x*)*^t^*) = 1
>
> *unless y* = *y^t^.*

2.  ***Provability:** if y, π*~VRF*.sk*~(*x*) = Prove~VRF*.sk*~(*x*)*,
    > then* Ver~VRF*.pk*~(*x, y, π*~VRF*.sk*~(*x*)) = 1*.*

3.  ***Pseudorandomness:** for any PPT algorithm A* = (*A~E~, A~J~* )*,
    > which runs for a total of s*(*k*)

> *steps when its first input is* 1*^k^, and does not query the*
> Prove(*·*) *oracle on x,*
>
> *k*

 I (*x, A~st~*) *← A*^Prove(*·*)^(VRF*.pk*);  1

## Digital Signatures and *F*~DSIG~

In Figure [11,](#_bookmark95) we present Functionality *F*~DSIG~ as
defined in \[[Can04](#_bookmark70)\], where it is also shown that
EUF-CMA signature schemes realize ~DSIG~. This functionality will be
used to model signatures on transactions.

Fig. 11: Functionality *F*~DSIG~.

## Forward Secure Signatures Schemes

We present the formal definitions of key evolving signature schemes and
forward security of \[[BM99](#_bookmark69),[IR01](#_bookmark78)\].

> []{#_bookmark97 .anchor}**Definition 15 (Key Evolving Signature
> Schemes).** *A key evolving signature scheme* KES = (Gen*,* Sign*,*
> Verify*,* Update) *is a tuple of algorithms such that:*

1.  Gen(1*^k^, T* ) *is a probabilistic key generation algorithm that
    > takes as input a security parameter* 1*^k^ and the total number of
    > periods T , outputting a key pair* (KES*.sk*~1~*,* KES*.vk*)*,
    > where* KES*.vk is the verification key and* KES*.sk*~1~ *is the
    > initial signing key (we assume that the period j to which a
    > signing key* KES*.sk~j~ corresponds is encoded in the signing key
    > itself).*

2.  SignKES*.skj* (*m*) *is a probabilistic signing algorithm that takes
    > as input a secret key* KES*.sk~k~est for the time period j ≤ T and
    > a message m, outputting a signature σ~j~ on m for time period j
    > (we assume that the period j for which a signature σ~j~ was
    > generated is encoded in the signature*

> *itself).*

3.  VerifyKES*.vk*(*m, σ~j~*) *is a deterministic verification algorithm
    > that takes as input a public key* KES*.vk, a message m and a
    > signature σ~j~, outputting* 1 *if σ~j~ is a valid signature on
    > message m for time period j and* 0 *otherwise.*

4.  Update(KES*.sk~j~*) *is a probabilistic* secret key update
    > *algorithm that takes as input a secret key* KES*.sk~j~ for the
    > current time period j and outputs a new secret key*
    > KES*.sk~j~*~+1~ *for time period j* + 1*. We define* KES*.sk~T~*
    > ~+1~ *as the empty string and set it as the output of*
    > Update(KES*.sk~T~* )*.*

> ***Correctness:** for every key pair* (KES*.sk*~1~*,* KES*.vk*) *←*
> Gen(1*^k^, T* )*, every message m and every time period j ≤ T ,*
>
> VerifyKES*.vk*(*m,* SignKES*.skj* (*m*)) = 1*.*

Given a key evolving signature scheme, forward security is defined by a
game that starts as the standard Chosen Message Attack (CMA) experiment
but after a number of queries to the signing oracle allows the adversary
to learn the signing key for the current time period. The adversary is
successful if it can produce a valid signature on a message of its
choice for an earlier time period. []{#_bookmark98 .anchor}The
experiment and forward security are formally defined as follows.

> **Definition 16 (Forward Security Experiment).** *A forger is a pair
> of algorithms F* = (*F*~cma~*, F*~forge~)
>
> *such that F*~cma~ *has access to a signing oracle. For a key pair*
> (KES*.vk,* KES*.sk*~1~) *←* Gen(1*^k^, T* )*, F*~cma~ *is given*
> KES*.vk and T and queries the signing oracle q~sig~ times with
> adaptively chosen message and time period pairs, outputting the set of
> queried message and time period pairs CM, the set of corresponding
> signatures sign*(*CM* ) *and a time period b. Given CM, sign*(*CM* )
> *and the signing key* KES*.sk~b~ for time period b, F*~forge~
> *outputs* (*m, σ~j~*) *← F*~forge~(*CM, sign*(*CM* )*,* KES*.sk~b~*)*.
> F is successful if* (*m, j*) */ CM, j \< b and* VerifyKES*.vk*(*m,
> σ~j~*) = 1*. (The two components of F can communicate the necessary
> information, including T and b through CM.)*
>
> []{#_bookmark99 .anchor}**Definition 17 (Forward Security).** *Let*
> **Succ***^fwsig^*(KES\[*k, T* \]*, F* ) *be the probability (over the
> random coins of* KES *and F) that F is successful in the forward
> security experiment of Defini- tion [16.](#_bookmark98) Let the
> function* **InSec***^fwsig^*(KES\[*k, T* \]*, t, q~s~ig*) *(the*
> insecurity *function) be the maximum of* **Succ***^fwsig^*(KES\[*k, T*
> \]*, F* )*, over all algorithms F that are restricted to running time
> t and q~s~ig signature queries. A key evolving signature scheme* KES
> *is forward secure against an adversary that runs in time t and makes
> q~s~ig signature queries if* **Succ***^fwsig^*(KES\[*k, T* \]*, F* )
> *is negligible in k.*

# Realizing *F*~KES~

We will follow the proof strategy of \[[Can04](#_bookmark70)\] to show
that a construction based on a key evolving signature scheme (Definition
[15)](#_bookmark97) realizes *F*~KES~. Our construction *π~KES~* is
based on a key evolving signature scheme KES = (Gen*,* Sign*,* Verify*,*
Update). The signature protocol *π~KES~* is run between a

> stakeholder *U~S~* and stakeholders *U*~1~*, . . . , U~n~*, proceeding
> as follows:

-   **Key Generation:** When *U~S~* receives an input (KeyGen*, sid,
    > U~S~*) , it runs Gen(1*^k^, T* ), records the signing key (sid*,*
    > KES*.*sk~1~*,*), sets counter k~ctr~ = 1 and outputs
    > (VerificationKey*, sid,* KES*.vk*).

-   **Signature and Update:** When *U~S~* receives an input (Sign*, sid,
    > U~S~, m, j*) for a *sid* for which it has the signing key (sid*,*
    > U~S~*,* KES*.*sk~k~ctr *,*) and that k~ctr~ *≥ j ≤ T* . Otherwise,
    > it ignores the input. First, *U~S~* performs the following steps
    > until k~ctr~ = *j*: run Update(KES*.sk*~k~ctr ) to obtain

> KES*.sk*~k~ctr+1, securely erase KES*.sk*~k~ctr and increment k~ctr~.
> Next, It runs SignKES*.sk*k

ctr

(*m*) to

> obtain *σ*~k~ctr , runs Update(KES*.sk*~k~ctr ) to obtain
> KES*.sk*~k~ctr+1, securely erases KES*.sk*~k~ctr , outputs
>
> (Signature*, sid, m,* k~ctr~*, σ*~k~ctr ) and increments k~ctr~.
>
> **-- Verification:** When a stakeholder *U~i~* receives an input
> (Verify*, sid, m, j, σ~j~,* KES*.vk^t^*), it outputs (Verified*, sid,
> m, j,* Verify~KES*.vk*~*I* (*m, σ~j~*)).
>
> **Theorem 1** *The π~KES~ construction presented above, realizes*
> ~KES~ *with erasures assuming* KES = (Gen*,* Sign*,* Verify*,* Update)
> *is a key evolving signature scheme with forward security as per
> Defini- tion [15](#_bookmark97) and Definition [17.](#_bookmark99)*

*Proof.* We follow the approach of \[[Can04](#_bookmark70)\] by showing
that an environment *Z* that distinguishes an ideal execution with a
prescribed simulator *S* and *F*~KES~ from a real execution with an
adversary *A* and *π~KES~* can be used to construct a forger for the
underlying key evolving signature scheme *σ*

that is successful in the forward security experiment of Definition
[16](#_bookmark98) with non-negligible probability, thus contradicting
the forward security guarantee of *σ*. We argue that since *Z* can
distinguish the real world execution from the idea world execution for
any *Z*, it will also succeed for an specific simulator *S*. Simulator
*S* runs an internal copy of *A*, proceeding as follows:

-   *S* forwards any inputs from *Z* to *A* and any outputs from *A* to
    > *Z*.

-   Upon receiving (KeyGen*, sid, U~S~*) from *F*~KES~, *S* runs
    > Gen(1*^k^, T* ), records the signing key (sid*,* U~S~*,*
    > KES*.*sk~1~*,*), sets counter k~ctr~ = 1 and sends
    > (VerificationKey*, sid, U~S~*KES*.vk*) to *F*~KES~.

-   Upon receiving (Signature*, sid, U~S~, j, m*) from *F*~KES~, *S*
    > checks that k~ctr~ *≥ j ≤ T* . Otherwise, it ignores the request.
    > First, *S* performs the following steps until k~ctr~ = *j*: run
    > Update(KES*.sk*~k~ctr ) to obtain KES*.sk*~k~ctr+1, securely erase
    > KES*.sk*~k~ctr and increment k~ctr~. Next, *S* runs
    > SignKES*.sk*kctr (*m*)

> to obtain *σ*~k~ctr , runs Update(KES*.sk*~k~ctr ) to obtain
> KES*.sk*~k~ctr+1, securely erases KES*.sk*~k~ctr , sends (Signature*,
> sid, U~S~, m,* k~ctr~*, σ*~k~ctr ) to *F*~KES~ and increments k~ctr~.

-   Upon receiving (Verify*, sid, m, j, σ,* KES*.vk^t^*) from *F*~KES~,
    > *S* sends (Verified*, sid, m, j,* Verify~KES*.vk*~*I* (*m, σ~j~*))
    > to *F*~KES~.

-   When *A* corrupts a party *U^t^*, *S* corrupts *U^t^* in the ideal
    > world. If *U^t^* = *U~S~* (*i.e.* the signer), *S*

reveals the signing key KES*.sk*~k~ctr and the internal state of Sign
(if there's any) as the state of

> *U~t~*.

Given an environment *Z* that distinguishes an ideal execution with
simulator *S* and *F*~KES~ from a real execution with *A* and *π~KES~*,
we will construct a forger *F* = (*F*~cma~*, F*~forge~) for the
underlying key evolving signature scheme *σ*. Our forger *F* will run an
internal copy of *Z*, simulating for *Z* the interactions with *S* and
*F*~KES~ (*i.e.* acting as *S* and *F*~KES~ towards *Z*). Moreover, *F*
will run an internal copy of *A* as in the case of *S*.

Forger *F* starts execution as *F*~cma~ in the first phase of the
forward security game (as per Definition [16),](#_bookmark98) where it
is given a verification key KES*.vk* for total number of time periods
*T* and has access to signing oracle. When *F* is activated, it gives
*A* the verification key KES*.vk* obtained in

the forward security experiment. Whenever *F* has to generate a
signature as *S*, it calls its signing

oracle with the given message and current k~ctr~, which are added the
set of queried message and time

period pairs *CM* . The signatures obtained from the oracle are used in
the answers of the simulated *S* and added the set of signatures
*sign*(*CM* ) corresponding to *CM* . Whenever the internal *Z*
activates an uncorrupted party with (Verify*, sid, m, j, σ,*
KES*.vk^t^*), *F* tests whether (*m, j*) *∈/ CM* ,

Verify~KES*.vk*~*I* (*m, σ~j~*) and *j \<* k~ctr~. If this condition is
met and the signer is not corrupted, the triple (*m, j, σ*) can be used
by *F* to succeed in the forward security experiment. *F* outputs *CM* ,
*sign*(*CM* )

and k~ctr~ ending the first phase of the forward security game. Next,
acting as *F*~forge~ in the forward security game, it outputs (*m,
σ~j~*), succeeding in the experiment. If corrupts the signer, *F*
outputs

> and halts.

Following the same reasoning as in \[[Can04](#_bookmark70)\], we argue
that given the correctness property of *σ*, the internal environment *Z*
would not issue a query (Verify*, sid, m, j, σ,* KES*.vk^t^*), *F* such
that (*m, j*) *∈/ CM* , Verify~KES*.vk*~*I* (*m, σ~j~*) and *j \<*
k~ctr~ in the case that the signer is not corrupted. If this query
indeed does not happen, *Z* would not be able to distinguish between an
ideal and a real executions. However, this query happens with
non-negligible probability since we assume that *Z* does distinguish
real from ideal executions. Moreover, notice that the interactions with
*F*~KES~ from the point of view of *A* and *Z* are the same in a real
world execution with *π~KES~*, guaranteeing that

a forgery is obtained. *un*

# Realizing *F*~VRF~

We provide an implementation of ~VRF~ in the random oracle model using
two hash functions *H, H^t^* with ranges 0*,* 1 *^.t^*VRF and *g*
respectively with *g* = *q*. The implementation is based on the
2-Hash-DH verifiable oblivious PRF construction of
\[[JKK14](#_bookmark79)\]. Specifically, the public-key is equal to *v*
= *g^k^* and the output is *y* = *H*(*m, u*) where *u* =
*H^t^*(*m*)*^k^*, while the proof is set

to *π* = (*u,* EQDL(*k* : log*~H~I* (*m*)(*u*) = log*~g~*(*v*); *m,
v*)). The verification of (*m, y, π, v*) proceeds as follows. First it
parses *π* as (*u, π^t^*) where *π^t^* is a proof of equality of
discrete logarithms. It verifies

> *y* = *H*(*m, u*) as well as the proof *π^t^* and returns 1 if and
> only if both tests pass. The proof notation EQDL(*k* : log*~H~I*
> (*m*)(*u*) = log*~g~*(*v*); *m, v*) stands for the string (*c, s*)
> where *c* = *H*(*m, v, g^r^, H^t^*(*m*)*^r^*), *s* = *r* + *kc* mod
> *q*, while the verification of (*c, s*) on context *m, v* is performed
> by checking the

equality

> *c* = *H*(*m, v, g^s^v^−c^, H^t^*(*m*)*^s^u^−c^*) *.*
>
> **Theorem 2** *The 2Hash-DH construction presented above, realizes*
> ~VRF~ *in the random oracle model assuming the CDH.*

*Proof.* We describe a simulator that controls the random oracles *H,
H^t^* and operates in the following manner.

1.  Upon receiving a message (KeyGen*, sid, U~i~*) from *F*~VRF~, a new
    > value *v* = *g^k^* is selected for a random *k* and *S* inserts
    > (*U~i~, v*) in its internal registry of keys; in case the key
    > exists already, *S* returns fail and terminates. It returns to
    > *F*~VRF~ the message (VerificationKey*, sid, U~i~, v*).

2.  Upon receiving a message (EvalProve*, sid, U~i~, m*) from *F*~VRF~,
    > this is matched to the verification

> key *v* of *U~i~* and is checked whether *m* has been queried before.
> In such case, the value *u* that
>
> corresponds to *m* in the table for *v* is recovered. In case *m* was
> not queried before, it is checked whether *H^t^*(*m*) is defined. In
> such case the entry (base*, m, t*) is recovered, the value *u* is set
> to *v^t^* and the triple (*v, m, u*) is stored for future reference.
> In case the value *H^t^*(*m*) is undefined selects *t* at random,
> stores (base*, m, t*) and sets *H^t^*(*m*) = *g^t^*. Subsequently
> random *c, s* values are selected by ; the pair ((*m, v, g^s^v^−c^,
> H^t^*(*m*)*^s^u^−c^*)*, c*) is inserted to the table of the random
>
> oracle *H*. In case this is not feasible (because that would make the
> table inconsistent), outputs fail and terminates. Finally, *π* is set
> to (*u,* (*c, s*)) and the message (Eval*, sid, m, π*) is returned to
> *F*~VRF~.

3.  Upon receiving (Verify*, sid, m, y, π, v^t^*) from *F*~VRF~, parse
    > *π* as (*u^t^,* (*c, s*)) and verify the proof

> (*c, s*) as a proof of equality of discrete logarithms,
> log*~g~*(*v^t^*) = log*~H~I* (*m*)(*u^t^*), to obtain a bit *b*. Now
> observe that (base*, m, t*) must be recorded, and set *b^t^* =
> ((*u^t^*)^1*/t*^ = *v^t^*) (*H*(*m, u*) = *y*). If *b* = *b^t^* output
> fail and terminate. In any other case, return (Verified*, sid, m, y,
> π, v^t^*) to ~VRF~.

4.  Upon receiving a query *m* for the random oracle *H^t^*, select *t*
    > at random, store (base*, m, t*) and

> return *g^t^*.

5.  Upon receiving a query for the random oracle *H* of the form (*m,
    > u*), and the value (base*, m, t*) is stored previously, performs
    > the following. First, if *v* = *u*^1*/t*^ is not registered as a
    > public-key it registers (KeyGen*, sid, v*) with ~VRF~. Then it
    > submits (Eval*, sid, u*^1*/t*^*, m*) to the ~VRF~. If ~VRF~
    > ignores the request terminates with fail. Else it obtains the
    > response *y* which is set as the

> random oracle output to the query (*m, u*). In case (base*, m, t*) is
> not stored, then perform the step that corresponds to the query
> *H^t^*(*m*) above and repeat the current step.
>
> Other queries to *H* are handled by returning random elements of
> *{*0*,* 1*}.t*VRF .

We observe that unless *S* outputs fail the simulation of protocol
2Hash-DH is perfect. We next argue that the probability to output fail
is negligible. outputs fail in the case that ~VRF~

ignores a request (Eval*, sid, u*^1*/t*^*, m*). This means that the key
*v* = *u*^1*/t*^ is registered with an honest

party that has not evaluated *m*. It follows that the event an adversary
that produces such *u* can be turned to solver for the CDH assumption.
The other cases where *S* produces fail, specifically, step

1 and step 3 can be easily seen to be negligible probability events.
*un*

# Insecurity of the Original Ouroboros Against Adversarial Message Delays

This appendix informally describes several attacks against the
Proof-of-Stake protocol Ouroboros proposed in
\[[KRDO17](#_bookmark83)\], when used in various environments that allow
the adversary to control message delays to some extent.

> We consider two variants of the semi-synchronous model. With
> *sender-side delays*, each message

can be delayed on the side of its sender, and hence after being delayed,
it arrives to all recipients in the same round. On the other hand, if we
allow for *recipient-side delays*, the each message can be delayed for a
different time period for each of its recipients. The latter model is
the one that we consider for our positive results in the main body of
the paper. Clearly this latter model gives more power to the adversary,
hence we explore it first here.

## Recipient-Side Delays

*The Model.* The model for recipient-side delays is identical to the one
given in Section [2.2.](#the-semi-synchronous-model)

*Attack Description.* Intuitively, the adversary aims to violate the
common prefix property by maintaining two tines that are growing at
approximately the same rate: so that their lengths never differ by more
than one block. This is achieved by disclosing the blocks mined in the
past *∆* rounds (which are distributed via the DDiffuse functionality
and hence can be delayed by ) in a controlled way to affect the decision
of the current slot leader (in case he is honest) about which of the two
tines to extend.

The attack can be performed even in the simple setting with a static
stake and slot leaders sampled by an idealized beacon. Moreover, it can
be carried out without any corrupted parties at

all (i.e., also if the adversarial stake ratio *α~A~* = 0), as long as
maintains control over message

delays.

> In detail, *A* behaves as follows:

1.  Internally, *A* maintains two tines *T*~0~ and *T*~1~, initially
    > empty. Whenever any party diffuses a chain *C* such that some
    > *T~i~* is a prefix of *C*, *A* replaces *T~i~* with *C* (except
    > for the trivial initial case when any chain is a prefix of both
    > *T*~0~ and *T*~1~, here *A* only replaces *T*~0~).

2.  In each slot *sl~r~*:

    a.  Determine *T~s~*, the tine that is currently not longer, i.e.,
        > such that it satisfies *\|T~s~\| ≤ \|T*~1*−s*~*\|*.

    b.  Let *U~i~* denote the slot leader for the upcoming slot
        > *sl~r~*~+1~. If a message containing *T~s~* was diffused in
        > this round, *A* delivers it to the inbox of *U~i~* and to the
        > delayed*j* -strings for all

> other parties *j* =*/ i*. Otherwise, if a message containing *T~s~* is
> already present in delayed*i*, *A*
>
> removes it from delayed*i* and delivers it to the inbox of party
> *U~i~*.

c.  *A* moves all messages diffused in this round into the
    > delayed-strings of all parties.

## Sender-Side Delays

We now argue that the original Ouroboros protocol is insecure even
against sender-side adversarial message delays.

*The Model.* We consider an ideal functionality SDiffuse*~∆~* that is
defined exactly as the functionality

Diffuse given in [\[KRDO17\],](#_bookmark83) except for two differences:

1.  When the adversary is activated, besides performing any of the
    > actions that were allowed by the Diffuse functionality, it is also
    > allowed to:

-   move any message obtained in a diffuse request from a party to a
    > special string delayed,

-   move any message from the string delayed to the inboxes of all
    > parties.

    1.  At the end of each round, the functionality ensures that for
        > every message that was either

        a.  diffused in this round and not put to the string delayed
            > or (b) removed from the string delayed in this round, it
            > is present in the inboxes of all parties. If any message
            > currently present in delayed was originally diffused at
            > least *∆* slots ago, then the functionality removes it
            > from delayed and appends it to the inbox of all parties.

We again define our model by replacing Diffuse by SDiffuse*~∆~* in the
model of \[[KRDO17](#_bookmark83)\] (this gives us a class of models
parametrized by *∆*, setting *∆* = 0 again results in the original model
of [\[KRDO17\]).](#_bookmark83)

*Attack Description.* The adversary again aims to violate the common
prefix property by maintaining two tines that are growing at
approximately the same rate. However, this time it cannot deliver
messages selectively to future slot leaders, and hence the attack
requires a slight modification.

The details of the attack depend on the exact definition of the maxvalid
function that honest parties use to choose the winning chain, namely on
how it does tie-breaking in case of several equal-length chains.
According to \[[KRDO17](#_bookmark83)\], maxvalid should favor the
current chain *C* if it is the longest, otherwise choose arbitrarily.
There are several natural possibilities to perform this choice:

(i) [[]{#_bookmark104 .anchor}]{#_bookmark103 .anchor}Choose a chain
    > that was delivered first out of those with maximal length.

(ii) Choose a chain at random out of those with maximal length.

(iii) []{#_bookmark105 .anchor}Prefer an extension of the current chain
      > *C*. This is not fully specified, a rule to choose among
      > []{#_bookmark106 .anchor}several extensions of *C* with maximal
      > length is also needed.

(iv) Apply some fixed ordering rule, e.g. take the lexicographically
     > first out of the chains with maximal length.

We now sketch an attack for each of the cases above. The attacks can
again be performed even in the simple setting with a static stake, slot
leaders sampled by an idealized beacon, and without any corrupted
parties.

**Case [(i).](#_bookmark103)** The adversary starts by partitioning the
stakeholders into two sets *S*~0~ and *S*~1~ so that each of these sets
controls about one half of the total stake. It again maintains two tines
*T*~0~ and

> *T*~1~, and also keeps track of the prefixes *Tit* of each *T~i~* that
> were already delivered by SDiffuse*~∆~*
>
> to all parties. The goal of *A* is to maintain *\|T*0*t \|* = *\|T*1*t
> \|*, and make all parties in *S~i~* believe that
>
> *Tit* is their current chain. This is achieved as follows:

-   In each slot *sl~j~*, the slot leader *U~j~ ∈ S~i~* will extend
    > *Tit*.

-   *A* will delay this new block unless there is already also an
    > existing block in *T*~1*−i*~ *\\ T*1*t−i* that can be used to
    > extend both *T*0*t* and *T*1*t* by one block at the same time.

-   If this is the case, delivers both delayed blocks, extends both
    > *T*0*t* and *T*1*t* by one block,

> and uses its power to reorder messages in the inboxes of honest
> parties to maintain that parties in *S~i~* still consider the new
> *Tit* to be their current chain (note that parties follow the rule
> [((i))](#_bookmark103) above).
>
> The probability that a message would need to be delayed by for more
> than *∆* slots to follow this strategy decreases exponentially with
> *∆*.

**Case [(ii).](#_bookmark104)** A similar approach as in the case
[(i)](#_bookmark103) will work, with one small change. Here *A* does not

> need to choose partitions *S*~0~ and *S*~1~ and maintain them using
> its inbox-reordering capability. Instead, it can simply observe which
> of the chains *T*~0~*^t^* and *T*~1~*^t^* are being extended, and
> again only deliver extensions for both of them at the same time. By
> rule [(ii),](#_bookmark104) each stakeholder will choose its current
> chain by choosing at random between the new *T*0*t* and *T*1*t* . This
> will guarantee a quite even distribution of parties into *S*~0~ and
> *S*~1~ unless there are parties with a very large stake.

**Case [(iii)](#_bookmark105).** The same attack as in the case
[(i)](#_bookmark103) will work. Here the partitions *S*~0~ and *S*~1~
don't need to be maintained by inbox-reordering, each party will stay in
the same partition thanks to following the rule [(iii).](#_bookmark105)

**Case [(iv).](#_bookmark106)** The attacker *A* again maintains two
tines *T*~0~ and *T*~1~, and also keeps track of the prefixes

*Tit* of each *T~i~* that were already delivered by SDiffuse*~∆~* to all
parties. The goal of *A* is to make

> *T*~0~ and *T*~1~ grow at roughly the same speed.
>
> The attack starts by letting the honest slot leaders mine two separate
> length-1 tines from the
>
> genesis block (by delaying the first one). Denote these blocks
> *B*^(1)^ and *B*^(1)^, these will be the

0 1

> first blocks of *T*~0~ and *T*~1~, respectively. Now, delivers to all
> parties the one of these two blocks
>
> (say *B*^(1)^) that has lower preference in the fixed ordering given
> by the rule [(iv),](#_bookmark106) and hence the next honest slot
> leader will extend this tine by mining some block *B*^(2)^ on top of
> *B*^(1)^. *A*
>
> witholds *B*^(2)^ but now publishes *B*^(1)^ and due to the rule
> [(iv),](#_bookmark106) the next honest slot leader will
>
> *i* 1*−i*
>
> mine a block on top of *B*^(1)^ , call it *B*^(2)^ . Now *A* is in the
> same situation as before, hence it
>
> again delivers the one of the blocks *B*^(2)^ and *B*^(2)^ that has
> lower preference according to the
>
> 0 1
>
> rule [(iv).](#_bookmark106) The attack continues analogously. This
> attack only requires *∆ ≥* 2.

# Useful Probability-Theoretic Tools

In our arguments, we are using the following standard variant of the
Chernoff bound. See, e.g., \[[MR95](#_bookmark86)\] for a proof.

> **Theorem 10 (Chernoff bound).** *Let X*~1~*, . . . , X~T~ be
> independent random variables with* E\[*X~i~*\] =
>
> *p~i~ and X~i~ ∈* \[0*,* 1\]*. Let X* = L,*T X~i~ and µ* = L,*T p~i~*
> = E\[*X*\]*. Then, for all δ ≥* 0*,*
>
> [2]{.underline}
>
> **--** P\[*X ≥* (1 + *δ*)*µ*\] *≤ e^−^* 2+*δ µ;*
>
> **--** P\[*X ≤* (1 *− δ*)*µ*\] *≤ e^−^* 2+*δ µ.*
>
> []{#_bookmark108 .anchor}We also employ the following theorem.
>
> **Theorem 11 [(\[Str65\])](#_bookmark91).** *Let D*~1~ *and D*~2~ *be
> two distributions on a finite partially ordered set V with partial
> order :::. Then D*~1~ *::: D*~2~ *iff there is a pair of (typically
> dependent) random variables, X*~1~ *and X*~2~*, taking values in V so
> that each X~i~ is distributed according to D~i~, and* Pr\[*X*~1~ *:::
> X*~2~\] = 1*.*

(Note that the statement of this theorem overloads the notation ,
applying it both to distri- butions in the sense of Definition
[10](#_bookmark34) and elements of the partial order.) This result is
implicit in Strassen's 1965 article \[[Str65](#_bookmark91)\]; a
presentation with terminology closer to ours appears in Kamae et al.
[\[KKO77\].](#_bookmark80)

# From Executions to Forks

We define the useful notion of an *execution tree* that captures the
structure formed by all chains that are observed by any honest party
during an execution.

> **Definition 18 (Execution tree).** *Consider an execution E of the
> hybrid experiment. The* execu- tion tree *for this execution is a
> directed, rooted tree T~E~* = (*V, E*) *with a labeling £* : *V* N~0~
> *that is constructed during the execution as follows:*

(i) *At the beginning, V* = *{r}, E* = *∅ and £*(*r*) = 0*.*

(ii) *Every chain C^t^ that is input to* maxvalid *as a part of* C *in
     > Step [2b](#_bookmark19) or created as a new local chain in Step
     > [2c](#_bookmark20) of π*~SPoS~ *run by any honest party is
     > immediately processed block-by-block from the genesis block to*
     > head(*C^t^*)*. For every block B* = (*st^t^, d^t^, sl^t^,
     > B~π~^t^, σ~j~I* ) *processed for the first time:*

     -   *a new vertex v~B~ is added to V ;*

     -   *a new edge* (*v~B~− , v~B~*) *is added to E where B^−^ is the
         > unique block such that H*(*B^−^*) = *st^t^;*

     -   *the labeling £ is extended by setting £*(*v~B~*) = *sl^t^.*

We now observe that as desired, the execution tree of every execution is
among the forks for the characteristic string of that execution. Note
that technically, this conclusion is conditioned on no collisions in the
random oracle outputs. For the sake of improved readability, we neglect
the []{#_bookmark110 .anchor}possibility of such collisions in our
further considerations.

> **Lemma 6.** *For any execution of the hybrid experiment we have T~E~
> ~∆~ w~E~ , unless a collision in the responses of the random oracle
> occurs.*

*Proof (sketch).* Given an execution *E* and the resulting execution
tree *T~E~* , we need to prove that it satisfies the properties
[(i)](#_bookmark25)[--(v)](#_bookmark29) of Definition [6](#_bookmark24)
with respect to *w~E~* . Property [(i)](#_bookmark25) follows directly
from the definition of *T~E~* , while [(ii)](#_bookmark26) follows from
the order in which vertices in *T~E~* are created: every edge

is directed from an older vertex to a newer one and the root is the
first vertex created. Property [(iii)](#_bookmark28) is satisfied due to
the requirement in Definition [2](#_bookmark5) that the sequence of
slots in a valid blockchain is strictly increasing (otherwise, the chain
is rejected by *π*~SPoS~ as invalid). To see property
[(iv),](#_bookmark27)

note that by *π*~SPoS~, every uniquely honest slot leader will create a
block and this is immediately processed, resulting in a vertex with the
respective label in *T~E~* . Finally, property [(v)](#_bookmark29) is
satisfied as every uniquely honest slot leader will be aware of any
other such slot leader's block created at least

*∆* slots ago due to the guarantees provided by DDiffuse, and will hence
extend a chain that is at least as long as the one containing this
block. Note that several of our arguments above assume no

random oracle collisions. *un*

> Given Lemma [6,](#_bookmark110) we can later focus on investigating
> the properties of the distribution *Df* .

Roughly speaking, if we prove that a characteristic string sampled from
*^f^*

*Z,A*

*Z,A*

, with overwhelming

probability, does not allow for *any* "harmful" forks for it, then this
also implies that a random

execution with overwhelming probability results in a "harmless"
execution tree.

# Further Details on Forks, Forkability and Divergence

We introduce the notion of a forkable string that was central to the
analysis in [\[KRDO17\].](#_bookmark83)

> **Definition 19 (Height and tine intersection).** *The* height *of a
> fork (as usual for a tree) is defined to be the length of the longest
> tine. For two tines t*~1~ *and t*~2~ *of a fork F, we write t*~1~ *∼
> t*~2~ *if they share an edge. Note that ∼ is an equivalence relation
> on the set of nontrivial tines; on the other hand, if t~\_~ denotes
> the "empty" tine consisting solely of the root vertex then t~\_~ /∼ t
> for any tine t.*

The common prefix property in the synchronous case is studied by
focusing on a local property of "forkability".

> **Definition 20 (Flat forks and forkable strings).** *We say that a
> synchronous fork is* flat *if it has two tines t*~1~ */∼ t*~2~ *of
> length equal to the height of the fork. A string w ∈ {*0*,* 1*}∗ is
> said to be* forkable *if there is a flat synchronous fork F f-*~0~
> *w.*

A fundamental tool in the security analysis in the synchronous case is
an estimate of the number of forkable strings of a particular
[]{#_bookmark111 .anchor}length *k*. The original bound of 2^*−Ω*(^*√k*)
in \[[KRDO17](#_bookmark83)\] was strengthened to 2^*−Ω*(*k*)^ in
[\[RMKQ17\].](#_bookmark90)

> **Theorem 12 [(\[KRDO17,RMK](#_bookmark83)[Q17\]](#_bookmark90)).**
> *Let E ∈* (0*,* 1) *and let w be a string drawn from {*0*,* 1*}k by
> independently assigning each w~i~* = 1 *with probability* (1 *−
> E*)*/*2*. Then* Pr\[*w is forkable*\] = 2^*−Ω*(*k*)^*. The constant
> hidden by the Ω*(*·*) *notation depends only on E.*

As mentioned above, the notion of []{#_bookmark112 .anchor}forkability
is directly related to (synchronous) divergence; this is reflected by
the theorem below.

> **Theorem 13 [(\[KRDO17\])](#_bookmark83).** *Let w ∈ {*0*,* 1*}∗
> with* div~0~(*w*) *≥ k. Then there is a forkable substring*
>
> *w*ˇ *of w with \|w*ˇ*\| ≥ k.*

An immediate conclusion of Theorems [12](#_bookmark111) and Theorem
[13](#_bookmark112) is the following bound on the probability that a
synchronous characteristic string drawn from the binomial distribution
has large divergence.

> **Theorem 14 (Restatement of Theorem [3).](#_bookmark32)** *Let £, k
> ∈* N *and E ∈* (0*,* 1)*. Let w ∈ {*0*,* 1*}.t be drawn according to
> the binomial distribution, so that* Pr\[*w~i~* = 1\] = (1 *− E*)*/*2*.
> Then*
>
> Pr\[div~0~(*w*) *≥ k*\] *≤* exp(ln *£ − Ω*(*k*)) *.*
>
> A proof of a weaker bound of the form exp(ln *£ Ω*(*√k*)) appears in
> \[[KRDO17](#_bookmark83)\]. Russell et

al. \[[RMKQ17](#_bookmark90)\] then strengthened the basic probabilistic
tools used in \[[KRDO17](#_bookmark83)\] to achieve a bound of the form
exp(ln *£ Ω*(*k*)) for the local notion of *forkability*. For
completeness, we include a proof of Theorem [3](#_bookmark32) relying on
the results of [\[RMKQ17\].](#_bookmark90)

> *Proof (of Theorem [3).](#_bookmark32)* It follows from Theorem
> [13](#_bookmark112) that if div~0~(*w*) *k*, there is a forkable
> substring

*w*ˇ of length at least *k*. Thus

Pr\[div (*w*) *k*\] Pr *∃α, β ∈ {*1*, . . . , £}* so that *α* + *k −* 1
*≤ β* and

> *w~α~ . . . w~β~* is forkable
>
> *≤* Pr\[*w~α~ . . . w~β~* is forkable\] *.*
>
> \| ({*∗*z) }

According to Theorem [12](#_bookmark111) the probability that a string
of length *t* drawn from this distribution is forkable is no more than
exp(*−ct*) for a positive constant *c*. Note that for any *α ≥* 1,

> *.t*
>
> *t*=*α*+*k−*1

*e−ct ≤*

> *∞*
>
> *k−*1
>
> *e−ct dt* = (1*/c*)*e−c*(*k−*1) = *e−Ω*(*k*)

and it follows that the sum (*∗*) above is exp(*−Ω*(*k*)). Thus

> Pr\[div~0~(*w*) *≥ k*\] *≤ £ ·* exp(*−Ω*(*k*)) *≤* exp(ln *£ −
> Ω*(*k*)) *,*

as desired. *un*

# A Lazy Variant of *π*~DPoS~

This section sketches how the protocol *π*~DPoS~ can be easily modified
to significantly weaken the

requirement of all honest parties being online all the time. In the
modified protocol *π*^lazy^ given in

Figure [12,](#_bookmark114) every stakeholder comes online only at the
beginning of each epoch, determining for which of the slots in that
epoch he belongs into the slot leader set. Consequently, the stakeholder
can only come online in those slots and create blocks as usually.
Additionally, the stakeholder also makes sure that it is not offline for
*k* or more slots.

Note that this requires a slightly different mechanism of distributing
existing chains, as the lazy stakeholder needs a way to obtain a copy of
the current chain the moment he comes online. In theory, this can be
achieved by letting all stakeholders diffuse their current chain even if
they haven't added a block to it; in practice this would be handled by a
request mechanism where a stakeholder can ask for chains from other
nodes upon coming online.

Fig. 12: Protocol *π*^lazy^ .
